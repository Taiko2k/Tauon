#! /usr/bin/env python3
# -*- coding: utf-8 -*-


# Tauon Music Box

# Copyright Â© 2015-2019, Taiko2k captain(dot)gxj(at)gmail.com

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# --------------------------------------------------------------------
# Preamble

# Welcome to the Tauon Music Box source code. I started this project when I was first
# learning python, as a result this code can be quite messy. No doubt I have
# written some things terribly wrong or inefficiently in places.
# I would highly recommend not using this project as an example on how to code cleanly or correctly.

# --------------------------------------------------------------------

# artist info box def
# guitar chords def

import sys
import os
import pickle
import shutil

n_version = "4.4.0"
t_version = "v" + n_version
t_title = 'Tauon Music Box'
t_id = 'tauonmb'

print(t_title)
print(t_version)
print('Copyright 2015-2019 Taiko2k captain.gxj@gmail.com\n')

# Detect platform
windows_native = False
if sys.platform == 'win32':
    system = 'windows'
    windows_native = True
else:
    system = 'linux'
    import fcntl

if not windows_native:
    import gi
    from gi.repository import GLib

# Detect what desktop environment we are in to enable specific features
desktop = os.environ.get('XDG_CURRENT_DESKTOP')
de_nofity_support = desktop == 'GNOME' or desktop == 'KDE'

# Find the directory we are running from
install_directory = sys.path[0]

# Workaround for Py-Installer
if 'base_library' in install_directory:
    install_directory = os.path.dirname(install_directory)

# Set data folders (portable mode)
user_directory = install_directory
config_directory = user_directory
cache_directory = os.path.join(user_directory, "cache")
home_directory = os.path.join(os.path.expanduser('~'))
asset_subfolder = "/assets/"

# Detect if we are installed or running portably
install_mode = False
flatpak_mode = False
if install_directory[:5] == "/opt/" or install_directory[:5] == "/usr/" or install_directory[:5] == "/app/":
    install_mode = True
    if install_directory[:5] == "/app/":
        # Flatpak mode

        t_id = "com.github.taiko2k.tauonmb"
        print("Detected running as Flatpak")

        # Symlink fontconfig from host system as workaround for poor font rendering
        if os.path.exists(os.path.join(home_directory, ".var/app/com.github.taiko2k.tauonmb/config")):

            host_fcfg = os.path.join(home_directory, ".config/fontconfig/")
            flatpak_fcfg = os.path.join(home_directory, ".var/app/com.github.taiko2k.tauonmb/config/fontconfig")

            if os.path.exists(host_fcfg):

                if os.path.isdir(flatpak_fcfg) and not os.path.islink(flatpak_fcfg):
                    shutil.rmtree(flatpak_fcfg)
                if os.path.islink(flatpak_fcfg):
                    print("-- Symlink to user fonconfig exists")
                else:
                    print("-- Symlinking user fonconfig")
                    os.symlink(host_fcfg, flatpak_fcfg)

        flatpak_mode = True

# If we're installed, use home data locations
if install_mode and system == 'linux':

    old_user_directory = os.path.expanduser('~') + "/.tauonmb-user"

    cache_directory = os.path.join(GLib.get_user_cache_dir(), "TauonMusicBox")
    user_directory = os.path.join(GLib.get_user_data_dir(), "TauonMusicBox")
    config_directory = os.path.join(GLib.get_user_data_dir(), "TauonMusicBox")

    if not os.path.isdir(cache_directory):
        os.makedirs(cache_directory)

    if not os.path.isdir(user_directory):
        os.makedirs(user_directory)

    if not os.path.isdir(config_directory):
        os.makedirs(config_directory)

    print("Running from installed location")
    print("User files location: " + user_directory)

    if not os.path.isdir(os.path.join(user_directory, "encoder")):
        os.makedirs(os.path.join(user_directory, "encoder"))

    # Copy data from old location if needed (new location since v3.0.0)
    if not flatpak_mode:
        if os.path.isfile(os.path.join(old_user_directory, 'state.p')) and \
            not os.path.isfile(os.path.join(user_directory, 'state.p')):
                shutil.copy(os.path.join(old_user_directory, 'state.p'), os.path.join(user_directory, 'state.p'))

        if os.path.isfile(os.path.join(old_user_directory, 'star.p')) and \
            not os.path.isfile(os.path.join(user_directory, 'star.p')):
                shutil.copy(os.path.join(old_user_directory, 'star.p'), os.path.join(user_directory, 'star.p'))


elif system == 'windows' and ('Program Files' in install_directory or
                                  os.path.isfile(install_directory + '\\unins000.exe')):

    user_directory = os.path.expanduser('~').replace("\\", '/') + "/Music/TauonMusicBox"
    config_directory = user_directory
    cache_directory = user_directory + "\\cache"
    print("User Directroy: ", end="")
    print(user_directory)
    install_mode = True
    if not os.path.isdir(user_directory):
        os.makedirs(user_directory)


else:
    print("Running in portable mode")

    user_directory = os.path.join(install_directory, "user-data")
    config_directory = user_directory

    if not os.path.isdir(user_directory):
        os.makedirs(user_directory)

if not os.path.isdir(os.path.join(user_directory, "artist-pictures")):
    os.makedirs(os.path.join(user_directory, "artist-pictures"))

transfer_target = user_directory + "/transfer.p"
# print('Argument List: ' + str(sys.argv))
print('Install directory: ' + install_directory)
b_active_directory = install_directory.encode('utf-8')

# Find home music folder
music_folder = os.path.join(os.path.expanduser('~'), "Music")
if not os.path.isdir(music_folder):
    music_folder = None

# Things for detecting and launching programs outside of flatpak sandbox
def whicher(target):
    try:
        if flatpak_mode:
            complete = subprocess.run(shlex.split("flatpak-spawn --host which " + target), stdout=subprocess.PIPE,
                                      stderr=subprocess.PIPE)
            r = complete.stdout.decode()
            return "bin/" + target in r
        else:
            return shutil.which(target)
    except:
        return False

launch_prefix = ""
if flatpak_mode:
    launch_prefix = "flatpak-spawn --host "

# -------------------------------
# Single Instancing

pid = os.getpid()

if system == 'linux':
    if os.path.isfile('.gitignore'):
        print("Dev mode, ignoring single instancing")
    else:
        pid_file = os.path.join(user_directory, 'program.pid')
        fp = open(pid_file, 'w')
        try:
            fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError:
            # another instance is running
            print("Program is already running")
            pickle.dump(sys.argv, open(user_directory + "/transfer.p", "wb"))
            sys.exit()


if system == 'windows':
    from win32event import CreateMutex
    from win32api import CloseHandle, GetLastError
    from winerror import ERROR_ALREADY_EXISTS


    class singleinstance:
        """ Limits application to single instance """

        def __init__(self):
            self.mutexname = "tauonmusicbox_{A0E858DF-985E-4907-B7FB-7D732C3FC3B9}"
            self.mutex = CreateMutex(None, False, self.mutexname)
            self.lasterror = GetLastError()

        def aleradyrunning(self):
            return (self.lasterror == ERROR_ALREADY_EXISTS)

        def __del__(self):
            if self.mutex:
                CloseHandle(self.mutex)

    lock = singleinstance()

    if lock.aleradyrunning():
        print("Program is already running")
        pickle.dump(sys.argv, open(user_directory + "/transfer.p", "wb"))
        sys.exit()

# ------------------------------------
# Continue startup

# if install_directory != config_directory and not os.path.isfile(os.path.join(config_directory, "config.txt")):
#     print("Config file is missing... copying template from program files")
#     shutil.copy(os.path.join(install_directory, "config.txt"), config_directory)

if install_directory != config_directory and not os.path.isfile(os.path.join(config_directory, "input.txt")):
    print("Input config file is missing... copying template from program files")
    shutil.copy(os.path.join(install_directory, "input.txt"), config_directory)

last_fm_enable = False

try:
    import setproctitle
    setproctitle.setproctitle("tauonmb")
except:
    print("Could not set process title.")


# try:
#     import rpc
#     discord_allow = True
# except:
#     pass
try:
    from pypresence import Presence
    import asyncio
    discord_allow = True
except:
    discord_allow = False

if system == "windows":
    import win32con, win32api, win32gui, win32ui, comtypes
    import atexit

import time
import ctypes
import random
import threading
import logging
import io
import copy
import subprocess
import urllib.parse
import urllib.request
import datetime
try:
    import pylast
    last_fm_enable = True
except:
    print("PyLast moduel not found, last fm will be disabled.")
import shlex
import math
import locale
import webbrowser
import base64
import re
import zipfile
import warnings
import colorsys
import html
import requests
import stat
import xml.etree.ElementTree as ET
from pathlib import Path
from xml.sax.saxutils import escape
from ctypes import *
from PyLyrics import *
from send2trash import send2trash
import musicbrainzngs
import discogs_client
musicbrainzngs.set_useragent("TauonMusicBox", n_version, "https://github.com/Taiko2k/TauonMusicBox")

# -----------------------------------------------------------
# Detect locale for translations (currently none availiable)

locale.setlocale(locale.LC_ALL, "")
#locale.setlocale(locale.LC_ALL, ("ja_JP", "UTF-8"))

lc = locale.getlocale()
if lc[0] is not None and 'en' not in lc[0]:  # Remember to handle LANG potentionally being None
    try:

        print("Locale detected: ", end="")
        print(lc)

        import gettext
        lang = gettext.translation('tauon', os.path.join(install_directory, "locale"), lc)
        lang.install()

        print("Translation file loaded")

    except:
        print("No translation file available for this locale")
        def _(message):
            return message
else:
    def _(message):
        return message


# ------------------------------------------------

os.environ["SDL_VIDEO_X11_WMCLASS"] = t_title  # This sets the window title under some desktop environments

if system == 'windows':
    os.environ["PYSDL2_DLL_PATH"] = install_directory + "\\lib"
else:
    gi.require_version('Notify', '0.7')  # Doesn't really matter, just stops it from complaining
    from gi.repository import Notify


# Other imports
from sdl2 import *
from sdl2.sdlimage import *
from PIL import Image, ImageDraw, ImageFilter
from hsaudiotag import auto
import stagger
from stagger.id3 import *


from t_modules.t_tagscan import Flac
from t_modules.t_tagscan import Opus
from t_modules.t_tagscan import Ape
from t_modules.t_tagscan import Wav
from t_modules.t_tagscan import M4a
from t_modules.t_tagscan import parse_picture_block
from t_modules.t_extra import *

# Mute some stagger warnings
warnings.simplefilter('ignore', stagger.errors.EmptyFrameWarning)
warnings.simplefilter('ignore', stagger.errors.FrameWarning)
warnings.simplefilter('ignore', stagger.errors.Warning)

# Setting various timers

message_box_min_timer = Timer()
cursor_blink_timer = Timer()
animate_monitor_timer = Timer()
min_render_timer = Timer()
check_file_timer = Timer()
vis_rate_timer = Timer()
vis_decay_timer = Timer()
scroll_timer = Timer()
perf_timer = Timer()
quick_d_timer = Timer()
core_timer = Timer()
gallery_select_animate_timer = Timer()
gallery_select_animate_timer.force_set(10)
search_clear_timer = Timer()
lfm_dl_timer = Timer()
lfm_dl_timer.force_set(60)
gall_pl_switch_timer = Timer()
gall_pl_switch_timer.force_set(999)
d_click_timer = Timer()
d_click_timer.force_set(10)
#gall_render_last_timer = Timer(10)
lyrics_check_timer = Timer()
scroll_hide_timer = Timer(100)
get_lfm_wait_timer = Timer(10)
lyrics_fetch_timer = Timer(10)

vis_update = False
# GUI Variables -------------------------------------------------------------------------------------------

# Variables now go in the gui, pctl, input and prefs class instances. The following just haven't been moved yet.

draw_border = True
resize_mode = False

side_panel_text_align = 0

album_mode = False
spec_smoothing = True

# gui.offset_extra = 0

old_album_pos = -55
old_side_pos = 200
album_dex = []
album_artist_dict = {}
row_len = 5
last_row = 0
album_v_gap = 66
album_h_gap = 30
album_mode_art_size = 200

album_pos_px = 1
time_last_save = 0
window_default_size = [1110, 540]
window_size = window_default_size
b_info_y = int(window_size[1] * 0.7)  # For future possible panel below playlist
fullscreen = False

volume_store = 50  # Used to save the previous volume when muted

# row_alt = False

to_get = 0  # Used to store temporary import count display
to_got = 0

editline = ""
#gui.rsp = True
quick_drag = False

radiobox = False
radio_field_text = "http://0.0.0.0:8000"
renamebox = False


# Playlist Panel
pl_view_offset = 0
pl_rect = (2, 12, 10, 10)

theme = 7
themeChange = True

scroll_enable = True
scroll_timer = Timer()
scroll_timer.set()
scroll_opacity = 0
break_enable = True

source = None

album_playlist_width = 430

update_title = False

playlist_hold_position = 0
playlist_hold = False
selection_stage = 0

shift_selection = []
# Control Variables--------------------------------------------------------------------------

mouse_down = False
right_down = False
click_location = [200, 200]
last_click_location = [0, 0]
mouse_position = [0, 0]

k_input = True
key_shift_down = False
drag_mode = False
side_drag = False
clicked = False

# Player Variables----------------------------------------------------------------------------

format_colours = {  # These are the colours used for the label icon in UI 'track info box'
    "MP3": [255, 130, 80, 255],
    "FLAC": [156, 249, 79, 255],
    "M4A": [81, 220, 225, 255],
    "OGG": [244, 244, 78, 255],
    "WMA": [213, 79, 247, 255],
    "APE": [247, 79, 79, 255],
    "TTA": [94, 78, 244, 255],
    "OPUS": [247, 79, 146, 255],
    "AAC": [79, 247, 168, 255],
    "WV": [229, 23, 18, 255],
    "PLEX": [229, 160, 13, 255],
}

# These will be the extensions of files to be added when importing
DA_Formats = {'mp3', 'wav', 'opus', 'flac', 'ape',
              'm4a', 'ogg', 'aac', 'tta', 'wv', }

Archive_Formats = {'zip'}

if whicher('unrar'):
    Archive_Formats.add("rar")

if whicher('7z'):
    Archive_Formats.add("7z")

if system == 'windows':
    DA_Formats.add('wma')  # Bass on Linux does not support WMA

cargo = []

# ---------------------------------------------------------------------
# Player variables

# pl_follow = False

# List of encodings to check for with the fix mojibake function
encodings = ['cp932', 'utf-8', 'big5hkscs', 'gbk']  # These seem to be the most common for Japanese

track_box = False

transcode_list = []
transcode_state = ""

taskbar_progress = True
QUE = []

playing_in_queue = 0
draw_sep_hl = False

# -------------------------------------------------------------------------------
# Playlist Variables
playlist_view_position = 0
playlist_playing = -1
playlist_selected = -1

loading_in_progress = False

core_use = 0

random_mode = False
repeat_mode = False

# Functions to generate empty playlist
# Playlist is [Name, playing, playlist, position, hide folder title, selected, uid, last_folder, hidden(bool)]

# 0 Name (string)
# 1 Playing (int)
# 2 list  (list of int)
# 3 View Position (int)
# 4 hide playlist folder titles (bool)
# 5 selected (int)
# 6 Unique id (int)
# 7 last folder import path (string)
# 8 hidden (bool)
# 9 Locked (bool)
# 10 Filter parent playlist id (string)


def uid_gen():
    return random.randrange(1, 100000000)

def pl_gen(title='Default',
           playing=0,
           playlist=None,
           position=0,
           hide_title=0,
           selected=0,
           parent=""):

    if playlist == None:
        playlist = []

    return copy.deepcopy([title, playing, playlist, position, hide_title, selected, uid_gen(), "", False, False, parent])

multi_playlist = [pl_gen()] # Create default playlist

def queue_item_gen(trackid, position, pl_id, type=0, album_stage=0):
    # type; 0 is track, 1 is album
    auto_stop = False

    return [trackid, position, pl_id, type, album_stage, uid_gen(), auto_stop]


default_playlist = multi_playlist[0][2]
playlist_active = 0


quick_search_mode = False
search_index = 0

rename_index = 0

# ----------------------------------------
# Playlist right click menu

r_menu_index = 0
r_menu_position = 0

# Library and loader Variables--------------------------------------------------------
master_library = {}

cue_list = []

LC_None = 0
LC_Done = 1
LC_Folder = 2
LC_File = 3

loaderCommand = LC_None
loaderCommandReady = False

master_count = 0

load_orders = []

volume = 75

folder_image_offsets = {}
db_version = 0.0

albums = []
album_position = 0


class Prefs:    # Used to hold any kind of settings
    def __init__(self):
        self.colour_from_image = False
        self.dim_art = False
        self.prefer_side = True  # Saves whether side panel is shown or not
        self.pause_fade_time = 400
        self.change_volume_fade_time = 400
        self.cross_fade_time = 700 #700
        self.volume_wheel_increment = 2
        self.encoder_output = user_directory + '/encoder/'
        if music_folder is not None:
            self.encoder_output = music_folder + '/encode-output/'
        self.rename_folder_template = "<albumartist> - <album>"
        self.rename_tracks_template = "<tn>. <artist> - <title>.<ext>"

        self.enable_web = False
        self.allow_remote = False
        self.expose_web = True

        self.enable_transcode = True
        self.show_rym = False
        self.show_wiki = True
        self.show_transfer = True
        self.show_queue = True
        self.prefer_bottom_title = True
        self.append_date = True

        self.transcode_codec = 'opus'
        self.transcode_mode = 'single'
        self.transcode_bitrate = 64

        # self.line_style = 1
        self.device = 1
        self.device_name = ""

        self.cache_gallery = True
        self.gallery_row_scroll = False
        self.gallery_scroll_wheel_px = 90

        self.playlist_font_size = 15
        self.playlist_row_height = 22

        self.tag_editor_name = ""
        self.tag_editor_target = ""
        self.tag_editor_path = ""

        self.use_title = False
        self.auto_extract = False
        self.auto_del_zip = False
        self.pl_thumb = False

        self.linux_font = "Noto Sans" #"Liberation Sans"#
        self.linux_font_semibold = "Noto Sans Medium"
        self.linux_font_bold = "Noto Sans Bold"

        self.spec2_scroll = True

        self.spec2_p_base = [10, 10, 100]
        self.spec2_p_multiply = [0.5, 1, 1]

        self.spec2_base = [10, 10, 100]
        self.spec2_multiply = [0.5, 1, 1]
        self.spec2_colour_setting = 'custom'

        self.auto_lfm = False
        self.scrobble_mark = False
        self.enable_mpris = True

        self.server_port = 7590
        self.mkey = True
        self.replay_gain = 0  # 0=off 1=track 2=album
        self.radio_page_lyrics = True

        self.show_gimage = False
        self.end_setting = "stop"
        self.show_gen = False
        self.show_lyrics_side = True

        self.log_vol = False

        self.ui_scale = 1
        self.last_device = "PulseAudio Sound Server"

        # if flatpak_mode:

        self.transcode_opus_as = False

        self.discord_active = False
        self.discord_ready = False
        self.disconnect_discord = False

        self.monitor_downloads = True
        self.extract_to_music = False

        self.enable_lb = False
        self.lb_token = ""

        self.use_jump_crossfade = True
        self.use_transition_crossfade = False
        self.use_pause_fade = True

        self.show_notifications = False
        if de_nofity_support:
            self.show_notifications = True

        self.true_shuffle = True
        self.append_total_time = False
        self.backend = 1

        self.album_repeat_mode = False # passed to pctl
        self.album_shuffle_mode = False # passed to pctl

        self.finish_current = False  # Finish current album when adding to queue

        self.reload_play_state = False # Resume playback on app restart
        self.reload_state = None

        self.mono = False

        self.last_fm_token = None
        self.last_fm_username = ""

        self.use_card_style = True

        self.plex_username = ""
        self.plex_password = ""
        self.plex_servername = ""

        self.auto_lyrics = False
        self.auto_lyrics_checked = []

        self.show_side_art = True
        self.always_pin_playlists = True

        self.user_directory = user_directory
        self.cache_directory = cache_directory

        self.window_opacity = 1
        self.gallery_single_click = True
        self.custom_bg_opacity = 40

        self.tabs_on_top = True
        self.desktop = desktop

        self.dc_device = False  # (BASS) Disconnect device on pause
        if desktop == "KDE":
            self.dc_device = True

        self.showcase_vis = True
        self.show_lyrics_showcase = True

        self.spec2_colour_mode = 0
        self.flatpak_mode = flatpak_mode

        self.device_buffer = 40

        self.eq = [0.0] * 10
        self.use_eq = False

        self.bio_large = False
        self.discord_allow = discord_allow
        self.discord_show = False

        self.min_to_tray = False

        self.guitar_chords = False
        self.prefer_synced_lyrics = True
        self.sync_lyrics_time_offset = 0

        self.playback_follow_cursor = False
        self.short_buffer = False

        self.art_bg = False
        self.art_bg_stronger = 1
        self.art_bg_opacity = 10
        self.art_bg_blur = 9
        self.art_bg_always_blur = False

        self.random_mode = False
        self.repeat_mode = False

        self.failed_artists = []

        self.artist_list = False
        self.auto_sort = False

        self.transcode_inplace = False

        self.bg_showcase_only = False

        self.lyrics_enables = []
        self.apsed_ke = "4daMG8Oas53LFqXEaeFh8mA8UNGVg22JdJXCKxpxp8GtLcVJv29d3fAFYucaALk2"
        self.fatvap = "6b2a9499238ce6416783fc8129b8ac67"

        self.fanart_notify = True
        self.discogs_pat = ""

        self.artist_list_prefer_album_artist = False

        self.mini_mode_mode = 0
        self.dc_device_setting = "auto"

        self.download_dir1 = ""
        self.dd_index = False

        self.broadcast_port = 8000
        self.broadcast_bitrate = 128

        self.custom_encoder_output = ""
        self.column_aa_fallback_artist = False

        self.meta_persists_stop = False
        self.meta_shows_selected = False
        self.meta_shows_selected_always = False

        self.left_align_album_artist_title = False
        self.stop_notifications_mini_mode = False
        self.scale_want = 1
        self.mini_mode_micro_always_show_seek = False


prefs = Prefs()

def check_transfer_p():

    if check_file_timer.get() > 1.1:
        global arg_queue
        check_file_timer.set()
        if os.path.isfile(transfer_target):
            r_arg_queue = pickle.load(open(transfer_target, "rb"))
            os.remove(user_directory + "/transfer.p")
            arg_queue = []
            i = 0
            for item in r_arg_queue:
                if (os.path.isdir(item) or os.path.isfile(item)) and '.py' not in item or 'file://' in item:
                    arg_queue.append(item)
                    i += 1

            if i == 0:
                SDL_RaiseWindow(t_window)
                SDL_RestoreWindow(t_window)


        if arg_queue:

            i = 0
            while i < len(arg_queue):
                load_order = LoadClass()

                for w in range(len(pctl.multi_playlist)):
                    if pctl.multi_playlist[w][0] == "Default":
                        load_order.playlist = pctl.multi_playlist[w][6]  # copy.deepcopy(w)
                        break
                else:
                    # pctl.multi_playlist.append(["Default", 0, [], 0, 0, 0])
                    pctl.multi_playlist.append(pl_gen())
                    load_order.playlist = pctl.multi_playlist[len(pctl.multi_playlist) - 1][6]
                    switch_playlist(len(pctl.multi_playlist) - 1)

                load_order.target = str(urllib.parse.unquote(arg_queue[i])).replace("file:///", "/").replace("\r", "")
                if gui.auto_play_import is False:
                    load_order.play = True
                    gui.auto_play_import = True

                load_orders.append(copy.deepcopy(load_order))

                i += 1
            arg_queue = []

            #gui.auto_play_import = True


class GuiVar:   # Use to hold any variables for use in relation to UI
    def update_layout(self):
        global update_layout
        update_layout = True

    def show_message(self, line1, type="info", line2=""):
        show_message(line1, type, line2)

    def __init__(self):

        self.scale = prefs.ui_scale

        self.window_id = 0
        self.update = 2  # UPDATE
        self.turbo = True
        self.turbo_next = 0
        self.pl_update = 1
        self.lowered = False
        self.request_raise = False
        self.maximized = False

        self.message_box = False
        self.message_text = ""
        self.message_mode = 'info'
        self.message_subtext = ""


        self.save_size = [450, 310]
        self.show_playlist = True
        self.show_bottom_title = False
        self.show_top_title = True
        self.search_error = False

        self.level_update = False
        self.level_time = Timer()
        self.level_peak = [0, 0]
        self.level = 0
        self.time_passed = 0
        self.level_meter_colour_mode = 3

        self.vis = 2  # visualiser mode actual
        self.vis_want = 2  # visualiser mode setting
        self.spec = None
        self.s_spec = [0] * 24
        self.s4_spec = [0] * 45
        self.update_spec = 0

        #self.spec_rect = [0, 5, 80, 20]  # x = 72 + 24 - 6 - 10

        self.spec_y = int(round(5 * self.scale))
        self.spec_w = int(round(80 * self.scale))
        self.spec_h = int(round(20 * self.scale))
        self.spec1_rec = SDL_Rect(0, self.spec_y, self.spec_w, self.spec_h)

        self.spec4_array = []
        self.spec4_y = int(round(200 * self.scale))
        self.spec4_w = int(round(322 * self.scale))
        self.spec4_h = int(round(100 * self.scale))
        self.draw_spec4 = False
        self.spec4_rec = SDL_Rect(0, self.spec4_y, self.spec4_w, self.spec4_h)

        self.bar = SDL_Rect(10, 10, round(3 * self.scale), 10) # spec bar bin
        self.bar4 = SDL_Rect(10, 10, round(3 * self.scale), 10) # spec bar bin

        self.combo_mode = False
        self.showcase_mode = False
        self.display_time_mode = 0

        self.pl_text_real_height = 12
        self.pl_title_real_height = 11

        self.row_extra = 0
        self.test = False
        self.light_mode = False
        self.draw_frame = False

        self.level_2_click = False
        self.universal_y_text_offset = 0

        self.star_text_y_offset = 0
        if system == "windows":
            self.star_text_y_offset = -2

        self.set_bar = False
        self.set_mode = False
        self.set_height = 25 * self.scale
        self.set_hold = -1
        self.set_label_hold = -1
        self.set_label_point = (0, 0)
        self.set_point = 0
        self.set_old = 0
        self.pl_st = [['Artist', 156, False], ['Title', 188, False], ['T', 40, True], ['Album', 153, False], ['P', 28, True], ['Starline', 86, True], ['Date', 48, True], ['Codec', 55, True], ['Time', 53, True]]

        self.panelBY = 51 * self.scale
        self.panelY = round(30 * self.scale)

        self.playlist_top = self.panelY + (8 * self.scale)
        self.playlist_top_bk = self.playlist_top
        self.offset_extra = 0
        self.scroll_hide_box = (0, self.panelY, 28, window_size[1] - self.panelBY - self.panelY)

        self.playlist_row_height = 16
        self.playlist_text_offset = 0
        self.row_font_size = 13
        self.compact_bar = False
        self.abc = None
        self.ttext = None

        self.trunk_end = "..." # "â¦"
        self.temp_themes = {}
        self.theme_temp_current = -1

        self.pl_title_y_offset = 0
        self.pl_title_font_offset = -1

        self.playlist_box_d_click = -1

        self.gallery_show_text = True
        self.bb_show_art = False
        # self.show_stars = True

        self.spec2_y = int(round(22 * self.scale))
        self.spec2_w = int(round(140 * self.scale))
        self.spec2 = [0] * self.spec2_y
        self.spec2_phase = 0
        self.spec2_buffers = []
        self.spec2_tex = None
        self.spec2_rec = SDL_Rect(1230, round(4 * self.scale), self.spec2_w, self.spec2_y)
        self.spec2_source = SDL_Rect(900, round(4 * self.scale), self.spec2_w, self.spec2_y)
        self.spec2_dest = SDL_Rect(900, round(4 * self.scale), self.spec2_w, self.spec2_y)
        self.spec2_position = 0
        self.spec2_timer = Timer()
        self.spec2_timer.set()

        self.level_w = 5 * self.scale
        self.level_y = 16 * self.scale
        self.level_s = 1 * self.scale
        self.level_ww = round(79 * self.scale)
        self.level_hh = round(18 * self.scale)
        self.spec_level_rec = SDL_Rect(0, round(self.level_y - 10 * self.scale), round(self.level_ww), round(self.level_hh))

        self.rename_folder_box = False

        self.present = False
        self.drag_source_position = (0, 0)
        self.album_tab_mode = False
        self.main_art_box = (0, 0, 10, 10)
        self.gall_tab_enter = False

        self.lightning_copy = False

        self.gallery_animate_highlight_on = 0

        self.seek_cur_show = False
        self.cur_time = "0"
        self.force_showcase_index = -1

        self.frame_callback_list = []

        self.playlist_left = None
        self.image_downloading = False
        self.tc_cancel = False
        self.im_cancel = False
        self.force_search = False

        self.pl_pulse = False

        self.view_name = "S"
        self.restart_album_mode = False

        self.dtm3_index = -1
        self.dtm3_cum = 0
        self.dtm3_total = 0
        self.previous_playlist_id = ""

        self.star_mode = "line"
        self.heart_fields = []

        self.web_running = False

        self.rsp = True
        self.rspw = 300
        self.lsp = False
        self.lspw = 220 * self.scale
        self.plw = None

        self.pref_rspw = 300

        self.pref_gallery_w = 600
        self.artist_panel_height = 320 * self.scale

        self.artist_info_panel = False

        self.show_hearts = True

        self.cursor_is = 0
        self.cursor_want = 0
        # 0 standard
        # 1 drag horizontal
        # 2 text
        # 3 hand

        self.power_bar = None
        self.gallery_scroll_field_left = 1
        self.lyrics_was_album = False

        self.gallery_positions = {}

        self.remember_library_mode = False

        self.first_in_grid = None

        self.art_aspect_ratio = 1
        self.art_unlock_ratio = False
        self.art_max_ratio_lock = 1
        self.side_bar_drag_source = 0
        self.side_bar_drag_original = 0

        self.scroll_direction = 0
        self.add_music_folder_ready = False

        self.playlist_current_visible_tracks = 0
        self.playlist_current_visible_last_id = 0

        self.theme_name = ""
        self.rename_playlist_box = False
        self.queue_frame_draw = None  # Set when need draw frame later

        self.mode = 1

        self.save_position = [0, 0]

        self.window_control_hit_area_w = 100 * self.scale
        self.window_control_hit_area_h = 30 * self.scale

        self.draw_vis4_top = False
        #self.vis_4_colour = [0,0,0,255]
        self.vis_4_colour = None

        self.layer_focus = 0
        self.tab_menu_pl = 0

        self.tool_tip_lock_off_f = False
        self.tool_tip_lock_off_b = False

        self.auto_play_import = False

        self.transcoding_batch_total = 0
        self.transcoding_bach_done = 0

        self.seek_bar_rect = (0,0,0,0)
        self.volume_bar_rect = (0,0,0,0)

        self.mini_mode_return_maximized = False

        self.opened_config_file = False

        self.notify_main_id = None


gui = GuiVar()


# Functions for reading and setting play counts
class StarStore:

    def __init__(self):

        self.db = {}

    def key(self, index):
        return pctl.master_library[index].artist, pctl.master_library[index].title, pctl.master_library[index].filename

    def object_key(self, track):

        return track.artist, track.title, track.filename

    # Increments the play time
    def add(self, index, value):

        key = self.key(index)
        if key in self.db:
            self.db[key][0] += value
            if value < 0 and self.db[key][0] < 0:
                self.db[key][0] = 0
        else:
            self.db[key] = [value, ""]

    # Returns the track play time
    def get(self, index):

        key = self.key(index)
        if key in self.db:
            return self.db[key][0]
        else:
            return 0

    def get_by_object(self, track):

        key = self.object_key(track)
        if key in self.db:
            return self.db[key][0]
        else:
            return 0

    def get_total(self):

        return sum(item[0] for item in self.db.values())

    def full_get(self, index):

        key = self.key(index)
        if key in self.db:
            return self.db[key]
        else:
            return None

    def remove(self, index):

        key = self.key(index)
        if key in self.db:
            del self.db[key]

    def insert(self, index, object):

        key = self.key(index)
        self.db[key] = object


star_store = StarStore()


class Fonts:    # Used to hold font sizes (I forget to use this)

    def __init__(self):

        self.tabs = 211
        self.panel_title = 213

        self.side_panel_line1 = 214
        self.side_panel_line2 = 13

        self.bottom_panel_time = 212

        # if system == 'windows':
        #     self.bottom_panel_time = 12  # The Arial bold font is too big so just leaving this as normal. (lazy)

fonts = Fonts()


class Input:    # Used to keep track of button states (or should be)

    def __init__(self):

        self.mouse_click = False
        # self.right_click = False
        self.level_2_enter = False
        self.key_return_press = False



input = Input()


class KeyMap:

    def __init__(self):

        self.hits = [] # The keys hit this frame
        self.maps = {} # Loaded from input.txt

    def load(self):

        path = os.path.join(config_directory, "input.txt")
        with open(path, encoding="utf_8") as f:
            content = f.read().splitlines()
            for p in content:
                if len(p) == 0 or len(p) > 100:
                    continue
                if p[0] == " " or p[0] == "#":
                    continue

                items = p.split()
                if 1 < len(items) < 4:
                    function = items[0]
                    key = SDL_GetKeyFromName(items[1].encode())
                    if key == 0:
                        continue
                    mod = ""
                    if len(items) > 2:
                        mod = items[2].lower()

                    if function in self.maps:
                        self.maps[function].append((key, mod))
                    else:
                        self.maps[function] = [(key, mod)]

    def test(self, function):

        if not self.hits:
            return False
        if function not in self.maps:
            return False

        for code, mod in self.maps[function]:

            if (mod == "" and not (key_ctrl_down or key_rctrl_down or key_shift_down or key_shiftr_down or key_lalt or key_ralt)) \
                    or (mod == "ctrl" and (key_ctrl_down or key_rctrl_down)) or \
                    (mod == "shift" and (key_shift_down or key_shiftr_down)) or \
                    (mod == "alt" and (key_lalt or key_ralt)):

                if code in self.hits:
                    return True

        return False


keymaps = KeyMap()

shoot = threading.Thread(target=keymaps.load)
shoot.daemon = True
shoot.start()

def update_set():   # This is used to scale columns when windows is resized or items added/removed

    wid = gui.plw - 16
    total = 0
    for item in gui.pl_st:
        if item[2] is False:
            total += item[1]
        else:
            wid -= item[1]

    if wid <= 75:
        wid = 75

    for i in range(len(gui.pl_st)):
        if gui.pl_st[i][2] is False:
            gui.pl_st[i][1] = int(round((gui.pl_st[i][1] / total) * wid)) #+ 1


class ColoursClass:     # Used to store colour values for UI elements. These are changed for themes.
    def grey(self, value):
        return [value, value, value, 255]

    def alpha_grey(self, value):
        return [255, 255, 255, value]

    def grey_blend_bg(self, value):
        return alpha_blend((255, 255, 255, value), self.sys_background)

    def grey_blend_bg3(self, value):
        return alpha_blend((255, 255, 255, value), self.sys_background_3)

    def __init__(self):

        self.column_colours = {}
        self.column_colours_playing = {}

        self.last_album = ""
        self.link_text = [100, 200, 252, 255]

        self.sep_line = self.grey(21)
        self.bb_line = self.grey(21)
        self.tb_line = self.grey(21)
        self.art_box = self.grey(24)

        self.volume_bar_background = self.grey(30)
        #self.volume_bar_outline = self.grey(100)
        self.volume_bar_fill = self.grey(125)
        self.seek_bar_background = self.grey(30)
        #self.seek_bar_outline = self.grey(100)
        self.seek_bar_fill = self.grey(80)

        self.tab_text_active = self.grey(230)
        self.tab_text = self.grey(215)
        self.tab_background = self.grey(25)
        self.tab_highlight = self.grey(40)
        self.tab_background_active = self.grey(45)

        self.title_text = [190, 190, 190, 255]
        self.index_text = self.grey(70)
        self.time_text = self.grey(180)
        self.artist_text = [195, 255, 104, 255]
        self.album_text = [245, 240, 90, 255]

        self.index_playing = self.grey(190)
        self.artist_playing = [195, 255, 104, 255]
        self.album_playing = [245, 240, 90, 255]
        self.title_playing = self.grey(230)

        self.time_playing = [180, 194, 107, 255]

        self.playlist_text_missing = self.grey(85)
        self.bar_time = self.grey(70)

        self.top_panel_background = self.grey(15)
        self.side_panel_background = self.grey(18)
        self.gallery_background = self.side_panel_background
        self.playlist_panel_background = self.grey(21)
        self.bottom_panel_colour = self.grey(15)

        self.row_playing_highlight = [255,255,255,4]
        self.row_select_highlight = [255,255,255,5]

        self.side_bar_line1 = self.grey(210)
        self.side_bar_line2 = self.grey(200)

        self.mode_button_off = self.grey(50)
        self.mode_button_over = self.grey(200)
        self.mode_button_active = self.grey(190)

        self.media_buttons_over = self.grey(220)
        self.media_buttons_active = self.grey(220)
        self.media_buttons_off = self.grey(55)

        self.star_line = [100, 100, 100, 255]
        self.star_line_playing = None
        self.folder_title = [130, 130, 130, 255]
        self.folder_line = [40, 40, 40, 255]

        self.scroll_colour = [45, 45, 45, 255]

        self.level_1_bg = [0, 30, 0, 255]
        self.level_2_bg = [30, 30, 0, 255]
        self.level_3_bg = [30, 0, 0, 255]
        self.level_green = [20, 120, 20, 255]
        self.level_red = [190, 30, 30, 255]
        self.level_yellow = [135, 135, 30, 255]

        self.vis_colour = self.grey(200)
        self.vis_bg = [0, 0, 0, 255]

        self.menu_background = self.grey(12)
        self.menu_highlight_background = None
        self.menu_text = [230, 230, 230, 255]
        self.menu_text_disabled = self.grey(50)

        self.gallery_highlight = self.artist_playing

        self.status_info_text = [245, 205, 0, 255]
        self.streaming_text = [220, 75, 60, 255]
        self.lyrics = self.grey(235)

        self.corner_button = [60, 60, 60, 255]
        self.corner_button_active = [230, 230, 230, 255]
        self.window_buttons_bg = [0, 0, 0, 50]
        self.window_buttons_bg_over = [80, 80, 80, 120]

        self.message_box_bg = self.grey(0)
        self.message_box_text = self.grey(230)

        self.sys_title = self.grey(220)
        self.sys_title_strong = self.grey(230)
        self.lm = False

        self.pluse_colour = [244, 212, 66, 255]

        self.mini_mode_background = [24, 24, 24, 255]
        self.mini_mode_border = [60, 60, 60, 255]

        #self.post_config()

    def post_config(self):
        # Pre calculate alpha blend for spec background
        self.vis_bg[0] = int(0.05 * 255 + (1 - 0.05) * self.top_panel_background[0])
        self.vis_bg[1] = int(0.05 * 255 + (1 - 0.05) * self.top_panel_background[1])
        self.vis_bg[2] = int(0.05 * 255 + (1 - 0.05) * self.top_panel_background[2])

        self.sys_background = self.menu_background
        self.sys_background_2 = self.tab_background
        self.sys_background_3 = self.top_panel_background
        self.sys_background_4 = self.bottom_panel_colour
        self.message_box_bg = self.sys_background_3
        self.sys_tab_bg = self.tab_background
        self.sys_tab_hl = self.tab_background_active
        self.toggle_box_on = self.folder_title
        if colour_value(self.toggle_box_on) < 150:
            self.toggle_box_on = [160, 160, 160, 255]
        self.time_sub = alpha_blend([255, 255, 255, 80], self.bottom_panel_colour)
        self.bar_title_text = self.side_bar_line1

        self.gallery_artist_line = alpha_mod(self.side_bar_line2, 120)


        self.status_text_normal = self.grey(100)
        self.status_text_over = self.grey(220)

        if self.menu_highlight_background is None:
            self.menu_highlight_background = [40, 40, 40, 255]


    def light_mode(self):

        self.lm = True
        self.star_line_playing = [255, 255, 255, 255]
        self.sys_background = self.grey(20)
        self.sys_background_2 = self.grey(25)
        self.sys_tab_bg = self.grey(25)
        self.sys_tab_hl = self.grey(45)
        self.sys_background_3 = self.grey(35)
        self.sys_background_4 = self.grey(19)
        self.toggle_box_on = self.tab_background_active
        # self.time_sub = [0, 0, 0, 200]
        self.gallery_artist_line = self.grey(40)
        # self.bar_title_text = self.grey(30)
        self.status_text_normal = self.grey(70)
        self.status_text_over = self.grey(40)
        self.status_info_text = [40, 40, 40, 255]

        self.bar_title_text = self.grey(255)
        self.vis_bg = [235, 235, 235, 255]
        self.menu_background = [240, 240, 240, 245]
        self.menu_text = self.grey(40)
        self.menu_text_disabled = self.grey(180)
        self.menu_highlight_background = [200, 200, 200, 245]
        self.corner_button = self.grey(50)
        self.corner_button_active = self.grey(50)
        self.window_buttons_bg = [0, 0, 0, 5]
        self.message_box_bg = [245, 245, 245, 255]
        self.message_box_text = self.grey(20)
        self.gallery_background = self.grey(230)
        self.gallery_artist_line = self.grey(40)
        self.pluse_colour = [212, 66, 244, 255]

        #view_box.off_colour = self.grey(200)


colours = ColoursClass()
colours.post_config()


def set_colour(colour):
    SDL_SetRenderDrawColor(renderer, colour[0], colour[1], colour[2], colour[3])


def get_themes():

    themes = []  # full, name
    direcs = [install_directory + '/theme']
    if user_directory != install_directory:
        direcs.append(user_directory + '/theme')

    for direc in direcs:
        if os.path.exists(direc):
            for path in [os.path.join(direc, f) for f in os.listdir(direc)]:
                if path[-6:] == 'ttheme':
                    themes.append((path, os.path.basename(path).split(".")[0]))

    themes.sort()
    return themes


# This is legacy. New settings are added straight to the save list (need to overhaul)
view_prefs = {

    'split-line': True,
    'update-title': False,
    'star-lines': False,
    'side-panel': True,
    'dim-art': False,
    'pl-follow': False,
    'scroll-enable': True
}


class TrackClass:   # This is the fundamental object/data structure of a track
    # C-TC
    def __init__(self):
        self.index = 0
        self.fullpath = ""
        self.filename = ""
        self.parent_folder_path = ""
        self.parent_folder_name = ""
        self.file_ext = ""
        self.size = 0
        self.modified_time = 0

        self.is_network = False
        #self.url = ""
        self.url_key = ""
        self.art_url_key = ""

        self.artist = ""
        self.album_artist = ""
        self.title = ""
        self.composer = ""
        self.length = 0
        self.bitrate = 0
        self.samplerate = 0
        self.bit_depth = 0
        self.album = ""
        self.date = ""
        self.track_number = ""
        self.track_total = ""
        self.start_time = 0
        self.is_cue = False
        self.is_embed_cue = False
        self.cue_sheet = ""
        self.genre = ""
        self.found = True
        self.skips = 0
        self.comment = ""
        self.disc_number = ""
        self.disc_total = ""
        self.lyrics = ""
        self.album_gain = None
        self.track_gain = None

        self.lfm_friend_likes = set()
        self.misc = {}


class LoadClass:    # Object for import track jobs (passed to worker thread)
    def __init__(self):
        self.target = ""
        self.playlist = 0  # Playlist UID
        self.tracks = []
        self.stage = 0
        self.playlist_position = None
        self.replace_stem = False
        self.notify = False
        self.play = False


url_saves = []
rename_files_previous = ""
rename_folder_previous = ""
p_force_queue = []

reload_state = None


def show_message(text, message_mode='info', subtext=""):
    gui.message_box = True
    gui.message_text = text
    gui.message_mode = message_mode
    gui.message_subtext = subtext
    message_box_min_timer.set()
    gui.update = 1

# -----------------------------------------------------
# STATE LOADING
# Loading of program data from previous run

try:
    star_store.db = pickle.load(open(user_directory + "/star.p", "rb"))

except:
    print('No existing star.p file')

try:
    state_file = open(user_directory + "/state.p", "rb")
    save = pickle.load(state_file)

    if save[63] is not None:
        prefs.ui_scale = save[63]
        #prefs.ui_scale = 1.3

        gui.__init__()

    master_library = save[0]
    master_count = save[1]
    playlist_playing = save[2]
    playlist_active = save[3]
    playlist_view_position = save[4]
    multi_playlist = save[5]
    volume = save[6]
    QUE = save[7]
    playing_in_queue = save[8]
    default_playlist = save[9]
    playlist_playing = save[10]
    # cue_list = save[11]
    radio_field_text = save[12]
    theme = save[13]
    folder_image_offsets = save[14]
    #lfm_username = save[15]
    #lfm_hash = save[16]
    if save[16] is not None and save[16]:  # it should be None from now on
        show_message("Upgrade note: Last.fm loggout.", 'info', "This new version changes how last.fm login works. You will need to log back in.")
    db_version = save[17]
    view_prefs = save[18]
    window_size = save[19]
    gui.save_size = copy.copy(save[19])
    gui.rspw = save[20]
    # savetime = save[21]
    gui.vis_want = save[22]
    playlist_selected = save[23]
    if save[24] is not None:
        album_mode_art_size = save[24]
    if save[25] is not None:
        draw_border = save[25]
    if save[26] is not None:
        prefs.enable_web = save[26]
    if save[27] is not None:
        prefs.allow_remote = save[27]
    if save[28] is not None:
        prefs.expose_web = save[28]
    # if save[29] is not None:
    #     prefs.enable_transcode = save[29]
    if save[30] is not None:
        prefs.show_rym = save[30]
    # if save[31] is not None:
    #     combo_mode_art_size = save[31]
    if save[32] is not None:
        gui.maximized = save[32]
    if save[33] is not None:
        prefs.prefer_bottom_title = save[33]
    if save[34] is not None:
        gui.display_time_mode = save[34]
    # if save[35] is not None:
    #     prefs.transcode_mode = save[35]
    if save[36] is not None:
        prefs.transcode_codec = save[36]
    if save[37] is not None:
        prefs.transcode_bitrate = save[37]
    # if save[38] is not None:
    #     prefs.line_style = save[38]
    # if save[39] is not None:
    #     prefs.cache_gallery = save[39]
    if save[40] is not None:
        prefs.playlist_font_size = save[40]
    if save[41] is not None:
        prefs.use_title = save[41]
    if save[42] is not None:
        gui.pl_st = save[42]
    # if save[43] is not None:
    #     gui.set_mode = save[43]
    #     gui.set_bar = gui.set_mode
    if save[45] is not None:
        prefs.playlist_row_height = save[45]
    if save[46] is not None:
        prefs.show_wiki = save[46]
    if save[47] is not None:
        prefs.auto_extract = save[47]
    if save[48] is not None:
        prefs.colour_from_image = save[48]
    if save[49] is not None:
        gui.set_bar = save[49]
    if save[50] is not None:
        gui.gallery_show_text = save[50]
    if save[51] is not None:
        gui.bb_show_art = save[51]
    # if save[52] is not None:
    #     gui.show_stars = save[52]
    if save[53] is not None:
        prefs.auto_lfm = save[53]
    if save[54] is not None:
        prefs.scrobble_mark = save[54]
    if save[55] is not None:
        prefs.replay_gain = save[55]
    # if save[56] is not None:
    #     prefs.radio_page_lyrics = save[56]
    if save[57] is not None:
        prefs.show_gimage = save[57]
    if save[58] is not None:
        prefs.end_setting = save[58]
    if save[59] is not None:
        prefs.show_gen = save[59]
    if save[60] is not None:
        url_saves = save[60]
    if save[61] is not None:
        prefs.auto_del_zip = save[61]
    if save[62] is not None:
        gui.level_meter_colour_mode = save[62]
    if save[64] is not None:
        prefs.show_lyrics_side = save[64]
    if save[65] is not None:
        prefs.last_device = save[65]
    if save[66] is not None:
        gui.restart_album_mode = save[66]
    if save[67] is not None:
        album_playlist_width = save[67]
    if save[68] is not None:
        prefs.transcode_opus_as = save[68]
    if save[69] is not None:
        gui.star_mode = save[69]
    if save[70] is not None:
        gui.rsp = save[70]
    if save[71] is not None:
        gui.lsp = save[71]
    if save[72] is not None:
        gui.rspw = save[72]
    if save[73] is not None:
        gui.pref_gallery_w = save[73]
    if save[74] is not None:
        gui.pref_rspw = save[74]
    if save[75] is not None:
        gui.show_hearts = save[75]
    if save[76] is not None:
        prefs.monitor_downloads = save[76]
    if save[77] is not None:
        gui.artist_info_panel = save[77]
    if save[78] is not None:
        prefs.extract_to_music = save[78]
    if save[79] is not None:
        prefs.enable_lb = save[79]
    if save[80] is not None:
        prefs.lb_token = save[80]
        if prefs.lb_token is None:
            prefs.lb_token = ""
    if save[81] is not None:
        rename_files_previous = save[81]
    if save[82] is not None:
        rename_folder_previous = save[82]
    if save[83] is not None:
        prefs.use_jump_crossfade = save[83]
    if save[84] is not None:
        prefs.use_transition_crossfade = save[84]
    if save[85] is not None:
        prefs.show_notifications = save[85]
    # if save[86] is not None:
    #     prefs.true_shuffle = save[86]
    if save[87] is not None:
        gui.remember_library_mode = save[87]
    # if save[88] is not None:
    #     prefs.show_queue = save[88]
    # if save[89] is not None:
    #     prefs.show_transfer = save[89]
    if save[90] is not None:
        p_force_queue = save[90]
    if save[91] is not None:
        prefs.use_pause_fade = save[91]
    if save[92] is not None:
        prefs.append_total_time = save[92]
    if save[93] is not None:
        prefs.backend = save[93]
    if save[94] is not None:
        prefs.album_shuffle_mode = save[94]
    if save[95] is not None:
        prefs.album_repeat_mode = save[95]
    # if save[96] is not None:
    #     prefs.finish_current = save[96]
    if save[97] is not None:
        reload_state = save[97]
    # if save[98] is not None:
    #     prefs.reload_play_state = save[98]
    if save[99] is not None:
        prefs.last_fm_token = save[99]
    if save[100] is not None:
        prefs.last_fm_username = save[100]
    # if save[101] is not None:
    #     prefs.use_card_style = save[101]
    if save[102] is not None:
        prefs.auto_lyrics = save[102]
    if save[103] is not None:
        prefs.auto_lyrics_checked = save[103]
    if save[104] is not None:
        prefs.show_side_art = save[104]
    if save[105] is not None:
        prefs.window_opacity = save[105]
    if save[106] is not None:
        prefs.gallery_single_click = save[106]
    if save[107] is not None:
        prefs.tabs_on_top = save[107]
    if save[108] is not None:
        prefs.showcase_vis = save[108]
    if save[109] is not None:
        prefs.spec2_colour_mode = save[109]
    if save[110] is not None:
        prefs.device_buffer = save[110]
    if save[111] is not None:
        prefs.use_eq = save[111]
    if save[112] is not None:
        prefs.eq = save[112]
    if save[113] is not None:
        prefs.bio_large = save[113]
    if save[114] is not None:
        prefs.discord_show = save[114]
    if save[115] is not None:
        prefs.min_to_tray = save[115]
    if save[116] is not None:
        prefs.guitar_chords = save[116]
    if save[117] is not None:
        prefs.playback_follow_cursor = save[117]
    if save[118] is not None:
        prefs.art_bg = save[118]
    if save[119] is not None:
        prefs.random_mode = save[119]
    if save[120] is not None:
        prefs.repeat_mode = save[120]
    if save[121] is not None:
        prefs.art_bg_stronger = save[121]
    if save[122] is not None:
        prefs.art_bg_always_blur = save[122]
    if save[123] is not None:
        prefs.failed_artists = save[123]
    if save[124] is not None:
        prefs.artist_list = save[124]
    if save[125] is not None:
        prefs.auto_sort = save[125]
    if save[126] is not None:
        prefs.lyrics_enables = save[126]
    if save[127] is not None:
        prefs.fanart_notify = save[127]
    if save[128] is not None:
        prefs.bg_showcase_only = save[128]
    if save[129] is not None:
        prefs.discogs_pat = save[129]
    if save[130] is not None:
        prefs.mini_mode_mode = save[130]
    # if save[131] is not None:
    #     prefs.artist_list_prefer_album_artist = save[131]

    state_file.close()
    del save

except:

    print('Error loading save file')
    # if os.path.exists(cache_directory):
    #     print("clearing old cache")
    #     # shutil.rmtree(cache_directory)
    #     time.sleep(0.01)
    #     #os.makedirs(cache_directory)

# # Check is bass is present
# if prefs.backend == 1:
#     if not os.path.isfile(install_directory + '/lib/libbass.so'):
#         prefs.backend = 2

if prefs.backend == 2:
    # gi.require_version('Gst', '1.0')
    # from gi.repository import GObject, Gst
    print("Using GStreamer for playback")
    DA_Formats.add('wma')

# temporary
if window_size is None:
    window_size = window_default_size
    gui.rspw = 200

def track_number_process(line):
    line = str(line).split("/", 1)[0].lstrip("0")
    if prefs.dd_index and len(line) == 1:
        return "0" + line
    return line


# Upgrading from older versions
if db_version > 0:

    if db_version <= 0.8:
        print("Updating database from version 0.8 to 0.9")
        for key, value in master_library.items():
            setattr(master_library[key], 'skips', 0)

    if db_version <= 0.9:
        print("Updating database from version 0.9 to 1.1")
        for key, value in master_library.items():
            setattr(master_library[key], 'comment', "")

    if db_version <= 1.1:
        print("Updating database from version 1.1 to 1.2")
        for key, value in master_library.items():
            setattr(master_library[key], 'album_artist', "")

    if db_version <= 1.2:
        print("Updating database to version 1.3")
        for key, value in master_library.items():
            setattr(master_library[key], 'disc_number', "")
            setattr(master_library[key], 'disc_total', "")

    if db_version <= 1.3:
        print("Updating database to version 1.4")
        for key, value in master_library.items():
            setattr(master_library[key], 'lyrics', "")
            setattr(master_library[key], 'track_total', "")
        show_message(
            "Upgrade complete. Note: New attributes such as disk number won't show for existing tracks (delete state.p to reset)")

    if db_version <= 1.4:
        print("Updating database to version 1.5")
        for playlist in multi_playlist:
            playlist.append(uid_gen())

    if db_version <= 1.5:
        print("Updating database to version 1.6")
        for i in range(len(multi_playlist)):
            if len(multi_playlist[i]) == 7:
                multi_playlist[i].append("")

    if db_version <= 1.6:
        print("Updating preferences to 1.7")
        gui.show_stars = False
        if install_mode:
                #shutil.copy(install_directory + "/config.txt", user_directory)
                print("Rewrote user config file")

    if db_version <= 1.7:
        print("Updating database to version 1.8")
        if install_mode:
                print(".... Overwriting user config file")
                #shutil.copy(install_directory + "/config.txt", user_directory)

        try:
            print(".... Updating playtime database")

            old = star_store.db
            #perf_timer.set()
            old_total = sum(old.values())
            #print(perf_timer.get())
            print("Old total: ", end='')
            print(old_total)
            star_store.db = {}

            new = {}
            for track in master_library.values():
                key = track.title + track.filename
                if key in old:
                    n_value = [old[key], ""]
                    n_key = star_store.object_key(track)
                    star_store.db[n_key] = n_value

            print("New total: ", end='')
            diff = old_total - star_store.get_total()
            print(int(diff), end='')
            print(" Secconds could not be matched to tracks. Total playtime won't be affected")
            star_store.db[("", "", "LOST")] = [diff, ""]
            print("Upgrade Complete")
        except:
            print("Error upgrading database")
            show_message("Error loading old database, did the program not exit properly after updating? Oh well.")

    if db_version <= 1.8:
        print("Updating database to 1.9")
        for key, value in master_library.items():
            setattr(master_library[key], 'track_gain', None)
            setattr(master_library[key], 'album_gain', None)
        show_message(
            "Upgrade complete. Run a tag rescan if you want enable ReplayGain")

    if db_version <= 1.9:
        print("Updating database to version 2.0")
        for key, value in master_library.items():
            setattr(master_library[key], 'modified_time', 0)
        show_message(
            "Upgrade complete. New sorting option may require tag rescan.")


    if db_version <= 2.0:
        print("Updating database to version 2.1")
        for key, value in master_library.items():
            setattr(master_library[key], 'is_embed_cue', False)
            setattr(master_library[key], 'cue_sheet', "")
        show_message(
            "Updated to v2.6.3")

    if db_version <= 2.1:
        print("Updating database to version 2.1")
        for key, value in master_library.items():
            setattr(master_library[key], 'lfm_friend_likes', set())

    if db_version <= 2.2:
        for i in range(len(multi_playlist)):
            if len(multi_playlist[i]) < 9:
                multi_playlist[i].append(True)

    if db_version <= 2.3:
        print("Updating database to version 2.4")
        for key, value in master_library.items():
            setattr(master_library[key], 'bit_depth', 0)

    if db_version <= 2.4:
        if theme > 0:
           theme += 1

    if db_version <= 2.5:
        print("Updating database to version 2.6")
        for key, value in master_library.items():
            setattr(master_library[key], 'is_network', False)
        # for i in range(len(multi_playlist)):
        #     if len(multi_playlist[i]) < 10:
        #         multi_playlist[i].append(False)

    if db_version <= 26:
        print("Updating database to version 27")
        for i in range(len(multi_playlist)):
            if len(multi_playlist[i]) == 9:
                multi_playlist[i].append(False)

    if db_version <= 27:
        print("Updating database to version 28")
        for i in range(len(multi_playlist)):
            if len(multi_playlist[i]) <= 10:
                multi_playlist[i].append("")

    if db_version <= 29:
        print("Updating database to version 30")
        for key, value in master_library.items():
            setattr(master_library[key], 'composer', "")

        if install_directory != config_directory and os.path.isfile(os.path.join(config_directory, "input.txt")):

            with open(os.path.join(config_directory, "input.txt"), 'a') as f:
                f.write("global-search G Ctrl\n")

        show_message(
            "Welcome to v4.4.0. Run a tag rescan if you want enable Composer metadata.")

# Loading Config -----------------

download_directories = []

if os.path.isdir(os.path.expanduser("~/Downloads")):
    download_directories.append(os.path.expanduser("~/Downloads"))
if os.path.isdir(os.path.expanduser("~/Music")):
    download_directories.append(os.path.expanduser("~/Music"))

from t_modules.t_config import Config

cf = Config()

def save_prefs():

    cf.update_value("plex-username", prefs.plex_username)
    cf.update_value("plex-password", prefs.plex_password)
    cf.update_value("plex-servername", prefs.plex_servername)

    cf.update_value("use-log-volume-scale", prefs.log_vol)
    cf.update_value("pause-fade-time", prefs.pause_fade_time)
    cf.update_value("cross-fade-time", prefs.cross_fade_time)
    cf.update_value("force-mono", prefs.mono)
    cf.update_value("disconnect-device-pause", prefs.dc_device_setting)
    cf.update_value("use-short-buffering", prefs.short_buffer)

    cf.update_value("tag-editor-name", prefs.tag_editor_name)
    cf.update_value("tag-editor-target", prefs.tag_editor_target)

    cf.update_value("ui-scale", prefs.scale_want)
    cf.update_value("scroll-gallery-by-row", prefs.gallery_row_scroll)
    cf.update_value("prefs.gallery_scroll_wheel_px", prefs.gallery_row_scroll)
    cf.update_value("scroll-spectrogram", prefs.spec2_scroll)
    cf.update_value("mascot-opacity", prefs.custom_bg_opacity)
    cf.update_value("synced-lyrics-time-offset", prefs.sync_lyrics_time_offset)
    cf.update_value("artist-list-prefers-album-artist", prefs.artist_list_prefer_album_artist)
    cf.update_value("side-panel-info-persists", prefs.meta_persists_stop)
    cf.update_value("side-panel-info-selected", prefs.meta_shows_selected)
    cf.update_value("side-panel-info-selected-always", prefs.meta_shows_selected_always)
    cf.update_value("mini-mode-avoid-notifications", prefs.stop_notifications_mini_mode)
    cf.update_value("mini-mode-micro-show-seek", prefs.mini_mode_micro_always_show_seek)

    cf.update_value("font-main-standard", prefs.linux_font)
    cf.update_value("font-main-medium", prefs.linux_font_semibold)
    cf.update_value("font-main-bold", prefs.linux_font_bold)

    cf.update_value("double-digit-indicies", prefs.dd_index)
    cf.update_value("column-album-artist-fallsback", prefs.column_aa_fallback_artist)
    cf.update_value("left-aligned-album-artist-title", prefs.left_align_album_artist_title)

    cf.update_value("encode-output-dir", prefs.custom_encoder_output)
    cf.update_value("add_download_directory", prefs.download_dir1)

    cf.update_value("enable-mpris", prefs.enable_mpris)
    cf.update_value("enable-gnome-mediakeys", prefs.mkey)
    cf.update_value("resume-playback-on-restart", prefs.reload_play_state)

    cf.update_value("discogs-personal-access-token", prefs.discogs_pat)
    cf.update_value("listenbrainz-token", prefs.lb_token)

    cf.update_value("broadcast-port", prefs.broadcast_port)
    cf.update_value("broadcast-bitrate", prefs.broadcast_bitrate)

    if os.path.isdir(config_directory):
        cf.dump(os.path.join(config_directory, "tauon.conf"))
    else:
        print("ERROR: Missing config directory")

def load_prefs():

    cf.reset()
    cf.load(os.path.join(config_directory, "tauon.conf"))

    cf.add_comment("Tauon Music Box configuration file")
    cf.br()
    cf.add_comment("This file will be regenerated while app is running. Formatting and additional comments will be lost.")
    cf.add_comment("Tip: Use TOML syntax highlighting")

    cf.br()
    cf.add_text("[audio]")

    prefs.pause_fade_time = cf.sync_add("int", "pause-fade-time", prefs.pause_fade_time, "In milliseconds. BASS only.")
    prefs.cross_fade_time = cf.sync_add("int", "cross-fade-time", prefs.cross_fade_time, "In milliseconds. BASS only.")
    prefs.log_vol = cf.sync_add("bool", "use-log-volume-scale", prefs.log_vol, "BASS only.")
    prefs.mono = cf.sync_add("bool", "force-mono", prefs.mono, "BASS only.")
    prefs.dc_device_setting = cf.sync_add("string", "disconnect-device-pause", prefs.dc_device_setting, "Can be \"auto\", \"on\" or \"off\". BASS only.")
    prefs.short_buffer = cf.sync_add("bool", "use-short-buffering", prefs.short_buffer, "BASS only.")

    if prefs.dc_device_setting == 'on':
        prefs.dc_device = True
    elif prefs.dc_device_setting == 'off':
        prefs.dc_device = False

    cf.br()
    cf.add_text("[tag-editor]")
    if system == 'windows':
        prefs.tag_editor_name = cf.sync_add("string", "tag-editor-name", "Picard", "Name to display in UI.")
        prefs.tag_editor_target = cf.sync_add("string", "tag-editor-target", "C:\Program Files (x86)\MusicBrainz Picard\picard.exe", "The path of the exe to run.")
    else:
        prefs.tag_editor_name = cf.sync_add("string", "tag-editor-name", "Picard", "Name to display in UI.")
        prefs.tag_editor_target = cf.sync_add("string", "tag-editor-target", "picard", "The name of the binary to call.")

    cf.br()
    cf.add_text("[ui]")
    prefs.scale_want = cf.sync_add("float", "ui-scale", prefs.scale_want, "Scaling for HiDPI displays. Accepted values: 1, 1.25 and 2. Change applies on restart.")

    prefs.gallery_row_scroll = cf.sync_add("bool", "scroll-gallery-by-row", True)
    prefs.gallery_scroll_wheel_px = cf.sync_add("int", "scroll-gallery-distance", 90, "Only has effect if scroll-gallery-by-row is false.")
    prefs.spec2_scroll = cf.sync_add("bool", "scroll-spectrogram", prefs.spec2_scroll)
    prefs.custom_bg_opacity = cf.sync_add("int", "mascot-opacity", prefs.custom_bg_opacity)
    if prefs.custom_bg_opacity < 0 or prefs.custom_bg_opacity > 100:
        prefs.custom_bg_opacity = 40
        print("Warning: Invalid value for mascot-opacity")
        
    prefs.sync_lyrics_time_offset = cf.sync_add("int", "synced-lyrics-time-offset", prefs.sync_lyrics_time_offset, "In milliseconds. May be negative.")
    prefs.artist_list_prefer_album_artist = cf.sync_add("bool", "artist-list-prefers-album-artist", prefs.artist_list_prefer_album_artist, "May require restart for change to take effect.")
    prefs.meta_persists_stop = cf.sync_add("bool", "side-panel-info-persists", prefs.meta_persists_stop, "Show album art and metadata of last played track when stopped.")
    prefs.meta_shows_selected = cf.sync_add("bool", "side-panel-info-selected", prefs.meta_shows_selected, "Show album art and metadata of selected track when stopped. (overides above setting)")
    prefs.meta_shows_selected_always = cf.sync_add("bool", "side-panel-info-selected-always", prefs.meta_shows_selected_always, "Show album art and metadata of selected track at all times. (overides the above 2 settings)")
    prefs.stop_notifications_mini_mode = cf.sync_add("bool", "mini-mode-avoid-notifications", prefs.stop_notifications_mini_mode, "Avoid sending track change notifications when in Mini Mode")
    prefs.mini_mode_micro_always_show_seek = cf.sync_add("bool", "mini-mode-micro-show-seek", prefs.mini_mode_micro_always_show_seek, "Always show the seek bar in Mini Mode Micro, otherwise shows on mouse over.")

    if system != 'windows':
        cf.br()
        cf.add_text("[fonts]")
        cf.add_comment("Changes will require app restart.")
        prefs.linux_font = cf.sync_add("string", "font-main-standard", prefs.linux_font, "Recomended: Noto Sans, Sugested alternate: Liberation Sans")
        prefs.linux_font_semibold = cf.sync_add("string", "font-main-medium", prefs.linux_font_semibold, "Recomended: Noto Sans Medium")
        prefs.linux_font_bold = cf.sync_add("string", "font-main-bold", prefs.linux_font_bold, "Recomended: Noto Sans Bold")

    cf.br()
    cf.add_text("[tracklist]")
    prefs.dd_index = cf.sync_add("bool", "double-digit-indicies", prefs.dd_index)
    prefs.column_aa_fallback_artist = cf.sync_add("bool", "column-album-artist-fallsback", prefs.column_aa_fallback_artist, "'Album artist' column shows 'artist' if otherwise blank.")
    prefs.left_align_album_artist_title = cf.sync_add("bool", "left-aligned-album-artist-title", prefs.left_align_album_artist_title, "Show 'Album artist' in the folder/album title. Uses colour 'column-album-artist' from theme file")


    cf.br()
    cf.add_text("[directories]")
    cf.add_comment("Use full paths")
    prefs.custom_encoder_output = cf.sync_add("string", "encode-output-dir", prefs.custom_encoder_output, "E.g. \"/home/example/music/output\". If left blank, encode-output in home music dir will be used.")
    if prefs.custom_encoder_output:
        prefs.encoder_output = prefs.custom_encoder_output
    prefs.download_dir1 = cf.sync_add("string", "add_download_directory", prefs.download_dir1, "Add another folder to monitor in addition to home downloads and music.")
    if prefs.download_dir1 and prefs.download_dir1 not in download_directories:
        if os.path.isdir(prefs.download_dir1):
            download_directories.append(prefs.download_dir1)
        else:
            print("Warning: Invalid download directory in config")

    cf.br()
    cf.add_text("[app]")
    prefs.enable_mpris = cf.sync_add("bool", "enable-mpris", prefs.enable_mpris)
    prefs.mkey = cf.sync_add("bool", "enable-gnome-mediakeys", prefs.mkey)
    prefs.reload_play_state = cf.sync_add("bool", "resume-playback-on-restart", prefs.reload_play_state)

    cf.br()
    cf.add_text("[tokens]")
    temp = cf.sync_add("string", "discogs-personal-access-token", prefs.discogs_pat, "Used for sourcing of artist thumbnails.")
    if not temp:
        prefs.discogs_pat = ""
    elif len(temp) != 40:
        print("Warning: Invalid discogs token in config")
    else:
        prefs.discogs_pat = temp

    temp = cf.sync_add("string", "listenbrainz-token", prefs.lb_token)
    if not temp:
        prefs.lb_token = ""
    elif len(temp) != 36 or temp[8] != "-":
        print("Warning: Invalid discogs token in config")
    else:
        prefs.lb_token = temp

    cf.br()
    cf.add_text("[plex_account]")
    prefs.plex_username = cf.sync_add("string", "plex-username", prefs.plex_username)
    prefs.plex_password = cf.sync_add("string", "plex-password", prefs.plex_password)
    prefs.plex_servername = cf.sync_add("string", "plex-servername", prefs.plex_servername)

    cf.br()
    cf.add_text("[broadcasting]")
    prefs.broadcast_port = cf.sync_add("int", "broadcast-port", prefs.broadcast_port, "Changing this breaks player on landing page")
    prefs.broadcast_bitrate = cf.sync_add("int", "broadcast-bitrate", prefs.broadcast_bitrate, "Codec is OGG. Higher values may reduce latency.")


load_prefs()
save_prefs()


print("TEST SCALE")
print(prefs.scale_want)
print(prefs.ui_scale)
if prefs.scale_want != prefs.ui_scale:
    print("UPDATE SCALE SETTING")
    if prefs.scale_want in (1, 1.25, 2):
        prefs.ui_scale = prefs.scale_want
        print("SCALE VALUE IS VALID")
        prefs.playlist_row_height = round(22 * prefs.ui_scale)
        prefs.playlist_font_size = 15
        gui.__init__()

try:
    # star_lines = view_prefs['star-lines']
    update_title = view_prefs['update-title']
    prefs.prefer_side = view_prefs['side-panel']
    prefs.dim_art = False #view_prefs['dim-art']
    gui.turbo = view_prefs['level-meter']
    # pl_follow = view_prefs['pl-follow']
    scroll_enable = view_prefs['scroll-enable']
    break_enable = view_prefs['break-enable']
    #dd_index = view_prefs['dd-index']
    # custom_line_mode = view_prefs['custom-line']
    #thick_lines = view_prefs['thick-lines']
    prefs.append_date = view_prefs['append-date']
except:
    print("warning: error loading settings")

if prefs.prefer_side is False:
    gui.rsp = False


def get_global_mouse():
    i_y = pointer(c_int(0))
    i_x = pointer(c_int(0))
    SDL_GetGlobalMouseState(i_x, i_y)
    return i_x.contents.value, i_y.contents.value


def get_window_position():
    i_y = pointer(c_int(0))
    i_x = pointer(c_int(0))
    SDL_GetWindowPosition(t_window, i_x, i_y)
    return i_x.contents.value, i_y.contents.value


# This function takes a track object and scans metadata for it. (Filepath needs to be set)
def tag_scan(nt):

    if nt.is_embed_cue:
        return nt

    try:
        nt.modified_time = os.path.getmtime(nt.fullpath)

        nt.file_ext = os.path.splitext(os.path.basename(nt.fullpath))[1][1:].upper()

        if nt.file_ext == "FLAC":

            # print("get opus")
            audio = Flac(nt.fullpath)
            audio.read()

            # print(audio.title)

            nt.length = audio.length
            nt.title = audio.title
            nt.artist = audio.artist
            nt.album = audio.album
            nt.composer = audio.composer
            nt.date = audio.date
            nt.samplerate = audio.sample_rate
            nt.bit_depth = audio.bit_depth
            nt.size = os.path.getsize(nt.fullpath)
            nt.track_number = audio.track_number
            nt.genre = audio.genre
            nt.album_artist = audio.album_artist
            nt.disc_number = audio.disc_number
            nt.lyrics = audio.lyrics
            nt.bitrate = int(nt.size / nt.length * 8 / 1024)
            nt.track_total = audio.track_total
            nt.disc_total = audio.disc_total
            nt.comment = audio.comment
            nt.track_gain = audio.track_gain
            nt.album_gain = audio.album_gain
            nt.cue_sheet = audio.cue_sheet
            nt.misc = audio.misc


            return nt

        elif nt.file_ext == "WAV":

            audio = Wav(nt.fullpath)
            audio.read()

            nt.samplerate = audio.sample_rate
            nt.length = audio.length

            return nt

        elif nt.file_ext == "OPUS" or nt.file_ext == "OGG":

            # print("get opus")
            audio = Opus(nt.fullpath)
            audio.read()

            # print(audio.title)

            nt.length = audio.length
            nt.title = audio.title
            nt.artist = audio.artist
            nt.album = audio.album
            nt.composer = audio.composer
            nt.date = audio.date
            nt.samplerate = audio.sample_rate
            nt.size = os.path.getsize(nt.fullpath)
            nt.track_number = audio.track_number
            nt.genre = audio.genre
            nt.album_artist = audio.album_artist
            nt.bitrate = audio.bit_rate
            nt.lyrics = audio.lyrics
            nt.disc_number = audio.disc_number
            nt.track_total = audio.track_total
            nt.disc_total = audio.disc_total
            nt.comment = audio.comment
            nt.track_gain = audio.track_gain
            nt.album_gain = audio.album_gain
            nt.misc = audio.misc
            if nt.bitrate == 0 and nt.length > 0:
                nt.bitrate = int(nt.size / nt.length * 8 / 1024)
            return nt

        elif nt.file_ext == "APE" or nt.file_ext == "WV" or nt.file_ext == "TTA":

            audio = Ape(nt.fullpath)
            audio.read()

            # print(audio.title)

            nt.length = audio.length
            nt.title = audio.title
            nt.artist = audio.artist
            nt.album = audio.album
            nt.date = audio.date
            nt.composer = audio.composer
            nt.samplerate = audio.sample_rate
            nt.bit_depth = audio.bit_depth
            nt.size = os.path.getsize(nt.fullpath)
            nt.track_number = audio.track_number
            nt.genre = audio.genre
            nt.album_artist = audio.album_artist
            nt.disc_number = audio.disc_number
            nt.lyrics = audio.lyrics
            nt.track_gain = audio.track_gain
            nt.album_gain = audio.album_gain
            if nt.length > 0:
                nt.bitrate = int(nt.size / nt.length * 8 / 1024)
            nt.track_total = audio.track_total
            nt.disc_total = audio.disc_total
            nt.comment = audio.comment
            nt.misc = audio.misc

            if audio.found_tag is False:
                try:
                    tag = stagger.read_tag(nt.fullpath)
                    print("Tag Scan: Found ID3v2 tag")
                    nt.album_artist = tag.album_artist
                    nt.disc_number = str(tag.disc)
                    nt.disc_total = str(tag.disc_total)
                    nt.track_total = str(tag.track_total)
                    nt.title = tag.title
                    nt.artist = tag.artist
                    nt.album = tag.album
                    nt.genre = tag.genre
                    nt.date = tag.date
                except:
                    print("Tag Scan: Couldn't find ID3v2 tag or APE tag")

            return nt

        elif nt.file_ext == "M4A":

            audio = M4a(nt.fullpath)
            audio.read()

            # print(audio.title)

            nt.length = audio.length
            nt.title = audio.title
            nt.artist = audio.artist
            nt.album = audio.album
            nt.composer = audio.composer
            nt.date = audio.date
            nt.samplerate = audio.sample_rate
            nt.size = os.path.getsize(nt.fullpath)
            nt.track_number = audio.track_number
            nt.genre = audio.genre
            nt.album_artist = audio.album_artist
            nt.disc_number = audio.disc_number
            nt.lyrics = audio.lyrics
            nt.bitrate = audio.bit_rate
            #nt.track_total = audio.track_total
            #nt.disc_total = audio.disc_total
            nt.comment = audio.comment
            #nt.track_gain = audio.track_gain
            #nt.album_gain = audio.album_gain
            #nt.cue_sheet = audio.cue_sheet
            nt.misc = audio.misc

            return nt

        else:

            # Use HSAUDIOTAG
            audio = auto.File(nt.fullpath)

            nt.length = audio.duration
            nt.title = rm_16(audio.title)
            nt.artist = rm_16(audio.artist)
            nt.album = rm_16(audio.album)
            nt.track_number = str(audio.track)
            nt.bitrate = audio.bitrate
            nt.date = audio.year
            nt.genre = rm_16(audio.genre)
            nt.samplerate = audio.sample_rate
            nt.size = audio.size
            if audio.comment != "":
                if audio.comment[0:3] == '000':
                    pass
                elif len(audio.comment) > 4 and audio.comment[2] == '+':
                    pass
                else:
                    nt.comment = audio.comment

            if nt.file_ext == "MP3":
                tag = stagger.read_tag(nt.fullpath)
                nt.album_artist = tag.album_artist
                nt.disc_number = str(tag.disc)
                nt.disc_total = str(tag.disc_total)
                nt.track_total = str(tag.track_total)
                nt.genre = tag.genre
                if tag.date:
                    nt.date = tag.date
                nt.composer = tag.composer

                if UFID in tag:
                    for item in tag[UFID]:
                        if hasattr(item, 'owner'):
                            if "musicbrainz.org" in item.owner:
                                nt.misc['musicbrainz_recordingid'] = item.data.decode()

                if TXXX in tag:
                    for item in tag[TXXX]:
                        if hasattr(item, 'description'):
                            if item.description == "replaygain_album_gain":
                                nt.album_gain = float(item.value.strip(" dB"))
                            if item.description == "replaygain_track_gain":
                                nt.track_gain = float(item.value.strip(" dB"))
                            if item.description == "MusicBrainz Release Track Id":
                                nt.misc['musicbrainz_trackid'] = item.value
                            if item.description == "MusicBrainz Album Id":
                                nt.misc['musicbrainz_albumid'] = item.value
                            if item.description == "MusicBrainz Artist Id":
                                if "'musicbrainz_artistids'" not in nt.misc:
                                    nt.misc['musicbrainz_artistids'] = []
                                nt.misc['musicbrainz_artistids'].append(item.value)
                            if item.description == "MusicBrainz Release Group Id":
                                nt.misc['musicbrainz_releasegroupid'] = item.value

                if USLT in tag:
                    lyrics = tag[USLT][0].text
                    if len(lyrics) > 30 and ".com" not in lyrics:
                        nt.lyrics = lyrics
                    elif len(lyrics) > 2:
                        print("Tag Scan: Possible spam found in lyric field")
                        print("     In file: " + nt.fullpath)
                        print("     Value: " + lyrics)

                if SYLT in tag:
                    print("Tag Scan: Found unhandled id3 field 'Synced Lyrics'")
                    print(tag[SYLT][0].text)

            return nt

    except stagger.errors.NoTagError as err:
        # print("Tag Scanner: " + str(err))
        # print("      In file: " + nt.fullpath)
        return nt
    except:

        print("Warning: Tag read error")
        print("     On file: " + nt.fullpath)
        return nt


# Main class that controls playback (play, pause, stepping, playlists, queue etc). Sends commands to backend.
class PlayerCtl:
    # C-PC
    def __init__(self):

        self.running = True
        self.system = system
        self.windows_native = windows_native
        self.install_directory = install_directory
        self.config_directory = config_directory

        # Database

        self.total_playtime = 0
        self.master_library = master_library
        #self.star_library = star_library

        self.shuffle_pools = {}

        # Misc player control

        self.url = ""
        self.save_urls = url_saves
        self.tag_meta = ""
        self.encoder_pause = 0

        # Playback

        self.track_queue = QUE
        self.queue_step = playing_in_queue
        self.playing_time = 0
        self.playlist_playing_position = playlist_playing  # track in playlist that is playing
        self.playlist_view_position = playlist_view_position
        self.target_open = ""
        self.target_object = None
        self.start_time = 0
        self.b_start_time = 0
        self.playerCommand = ""
        self.playerSubCommand = ""
        self.playerCommandReady = False
        self.playing_state = 0
        self.playing_length = 0
        self.jump_time = 0
        self.random_mode = prefs.random_mode
        self.repeat_mode = prefs.repeat_mode
        self.album_repeat_mode = prefs.album_repeat_mode
        self.album_shuffle_mode = prefs.album_shuffle_mode
        # self.album_shuffle_pool = []
        # self.album_shuffle_id = ""
        self.last_playing_time = 0
        self.multi_playlist = multi_playlist
        self.active_playlist_viewing = playlist_active  # the playlist index that is being viewed
        self.active_playlist_playing = playlist_active  # the playlist index that is playing from
        self.force_queue = p_force_queue  # []
        self.pause_queue = False
        self.left_time = 0
        self.left_index = 0
        self.player_volume = volume
        self.new_time = 0
        self.time_to_get = []
        self.a_time = 0
        self.b_time = 0
        #self.playlist_backup = []
        self.active_replaygain = 0
        self.auto_stop = False

        # Broadcasting

        self.broadcast_active = False
        #self.join_broadcast = False
        self.broadcast_playlist = ""
        self.broadcast_position = 0
        self.broadcast_index = 0
        self.broadcast_time = 0
        self.broadcast_last_time = 0
        self.broadcast_line = ""
        self.broadcast_clients = []

        self.record_stream = False
        self.record_title = ""

        # Bass

        self.bass_devices = []
        self.set_device = 0
        self.mpris = None
        self.eq = [0] * 2  # not used
        self.enable_eq = True  # not used

        self.playing_time_int = 0  # playing time but with no decimel

        self.windows_progress = None

        self.finish_transition = False
        # self.queue_target = 0
        self.start_time_target = 0

        self.decode_time = 0

    def finalise(self):

        if self.finish_transition:
            self.playing_time = 0
            self.decode_time = 0
            self.queue_step = len(self.track_queue) - 1
            self.start_time = self.start_time_target
            self.playing_length = pctl.g(pctl.track_queue[self.queue_step]).length
            self.finish_transition = False


    def update_shuffle_pool(self, pl_id, track_list):

        if pl_id in self.shuffle_pools:
            self.shuffle_pools[pl_id] += track_list

    def notify_update(self):

        if self.mpris is not None:
            self.mpris.update()

    def get_url(self, track_object):
        if track_object.file_ext == "PLEX":
            return plex.resolve_stream(track_object.url_key)
        return None

    def playing_playlist(self):
        return self.multi_playlist[self.active_playlist_playing][2]

    def playing_ready(self):
        return len(self.track_queue) > 0

    def selected_ready(self):
        return default_playlist and playlist_selected < len(default_playlist)

    def render_playlist(self):

        if taskbar_progress and system == 'windows' and self.windows_progress:
            self.windows_progress.update(True)
        gui.pl_update = 1

    def show_selected(self):

        if gui.playlist_view_length < 1:
            return 0


        global playlist_selected
        global shift_selection

        for i in range(len(self.multi_playlist[self.active_playlist_viewing][2])):

            if i == playlist_selected:

                if i < pctl.playlist_view_position:
                    pctl.playlist_view_position = i - random.randint(2, int((gui.playlist_view_length / 3) * 2) + int(
                        gui.playlist_view_length / 6))
                elif abs(pctl.playlist_view_position - i) > gui.playlist_view_length:
                    pctl.playlist_view_position = i
                    if i > 6:
                        pctl.playlist_view_position -= 5
                    if i > gui.playlist_view_length * 1 and i + (gui.playlist_view_length * 2) < len(
                            self.multi_playlist[self.active_playlist_viewing][2]) and i > 10:
                        pctl.playlist_view_position = i - random.randint(2, int(gui.playlist_view_length / 3) * 2)
                    break

        self.render_playlist()

        return 0

    def g(self, index):

        return self.master_library[index]

    def playing_object(self):

        if len(self.track_queue) > 0:
            return self.master_library[self.track_queue[self.queue_step]]
        else:
            return None

    def title_text(self):

        line = ""
        if self.playing_state < 3 and pctl.playing_ready():
            title = self.master_library[self.track_queue[self.queue_step]].title
            artist = self.master_library[self.track_queue[self.queue_step]].artist

            if artist != "":
                line += artist
            if title != "":
                if line != "":
                    line += "  -  "
                line += title
        elif not gui.combo_mode:
            line = self.tag_meta

        return line


    def show(self):

        global playlist_selected
        global shift_selection

        if not self.track_queue:
            return 0


    def show_current(self, select=True, playing=True, quiet=False, this_only=False, highlight=False, index=None):

        # print("show------")
        # print(select)
        # print(playing)
        # print(quiet)
        # print(this_only)
        # print(highlight)
        # print("--------")

        global playlist_selected
        global shift_selection

        if not self.track_queue:
            return 0

        track_index = self.track_queue[self.queue_step]
        if index is not None:
            track_index = index

        # Switch to source playlist
        if self.active_playlist_viewing != self.active_playlist_playing and (
                    track_index not in self.multi_playlist[self.active_playlist_viewing][2]):
            switch_playlist(self.active_playlist_playing)

        if gui.playlist_view_length < 1:
            return 0



        for i in range(len(self.multi_playlist[self.active_playlist_viewing][2])):
            if self.multi_playlist[self.active_playlist_viewing][2][i] == track_index:

                if self.playlist_playing_position < len(self.multi_playlist[self.active_playlist_viewing][2]) and self.active_playlist_viewing == self.active_playlist_playing and track_index == \
                        self.multi_playlist[self.active_playlist_viewing][2][self.playlist_playing_position] and \
                        i != self.playlist_playing_position:
                    #continue
                    i = self.playlist_playing_position


                if select:
                    playlist_selected = i


                if playing:
                    # Make the found track the playing track
                    self.playlist_playing_position = i
                    self.active_playlist_playing = self.active_playlist_viewing

                if not (quiet and self.playing_object().length < 15):

                    vl = gui.playlist_view_length
                    if pctl.multi_playlist[pctl.active_playlist_viewing][6] == gui.playlist_current_visible_tracks_id:
                        vl = gui.playlist_current_visible_tracks

                    if i == pctl.playlist_view_position - 1 and pctl.playlist_view_position > 1:
                        pctl.playlist_view_position -= 1

                    # Move a bit if its just out of range
                    elif pctl.playlist_view_position + gui.playlist_view_length - 2 == i and i < len(
                            self.multi_playlist[self.active_playlist_viewing][2]) - 5:
                        pctl.playlist_view_position += 3

                    # We know its out of range if above view postion
                    elif i < pctl.playlist_view_position:
                        pctl.playlist_view_position = i - random.randint(2, int((gui.playlist_view_length / 3) * 2) + int(
                            gui.playlist_view_length / 6))

                    # If its below we need to test if its in view. If playing track in view, don't jump.
                    elif abs(pctl.playlist_view_position - i) >= vl:
                        pctl.playlist_view_position = i
                        if i > 6:
                            pctl.playlist_view_position -= 5
                        if i > gui.playlist_view_length and i + (gui.playlist_view_length * 2) < len(
                                self.multi_playlist[self.active_playlist_viewing][2]) and i > 10:
                            pctl.playlist_view_position = i - random.randint(2, int(gui.playlist_view_length / 3) * 2)
                break
        else:  # Search other all other playlists
            if not this_only:
                for i, playlist in enumerate(self.multi_playlist):
                    if track_index in playlist[2]:

                        switch_playlist(i)
                        self.show_current(select, playing, quiet, this_only=True, index=track_index)
                        break

        if pctl.playlist_view_position < 0:
            pctl.playlist_view_position = 0
        if pctl.playlist_view_position > len(self.multi_playlist[self.active_playlist_viewing][2]) - 1:
            print("Run Over")

        if select:
            shift_selection = []

        self.render_playlist()

        if album_mode and not quiet:
            if highlight:
                gui.gallery_animate_highlight_on = goto_album(playlist_selected)
                gallery_select_animate_timer.set()
            else:
                goto_album(playlist_selected)

        if prefs.artist_list and gui.lsp and not quiet:
            artist_list_box.locate_artist(pctl.playing_object())

        return 0

    def set_volume(self, notify=True):

        self.playerCommand = 'volume'
        self.playerCommandReady = True
        if notify:
            self.notify_update()

    def revert(self):

        if self.queue_step == 0:
            return

        prev = 0
        while len(self.track_queue) > prev + 1 and prev < 5:
            if self.track_queue[len(self.track_queue) - 1 - prev] == self.left_index:
                self.queue_step = len(self.track_queue) - 1 - prev
                self.jump_time = self.left_time
                self.playing_time = self.left_time
                self.decode_time = self.left_time
                break
            prev += 1
        else:
            self.queue_step -= 1
            self.jump_time = 0
            self.playing_time = 0
            self.decode_time = 0

        self.target_open = pctl.master_library[self.track_queue[self.queue_step]].fullpath
        self.target_object = pctl.master_library[self.track_queue[self.queue_step]]
        self.start_time = pctl.master_library[self.track_queue[self.queue_step]].start_time
        self.start_time_target = self.start_time
        self.playing_length = pctl.master_library[self.track_queue[self.queue_step]].length
        self.playerCommand = 'open'
        self.playerCommandReady = True
        self.playing_state = 1

        self.show_current()
        self.render_playlist()

    def play_target_rr(self):

        self.playing_length = pctl.master_library[self.track_queue[self.queue_step]].length

        if self.playing_length > 2:
            random_start = random.randrange(1, int(self.playing_length) - 45 if self.playing_length > 50 else int(
                self.playing_length))
        else:
            random_start = 0

        self.playing_time = random_start
        self.target_open = pctl.master_library[self.track_queue[self.queue_step]].fullpath
        self.target_object = pctl.master_library[self.track_queue[self.queue_step]]
        self.start_time = pctl.master_library[self.track_queue[self.queue_step]].start_time
        self.start_time_target = self.start_time
        self.jump_time = random_start
        self.playerCommand = 'open'
        if not prefs.use_jump_crossfade:
            self.playerSubCommand = 'now'
        self.playerCommandReady = True
        self.playing_state = 1

        self.last_playing_time = random_start

        if update_title:
            update_title_do()


    def play_target_gapless(self, jump=False):


        queue_target = len(self.track_queue) - 1
        self.target_open = pctl.master_library[self.track_queue[queue_target]].fullpath
        self.target_object = pctl.master_library[self.track_queue[queue_target]]
        self.start_time_target = pctl.master_library[self.track_queue[queue_target]].start_time

        # dont set self.start_time yet
        # dont set queue step yet

        # if not gapless:
        self.playerCommand = 'open'
        if jump and not prefs.use_jump_crossfade:
            self.playerSubCommand = 'now'
        self.playerCommandReady = True
        # else:
        #     self.playerCommand = 'gapless'
        self.playing_state = 1
        #self.playing_length = pctl.master_library[self.track_queue[self.queue_step]].length
        self.last_playing_time = 0
        self.finish_transition = True


    def play_target(self, gapless=False, jump=False):

        # print(self.track_queue)
        self.playing_time = 0
        self.decode_time = 0
        self.target_open = pctl.master_library[self.track_queue[self.queue_step]].fullpath
        self.target_object = pctl.master_library[self.track_queue[self.queue_step]]
        self.start_time = pctl.master_library[self.track_queue[self.queue_step]].start_time
        self.start_time_target = self.start_time
        # if not gapless:
        self.playerCommand = 'open'
        self.playing_length = pctl.master_library[self.track_queue[self.queue_step]].length
        self.last_playing_time = 0

        if jump and not prefs.use_jump_crossfade:
            self.playerSubCommand = 'now'
        self.playerCommandReady = True
        # else:
        #     self.playerCommand = 'gapless'
        self.playing_state = 1


        if update_title:
            update_title_do()
        self.notify_update()


    def jump(self, index, pl_position=None):

        lfm_scrobbler.start_queue()

        if self.force_queue and not pctl.pause_queue:
            if self.force_queue[0][4] == 1:
                if pctl.g(self.force_queue[0][0]).parent_folder_path != pctl.g(index).parent_folder_path:
                    del self.force_queue[0]

        if len(self.track_queue) > 0:
            self.left_time = self.playing_time
            self.left_index = self.track_queue[self.queue_step]

            if self.playing_state == 1 and self.left_time > 5 and self.playing_length - self.left_time > 15 :
                pctl.master_library[self.left_index].skips += 1

        global playlist_hold
        gui.update_spec = 0
        self.active_playlist_playing = self.active_playlist_viewing
        self.track_queue.append(index)
        self.queue_step = len(self.track_queue) - 1
        playlist_hold = False
        self.play_target(jump=True)

        if pl_position is not None:
            self.playlist_playing_position = pl_position

        gui.pl_update = 1

    def back(self):

        if len(self.track_queue) > 0:
            self.left_time = self.playing_time
            self.left_index = self.track_queue[self.queue_step]

        gui.update_spec = 0
        # Move up
        if self.random_mode is False and len(self.playing_playlist()) > self.playlist_playing_position > 0:

            if len(self.track_queue) > 0 and self.playing_playlist()[self.playlist_playing_position] != self.track_queue[
                self.queue_step]:
                try:
                    self.playlist_playing_position = self.playing_playlist().index(self.track_queue[self.queue_step])
                except:
                    random_jump = random.randrange(len(self.playing_playlist()))
                    self.playlist_playing_position = random_jump

            self.playlist_playing_position -= 1
            self.track_queue.append(self.playing_playlist()[self.playlist_playing_position])
            self.queue_step = len(self.track_queue) - 1
            self.play_target()

        elif self.random_mode is True and self.queue_step > 0:
            self.queue_step -= 1
            self.play_target()
        else:
            print("BACK: NO CASE!")
            self.show_current()

        if self.active_playlist_viewing == self.active_playlist_playing:
            self.show_current(False, True)

        if album_mode:
            goto_album(self.playlist_playing_position)
        if gui.combo_mode and self.active_playlist_viewing == self.active_playlist_playing:
            self.show_current()

        self.render_playlist()
        self.notify_update()
        notify_song()
        lfm_scrobbler.start_queue()
        gui.pl_update += 1


    def stop(self, block=False, run=False):
        self.playerCommand = 'stop'
        if run:
            self.playerCommand = 'runstop'

        self.playerCommandReady = True
        self.record_stream = False
        if len(self.track_queue) > 0:
            self.left_time = self.playing_time
            self.left_index = self.track_queue[self.queue_step]
        previous_state = self.playing_state
        self.playing_time = 0
        self.decode_time = 0
        self.playing_state = 0
        self.render_playlist()

        gui.update_spec = 0
        # gui.update_level = True  # Allows visualiser to enter decay sequence
        gui.update = True
        if update_title:
            update_title_do()  # Update title bar text

        if block:
            loop = 0
            while self.playerCommand != "stopped":
                time.sleep(0.03)
                if loop > 110:
                    break

        self.notify_update()
        lfm_scrobbler.start_queue()
        return previous_state

    def pause(self):
        if self.playing_state == 3:
            return
        if self.playing_state == 1:
            self.playerCommand = 'pauseon'
            self.playing_state = 2
        elif self.playing_state == 2:
            self.playerCommand = 'pauseoff'
            self.playing_state = 1
            notify_song()
        self.playerCommandReady = True

        self.render_playlist()
        self.notify_update()

    def pause_only(self):
        if self.playing_state == 1:
            self.playerCommand = 'pauseon'
            self.playing_state = 2

            self.playerCommandReady = True
            self.render_playlist()
            self.notify_update()

    def play_pause(self):
        if self.playing_state > 0:
            self.pause()
        else:
            self.play()

    def seek_decimal(self, decimal):

        if self.playing_state == 1 or self.playing_state == 2:
            if decimal > 1:
                decimal = 1
            elif decimal < 0:
                decimal = 0
            self.new_time = pctl.playing_length * decimal
            # print('seek to:' + str(pctl.new_time))
            self.playerCommand = 'seek'
            self.playerCommandReady = True
            self.playing_time = self.new_time

            if system == 'windows' and taskbar_progress and self.windows_progress:
                self.windows_progress.update(True)

            if self.mpris is not None:
                self.mpris.seek_do(self.playing_time)

    def seek_time(self, new):

        if new > self.playing_length + 5:
            print("INVALID SEEK VALUE")
            pass

        if new < 0:
            new = 0

        self.new_time = new
        self.playing_time = new

        self.playerCommand = 'seek'
        self.playerCommandReady = True

        print("seek: " + str(new))

        if self.mpris is not None:
            self.mpris.seek_do(self.playing_time)

    def play(self):

        # Unpause if paused
        if self.playing_state == 2:
            self.playerCommand = 'pauseoff'
            self.playerCommandReady = True
            self.playing_state = 1

        # If stopped...
        elif pctl.playing_state == 0:

            # If the queue is empty
            if self.track_queue == [] and len(self.multi_playlist[self.active_playlist_playing][2]) > 0:
                self.track_queue.append(self.multi_playlist[self.active_playlist_playing][2][0])
                self.queue_step = 0
                self.playlist_playing_position = 0
                self.active_playlist_playing = 0

                self.play_target()

            # If the queue is not empty, play?
            elif len(self.track_queue) > 0:
                self.play_target()

        self.render_playlist()
        self.notify_update()


    def test_progress(self):

        global playlist_selected

        # Fuzzy reload lastfm for rescrobble
        if lfm_scrobbler.a_sc and self.playing_time < 1:
            lfm_scrobbler.a_sc = False
            self.a_time = 0

        # Update the UI if playing time changes a whole number
        next_round = int(pctl.playing_time)
        if self.playing_time_int != next_round:
            gui.update += 1
            self.playing_time_int = next_round

        if not prefs.use_transition_crossfade:
            gap_extra = 0.9
        else:
            gap_extra = prefs.cross_fade_time / 1000

        if prefs.backend == 2:  # (gstreamer)
            gap_extra = 2

        if system == 'windows' and taskbar_progress and self.windows_progress:
            self.windows_progress.update(True)

        if self.playing_state == 1 and self.decode_time + gap_extra >= self.playing_length and self.decode_time > 0.2:

            self.decode_time = 0
            if self.playing_length == 0 and self.playing_time < 4:
                # If the length is unknown, allow backend some time to provide a duration
                pass
            else:

                pp = self.playing_playlist()

                if pctl.auto_stop: # and not pctl.force_queue and not (pctl.force_queue and pctl.pause_queue):
                    self.stop(run=True)
                    if pctl.force_queue or (not pctl.force_queue and not pctl.random_mode and not pctl.repeat_mode):
                        self.advance(play=False)
                    gui.update += 2
                    pctl.auto_stop = False

                elif self.force_queue and not self.pause_queue:
                    self.advance(end=True)

                elif self.repeat_mode is True:

                    if self.album_repeat_mode:

                        if self.playlist_playing_position > len(pp) - 1:
                            self.playlist_playing_position = 0  # Hack fix, race conditon bug?

                        ti = self.g(pp[self.playlist_playing_position])

                        i = self.playlist_playing_position

                        # Test if next track is in same folder
                        if i + 1 < len(pp):
                            nt = self.g(pp[i + 1])
                            if ti.parent_folder_path == nt.parent_folder_path:
                                # The next track is in the same folder
                                # so advance normaly
                                self.advance(quiet=True, end=True)
                                return

                        # We need to backtrack to see where the folder begins
                        i -= 1
                        while i >= 0:
                            nt = self.g(pp[i])
                            if ti.parent_folder_path != nt.parent_folder_path:
                                i += 1
                                break
                            i -= 1
                        if i < 0:
                            i = 0

                        playlist_selected = i
                        shift_selection = [i]

                        self.jump(pp[i], i)

                    elif prefs.playback_follow_cursor and self.playing_ready() \
                            and self.multi_playlist[pctl.active_playlist_viewing][2][
                        playlist_selected] != self.playing_object().index \
                            and -1 < playlist_selected < len(default_playlist):

                        print("Repeat follow cursor")

                        self.playing_time = 0
                        self.decode_time = 0
                        self.active_playlist_playing = self.active_playlist_viewing
                        self.playlist_playing_position = playlist_selected

                        self.track_queue.append(default_playlist[playlist_selected])
                        self.queue_step = len(self.track_queue) - 1
                        self.play_target(jump=False)
                        self.render_playlist()
                        lfm_scrobbler.start_queue()

                    else:

                        self.playing_time = 0
                        self.decode_time = 0
                        self.new_time = 0
                        self.playerCommand = 'seek'
                        self.playerCommandReady = True

                        self.render_playlist()
                        lfm_scrobbler.start_queue()

                        # Reload lastfm for rescrobble
                        if lfm_scrobbler.a_sc:
                            lfm_scrobbler.a_sc = False
                            self.a_time = 0


                elif    self.random_mode is False and len(pp) > self.playlist_playing_position + 1 and \
                        self.master_library[pp[self.playlist_playing_position]].is_cue is True \
                        and self.master_library[pp[self.playlist_playing_position + 1]].filename == \
                        self.master_library[pp[self.playlist_playing_position]].filename and int(
                    self.master_library[pp[self.playlist_playing_position]].track_number) == int(
                    self.master_library[pp[self.playlist_playing_position + 1]].track_number) - 1:

                    #  not (self.force_queue and not self.pause_queue) and \

                    # We can shave it closer
                    if not self.playing_time + 0.1 >= self.playing_length:
                        return

                    print("Do transition CUE")
                    self.playlist_playing_position += 1
                    self.queue_step += 1
                    self.track_queue.append(pp[self.playlist_playing_position])
                    self.playing_state = 1
                    self.playing_time = 0
                    self.decode_time = 0
                    self.playing_length = self.master_library[self.track_queue[self.queue_step]].length
                    self.start_time = self.master_library[self.track_queue[self.queue_step]].start_time
                    self.start_time_target = self.start_time
                    lfm_scrobbler.start_queue()

                    gui.update += 1
                    gui.pl_update = 1

                else:
                    self.advance(quiet=True, end=True)

                    self.playing_time = 0
                    self.decode_time = 0


    def advance(self, rr=False, quiet=False, gapless=False, inplace=False, end=False, force=False, nolock=False, play=True):

        # Temporary Workaround for UI block causing unwanted dragging
        quick_d_timer.set()


        # Trim the history if it gets too long
        while len(self.track_queue) > 250:
            self.queue_step -= 1
            del self.track_queue[0]


        if len(self.track_queue) > 0:
            self.left_time = self.playing_time
            self.left_index = self.track_queue[self.queue_step]

        # Test to register skip (not currently used for anything)
        if self.playing_state == 1 and 1 < self.left_time < 45:
            pctl.master_library[self.left_index].skips += 1
            # print('skip registered')

        #if pctl.playing_length <= 0:
        pctl.playing_time = 0
        pctl.decode_time = 0
        pctl.playing_length = 100



        gui.update_spec = 0

        old = self.queue_step

        end_of_playlist = False

        # Force queue (middle click on track)
        if len(self.force_queue) > 0 and not self.pause_queue:

            q = self.force_queue[0]
            target_index = q[0]

            if q[3] == 1:
                # This is an album type

                if q[4] == 0:
                    # We have not started playing the album yet
                    # So we go to that track
                    # (This is a copy of the track code, but we don't delete the item)

                    pl = id_to_pl(q[2])
                    if pl is not None:
                        self.active_playlist_playing = pl

                    if target_index not in self.playing_playlist():
                        del self.force_queue[0]
                        self.advance(nolock=True)
                        return



                    self.playlist_playing_position = q[1]
                    self.track_queue.append(target_index)
                    self.queue_step = len(self.track_queue) - 1
                    #self.queue_target = len(self.track_queue) - 1
                    if play:
                        self.play_target(jump=not end)

                    #  Set the flag that we have entered the album
                    self.force_queue[0][4] = 1


                    # This code is mirrored below -------
                    ok_continue = True

                    # Check if we are at end of playlist
                    pl = pctl.multi_playlist[pctl.active_playlist_playing][2]
                    if self.playlist_playing_position > len(pl) - 3:
                        ok_continue = False

                    # Check next song is in album
                    if ok_continue:
                        if self.g(pl[self.playlist_playing_position + 1]).parent_folder_path != pctl.g(target_index).parent_folder_path:
                            ok_continue = False

                    # -----------


                elif q[4] == 1:
                    # We have previously started playing this album

                    # Check to see if we still are:
                    ok_continue = True

                    if pctl.g(target_index).parent_folder_path != pctl.playing_object().parent_folder_path:
                        # Remember to set jumper check this too
                        ok_continue = False

                    # Check if we are at end of playlist
                    pl = pctl.multi_playlist[pctl.active_playlist_playing][2]
                    if self.playlist_playing_position > len(pl) - 3:
                        ok_continue = False

                    # Check next song is in album
                    if ok_continue:
                        if self.g(pl[self.playlist_playing_position + 2]).parent_folder_path != pctl.g(target_index).parent_folder_path:
                            ok_continue = False

                    #if ok_continue:
                    # We seem to be still in the album. Step down one and play
                    self.playlist_playing_position += 1

                    if len(pl) <= self.playlist_playing_position:
                        print("END OF PLAYLIST!")
                        del self.force_queue[0]
                        self.advance(nolock=True)
                        return

                    self.track_queue.append(pl[self.playlist_playing_position])
                    self.queue_step = len(self.track_queue) - 1
                    #self.queue_target = len(self.track_queue) - 1
                    if play:
                        self.play_target(jump=not end)

                if not ok_continue:
                    # It seems this item has expired, remove it and call advance again
                    print("Remove expired album from queue")
                    del self.force_queue[0]

                    if q[6]:
                        pctl.auto_stop = True

                    if queue_box.scroll_position > 0:
                        queue_box.scroll_position -= 1

                        #self.advance()
                        #return

            else:
                # This is track type
                pl = id_to_pl(q[2])
                if pl is not None:
                    self.active_playlist_playing = pl

                if target_index not in self.playing_playlist():
                    del self.force_queue[0]
                    self.advance(nolock=True)
                    return

                self.playlist_playing_position = q[1]
                self.track_queue.append(target_index)
                self.queue_step = len(self.track_queue) - 1
                #self.queue_target = len(self.track_queue) - 1
                if play:
                    self.play_target(jump= not end)
                del self.force_queue[0]
                if q[6]:
                    pctl.auto_stop = True
                if queue_box.scroll_position > 0:
                    queue_box.scroll_position -= 1

        # Stop if playlist is empty
        elif len(self.playing_playlist()) == 0:
            self.stop()
            return 0

        # Playback follow cursor
        elif prefs.playback_follow_cursor and self.playing_ready() \
                and self.multi_playlist[pctl.active_playlist_viewing][2][playlist_selected] != self.playing_object().index \
                and -1 < playlist_selected < len(default_playlist):

            self.active_playlist_playing = self.active_playlist_viewing
            self.playlist_playing_position = playlist_selected

            self.track_queue.append(default_playlist[playlist_selected])
            self.queue_step = len(self.track_queue) - 1
            if play:
                self.play_target(jump=not end)

        # If random, jump to random track
        elif (self.random_mode or rr) and len(self.playing_playlist()) > 0 and not self.album_shuffle_mode:
            #self.queue_step += 1
            new_step = self.queue_step + 1

            if new_step == len(self.track_queue):

                if self.album_repeat_mode and self.repeat_mode:
                    # Album shuffle mode
                    pp = self.playing_playlist()
                    k = self.playlist_playing_position
                    #ti = self.g(pp[k])
                    ti = self.master_library[self.track_queue[self.queue_step]]

                    if ti.index not in pp:
                        print("No tracks to repeat!")
                        return 0


                    matches = []
                    for i, p in enumerate(pp):

                        if self.g(p).parent_folder_path == ti.parent_folder_path:
                            matches.append((i, p))

                    if matches:
                        # Avoid a repeat of same track
                        if len(matches) > 1 and (k, ti.index) in matches:
                            matches.remove((k, ti.index))

                        i, p = random.choice(matches)

                        if prefs.true_shuffle:

                            id = ti.parent_folder_path

                            while True:
                                if id in pctl.shuffle_pools:

                                     pool = pctl.shuffle_pools[id]

                                     if not pool:
                                         del pctl.shuffle_pools[id]  # Trigger a refill
                                         continue

                                     ref = random.choice(pool)
                                     pool.remove(ref)

                                     if ref[1] not in pp:  # Check track still in the live playlist
                                         print("Track not in pool")
                                         continue

                                     i, p = ref  # Find position of reference in playlist
                                     break

                                else:
                                     # Refill the pool
                                     pctl.shuffle_pools[id] = matches
                                     print("Refill folder shuffle pool")


                        self.playlist_playing_position = i
                        self.track_queue.append(p)

                else:
                    # Normal select from playlist

                    if prefs.true_shuffle:
                        # True shuffle avoides repeats by using a pool

                        pl = pctl.multi_playlist[pctl.active_playlist_playing]
                        id = pl[6]

                        while True:

                            if id in pctl.shuffle_pools:

                                pool = pctl.shuffle_pools[id]

                                if not pool:
                                    del pctl.shuffle_pools[id]  # Trigger a refill
                                    continue

                                ref = random.choice(pool)
                                pool.remove(ref)

                                if ref not in pl[2]:  # Check track still in the live playlist
                                    continue

                                random_jump = pl[2].index(ref)  # Find position of reference in playlist
                                break

                            else:
                                # Refill the pool
                                pctl.shuffle_pools[id] = copy.deepcopy(pl[2])
                                print("Refill shuffle pool")

                    else:
                        random_jump = random.randrange(len(self.playing_playlist()))
                    self.playlist_playing_position = random_jump
                    self.track_queue.append(self.playing_playlist()[random_jump])


            if inplace and self.queue_step > 1:
                del self.track_queue[self.queue_step]
            else:
                self.queue_step = new_step


            if rr:
                self.play_target_rr()
            else:
                if play:
                    self.play_target(jump=not end)


        # If not random mode, Step down 1 on the playlist
        elif self.random_mode is False and len(self.playing_playlist()) > 0:

            # Stop at end of playlist
            if self.playlist_playing_position == len(self.playing_playlist()) - 1:
                if prefs.end_setting == 'stop':
                    self.playing_state = 0
                    self.playerCommand = 'runstop'
                    self.playerCommandReady = True
                    end_of_playlist = True

                elif prefs.end_setting == 'advance' or prefs.end_setting == 'cycle':

                    # If at end playlist and not cycle mode, stop playback
                    if pctl.active_playlist_playing == len(pctl.multi_playlist) - 1 and not prefs.end_setting == 'cycle':
                        self.playing_state = 0
                        self.playerCommand = 'runstop'
                        self.playerCommandReady = True
                        end_of_playlist = True

                    else:

                        p = pctl.active_playlist_playing
                        for i in range(len(pctl.multi_playlist)):

                            k = (p + i + 1) %  len(pctl.multi_playlist)

                            # Skip a playlist if empty
                            if not (pctl.multi_playlist[k][2]):
                                continue

                            # Skip a playlist if hidden
                            if pctl.multi_playlist[k][8] and prefs.tabs_on_top:
                                continue

                            # Set found playlist as playing the first track
                            pctl.active_playlist_playing = k
                            pctl.playlist_playing_position = -1
                            pctl.advance(end=end, force=True, nolock=True, play=play)
                            break

                        else:
                            # Restart current if no other eligible playlist found
                            pctl.playlist_playing_position = -1
                            pctl.advance(end=end, force=True, nolock=True, play=play)


                elif prefs.end_setting == 'repeat':
                    pctl.playlist_playing_position = -1
                    pctl.advance(end=end, force=True, nolock=True, play=play)

                gui.update += 3

            else:
                if self.playlist_playing_position > len(self.playing_playlist()) - 1:
                    self.playlist_playing_position = 0

                elif not force and len(self.track_queue) > 0 and self.playing_playlist()[self.playlist_playing_position] != self.track_queue[
                    self.queue_step]:
                    try:
                        self.playlist_playing_position = self.playing_playlist().index(self.track_queue[self.queue_step])
                    except:
                        pass

                if len(self.playing_playlist()) == self.playlist_playing_position + 1:
                    return

                self.playlist_playing_position += 1
                self.track_queue.append(self.playing_playlist()[self.playlist_playing_position])

                print("standand advance")
                #self.queue_target = len(self.track_queue) - 1
                # if end:
                #     self.play_target_gapless(jump= not end)
                # else:
                self.queue_step = len(self.track_queue) - 1
                if play:
                    self.play_target(jump= not end)

        else:

            if self.random_mode and self.album_shuffle_mode:

                # Album shuffle mode
                print("Album shuffle mode")

                po = self.playing_object()

                redraw = False

                # Checks
                if po is not None and len(self.playing_playlist()) > 0:

                    # If we at end of playlist, we'll go to a new album
                    if len(self.playing_playlist()) == self.playlist_playing_position + 1:
                        redraw = True
                    # If the next track is a new album, go to a new album
                    elif po.parent_folder_path != pctl.g(self.playing_playlist()[self.playlist_playing_position + 1]).parent_folder_path:
                        redraw = True

                    if not redraw:
                        print("Trigger Pass")
                        self.playlist_playing_position += 1
                        self.track_queue.append(self.playing_playlist()[self.playlist_playing_position])
                        self.queue_step = len(self.track_queue) - 1
                        #self.queue_target = len(self.track_queue) - 1
                        if play:
                            self.play_target(jump=not end)

                    else:

                        albums = []
                        current_folder = ""
                        for i in range(len(self.playing_playlist())):
                            if i == 0:
                                albums.append(i)
                                current_folder = self.master_library[self.playing_playlist()[i]].parent_folder_path
                            else:
                                if pctl.master_library[self.playing_playlist()[i]].parent_folder_path != current_folder:
                                    current_folder = self.master_library[self.playing_playlist()[i]].parent_folder_path
                                    albums.append(i)

                        random.shuffle(albums)

                        for a in albums:

                            if self.g(self.playing_playlist()[a]).parent_folder_path != self.playing_object().parent_folder_path:
                                self.playlist_playing_position = a
                                self.track_queue.append(self.playing_playlist()[a])
                                self.queue_step = len(self.track_queue) - 1
                                #self.queue_target = len(self.track_queue) - 1
                                if play:
                                    self.play_target(jump=not end)
                                break
                            else:
                                print("THERS ONLY ONE ALBUM IN THE PLAYLIST")
                                self.stop()

            else:
                print("ADVANCE ERROR - NO CASE!")

        if self.active_playlist_viewing == self.active_playlist_playing:
            self.show_current(quiet=quiet)

        # if album_mode:
        #     goto_album(self.playlist_playing)

        self.render_playlist()

        self.notify_update()
        lfm_scrobbler.start_queue()
        notify_song(end_of_playlist, delay=1.3)


pctl = PlayerCtl()


def auto_name_pl(target_pl):

    if not pctl.multi_playlist[target_pl][2]:
        return

    albums = []
    artists = []
    parents = []

    track = None

    for index in pctl.multi_playlist[target_pl][2]:
        track = pctl.g(index)
        albums.append(track.album)
        if track.album_artist:
            artists.append(track.album_artist)
        else:
            artists.append(track.artist)
        parents.append(track.parent_folder_path)

    nt = ""
    artist = ""

    if track:
        artist = track.artist
        if track.album_artist:
            artist = track.album_artist

    if track and albums and albums[0] and albums.count(albums[0]) == len(albums):
        nt = artist + " - " + track.album

    elif track and artists and artists[0] and artists.count(artists[0]) == len(artists):
        nt = artists[0]

    else:
        nt = os.path.basename(commonprefix(parents))

    pctl.multi_playlist[target_pl][0] = nt



def get_object(index):
    return pctl.master_library[index]

def update_title_do():

    if pctl.playing_state > 0:
        if len(pctl.track_queue) > 0:
            line = pctl.master_library[pctl.track_queue[pctl.queue_step]].artist + " - " + \
                   pctl.master_library[pctl.track_queue[pctl.queue_step]].title
            #line += "   : :   Tauon Music Box"
            line = line.encode('utf-8')
            SDL_SetWindowTitle(t_window, line)
    else:
        line = "Tauon Music Box"
        line = line.encode('utf-8')
        SDL_SetWindowTitle(t_window, line)

if de_nofity_support:
    song_notification = Notify.Notification.new("Next track notification")


def notify_song_fire(notification, delay, id):

    time.sleep(delay)
    notification.show()

    if id is None:
        return

    time.sleep(15)
    if id == gui.notify_main_id:
        notification.close()


def notify_song(notify_of_end=False, delay=0):

    if not de_nofity_support:
        return


    if prefs.show_notifications and pctl.playing_object() is not None and not window_is_focused():

        if prefs.stop_notifications_mini_mode and gui.mode == 3:
            return

        track = pctl.playing_object()

        if not (track.title or track.artist or track.album):
            return  # only display if we have at least one piece of metadata avaliable

        i_path = ""
        try:
            if not notify_of_end:
                i_path = thumb_tracks.path(track)
        except:
            print("Thumbnail error")

        bottom_line = (track.artist + " | " + track.album).strip("| ")

        top_line = track.title

        gui.notify_main_id = uid_gen()
        id = gui.notify_main_id

        if notify_of_end:
            bottom_line = "Tauon Music Box"
            top_line = _("End of playlist")

            song_notification.update(top_line, bottom_line, i_path)
            id = None

        elif track.album:
            song_notification.update(top_line, bottom_line, i_path)

        else:
            song_notification.update(bottom_line, "", i_path)

        if not delay:
            song_notification.show()

            if id is None:
                return

            time.sleep(15)
            if id == gui.notify_main_id:
                notification.close()

        else:
            shoot_dl = threading.Thread(target=notify_song_fire, args=([song_notification, delay, id]))
            shoot_dl.daemon = True
            shoot_dl.start()



# Last.FM -----------------------------------------------------------------
class LastFMapi:

    API_SECRET = "6e433964d3ff5e817b7724d16a9cf0cc"
    connected = False
    hold = False
    API_KEY = "bfdaf6357f1dddd494e5bee1afe38254"
    scanning_username = ""

    network = None
    tries = 0

    scanning_friends = False

    def __init__(self):

        self.sg = None
        self.url = None

    def auth1(self):

        # This is step one where the user clicks "login"

        if self.network is None:
            self.no_user_connect()

        self.sg = pylast.SessionKeyGenerator(self.network)
        self.url = self.sg.get_web_auth_url()
        show_message("Web auth paged opened", 'arrow', "Once authorised click the 'done' button.")
        webbrowser.open(self.url, new=2, autoraise=True)

    def auth2(self):

        # This is step 2 where the user clicks "Done"

        if self.sg is None:
            show_message("You need to login first")
            return

        try:
            # session_key = self.sg.get_web_auth_session_key(self.url)
            session_key, username = self.sg.get_web_auth_session_key_username(self.url)
            prefs.last_fm_token = session_key
            self.network = pylast.LastFMNetwork(api_key=self.API_KEY, api_secret=
                self.API_SECRET, session_key=prefs.last_fm_token)
            # user = self.network.get_authenticated_user()
            # username = user.get_name()
            prefs.last_fm_username = username

        except Exception as e:
            if 'Unauthorized Token' in str(e):
                show_message("Error - Not authorized", 'error')
            else:
                show_message("Error", 'error', 'Unknown error.')

        if not toggle_lfm_auto(mode=1):
            toggle_lfm_auto()

    def auth3(self):

        # This is used for "logout"

        prefs.last_fm_token = None
        prefs.last_fm_username = ""
        show_message("Logout will complete on app restart.")


    def connect(self, m_notify=True):

        if not last_fm_enable:
            return False

        if self.connected is True:
            if m_notify:
                show_message("Already connected to Last.fm")
            return True

        if prefs.last_fm_token is None:
            show_message("No Last.Fm account registered", 'info', "Authorise an account in settings")
            return

        print('Attempting to connect to Last.fm network')

        try:

            self.network = pylast.LastFMNetwork(api_key=self.API_KEY, api_secret=
                self.API_SECRET, session_key=prefs.last_fm_token) #, username=lfm_username, password_hash=lfm_hash)

            self.connected = True
            if m_notify:
                show_message("Connection to Last.fm was successful.", 'done')

            print('Connection to lastfm appears successful')
            return True

        except Exception as e:
            show_message("Error connecting to Last.fm network", "warning", str(e))
            # print(e)
            return False

    def toggle(self):
        #if self.connected:
        self.hold ^= True
        #else:
        #    self.connect()

    def details_ready(self):
        if prefs.last_fm_token:
        #if len(lfm_username) > 1 and len(lfm_username) > 1 and prefs.auto_lfm:
            return True
        else:
            return False

    def no_user_connect(self):

        try:
            self.network = pylast.LastFMNetwork(api_key=self.API_KEY, api_secret=self.API_SECRET)
            print('Connection appears successful')
            return True

        except Exception as e:
            show_message("Error communicating with Last.fm network", "warning", str(e))
            print(e)
            return False


    def artist_info(self, artist):

        if self.network is None:
            if self.no_user_connect() is False:
                return False, "", ""

        try:
            if artist != "":
                l_artist = pylast.Artist(artist, self.network)
                bio = l_artist.get_bio_content()
                cover_link = l_artist.get_cover_image()
                mbid = l_artist.get_mbid()

                return True, bio, cover_link, mbid
        except:
            print("last.fm get artist info failed")

        return False, "", "", ""

    def artist_mbid(self, artist):

        if self.network is None:
            if self.no_user_connect() is False:
                return ""

        try:
            if artist != "":
                l_artist = pylast.Artist(artist, self.network)
                mbid = l_artist.get_mbid()
                return mbid
        except:
            print("last.fm get artist mbid info failed")

        return ""

    def scrobble(self, track_object, timestamp=None):
        if self.hold:
            return
        if prefs.auto_lfm:
            self.connect(False)

        if timestamp is None:
            timestamp = int(time.time())

        # lastfm_user = self.network.get_user(self.username)

        title = track_object.title
        album = track_object.album
        artist = get_artist_strip_feat(track_object)

        # Act
        try:
            if title != "" and artist != "":
                if album != "":
                    self.network.scrobble(artist=artist, title=title, album=album, timestamp=timestamp)
                else:
                    self.network.scrobble(artist=artist, title=title, timestamp=timestamp)
                print('Scrobbled')
            else:
                print("Not sent, incomplete metadata")

        except Exception as e:

            if 'retry' in str(e):
                print("Retrying...")
                time.sleep(7)

                try:
                    self.network.scrobble(artist=artist, title=title, timestamp=timestamp)
                    print('Scrobbled')
                    return True
                except:
                    pass

            show_message("Error: Could not scrobble. ", 'warning', str(e))
            print(e)
            return False

    def get_bio(self, artist):
        #if self.connected:
        if self.network is None:
            self.no_user_connect()

        artist_object = pylast.Artist(artist, self.network)
        bio = artist_object.get_bio_summary(language="en")
        # print(artist_object.get_cover_image())
        # print("\n\n")
        # print(bio)
        # print("\n\n")
        # print(artist_object.get_bio_content())
        return bio
        #else:
        #    return ""

    def love(self, artist, title):
        if not self.connected and prefs.auto_lfm:
            self.connect(False)
            self.hold = True
        if self.connected and artist != "" and title != "":
            track = self.network.get_track(artist, title)
            track.love()

    def unlove(self, artist, title):
        if not self.connected and prefs.auto_lfm:
            self.connect(False)
            self.hold = True
        if self.connected and artist != "" and title != "":
            track = self.network.get_track(artist, title)
            track.love()
            track.unlove()

    def clear_friends_love(self):

        count = 0
        for index, tr in pctl.master_library.items():
            count += len(tr.lfm_friend_likes)
            tr.lfm_friend_likes.clear()

        show_message("Removed {} loves.".format(count))

    def get_friends_love(self):

        self.scanning_friends = True

        try:
            username = prefs.last_fm_username

            if not username:
                return

            if self.network is None:
                self.no_user_connect()

            time.sleep(1)
            lastfm_user = self.network.get_user(username)
            friends = lastfm_user.get_friends(limit=None)
            show_message("Getting friend data...", 'info', "This may take a very long time.")
            time.sleep(3)
            for friend in friends:
                self.scanning_username = friend.name
                time.sleep(1)
                print("Getting friend loves: " + friend.name)

                try:
                    loves = friend.get_loved_tracks(limit=None)
                except:
                    continue

                for track in loves:
                    title = track.track.title.casefold()
                    artist = track.track.artist.name.casefold()
                    time.sleep(0.001)
                    for index, tr in pctl.master_library.items():

                        if tr.title.casefold() == title and tr.artist.casefold() == artist:
                            tr.lfm_friend_likes.add(friend.name)
                            print("MATCH")
                            print("     " + artist + " - " + title)
                            print("      ----- " + friend.name)

        except:
            show_message("There was an error getting friends loves", 'warning', "")

        self.scanning_friends = False

    def dl_love(self):


        username = prefs.last_fm_username

        if not username:
            show_message("No username found", 'error')
            return

        if len(username) > 25:
            return

        if lfm_dl_timer.get() < 15:
            show_message("Dont press this button so much.")
        lfm_dl_timer.set()

        try:
            if self.network is None:
                self.no_user_connect()

            print("Lookup last.fm user " + username)

            lastfm_user = self.network.get_user(username)
            tracks = lastfm_user.get_loved_tracks(limit=None)
            #tracks = lastfm_user.get_recent_tracks()

            matches = 0
            misses = 0
            updated = 0

            for track in tracks:
                title = track.track.title.casefold()
                artist = track.track.artist.name.casefold()

                for index, tr in pctl.master_library.items():
                    if tr.title.casefold() == title and tr.artist.casefold() == artist:
                        matches += 1
                        print("MATCH:")
                        print("     " + artist + " - " + title)
                        star = star_store.full_get(index)
                        if star is None:
                            star = [0, ""]
                        if "L" not in star[1]:
                            updated += 1
                            print("     NEW LOVE")
                        star = [star[0], star[1] + "L"]
                        star_store.insert(index, star)

            if len(tracks) == 0:
                show_message("User has no loved tracks.")
                return
            if matches > 0 and updated == 0:
                show_message(str(matches) + " matched tracks are up to date.")
                return
            if matches > 0 and updated > 0:
                show_message(str(matches) + " tracks matched. " + str(updated) + " were updated.")
                return
            else:
                show_message("Of " + str(len(tracks)) + " loved tracks, no matches were found in local db")
                return
        except:
            show_message("This doesn't seem to be working :(", 'error')


    def update(self, track_object):
        if self.hold:
            return 0
        if prefs.auto_lfm:
            if self.connect(False) is False:
                prefs.auto_lfm = False
        else:
            return 0

        # print('Updating Now Playing')

        title = track_object.title
        album = track_object.album
        artist = get_artist_strip_feat(track_object)

        try:
            if title != "" and artist != "":
                self.network.update_now_playing(
                    artist=artist, title=title, album=album)
                return 0
            else:
                print("Not sent, incomplete metadata")
        except Exception as e:

            print(e)
            if 'retry' in str(e):
                return 2
                show_message("Could not update Last.fm. ", 'warning', str(e))
            pctl.b_time -= 5000
            return 1


def get_backend_time(path):
    pctl.time_to_get = path

    pctl.playerCommand = 'time'
    pctl.playerCommandReady = True

    while pctl.playerCommand != 'done':
        time.sleep(0.005)

    return pctl.time_to_get


lastfm = LastFMapi()

class ListenBrainz:

    def __init__(self):

        self.enable = prefs.enable_lb
        self.hold = False
        self.url = "https://api.listenbrainz.org/1/submit-listens"

    def listen_full(self, track_object, time):

        if self.enable is False:
            return
        if self.hold is True:
            return
        if prefs.lb_token is None:
            show_message("ListenBrains is enabled but there is no token.", 'error', "How did this even happen.")

        title = track_object.title
        album = track_object.album
        artist = get_artist_strip_feat(track_object)

        if title == "" or artist == "":
            return

        data = {"listen_type": "single", "payload": []}
        metadata = {"track_name": title, "artist_name": artist}

        additional = {}

        # MusicBrainz Artist IDs
        if 'musicbrainz_artistids' in track_object.misc:
            additional['artist_mbids'] = track_object.misc['musicbrainz_artistids']

        # MusicBrainz Release ID
        if 'musicbrainz_albumid' in track_object.misc:
            additional['release_mbid'] = track_object.misc['musicbrainz_albumid']

        # MusicBrainz Recording ID
        if 'musicbrainz_recordingid' in track_object.misc:
            additional['recording_mbid'] = track_object.misc['musicbrainz_recordingid']

        # MusicBrainz Track ID
        if 'musicbrainz_trackid' in track_object.misc:
            additional['track_mbid'] = track_object.misc['musicbrainz_trackid']

        if additional:
            metadata['additional_info'] = additional

        data["payload"].append({"track_metadata": metadata})
        data["payload"][0]["listened_at"] = time


        r = requests.post(self.url, headers={"Authorization": "Token " + prefs.lb_token}, data=json.dumps(data))
        if r.status_code != 200:
            show_message("There was an error submitting data to ListenBrainz", 'warning', r.text)
            return False

    def listen_playing(self, track_object):

        if self.enable is False:
            return
        if self.hold is True:
            return
        if prefs.lb_token is None:
            show_message("ListenBrains is enabled but there is no token.", 'error', "How did this even happen.")

        title = track_object.title
        album = track_object.album
        artist = get_artist_strip_feat(track_object)

        if title == "" or artist == "":
            return

        data = {"listen_type": "playing_now", "payload": []}
        metadata = {"track_name": title, "artist_name": artist}

        additional = {}

        # MusicBrainz Artist IDs
        if 'musicbrainz_artistids' in track_object.misc:
            additional['artist_mbids'] = track_object.misc['musicbrainz_artistids']

        # MusicBrainz Release ID
        if 'musicbrainz_albumid' in track_object.misc:
            additional['release_mbid'] = track_object.misc['musicbrainz_albumid']

        # MusicBrainz Recording ID
        if 'musicbrainz_recordingid' in track_object.misc:
            additional['recording_mbid'] = track_object.misc['musicbrainz_recordingid']

        # MusicBrainz Track ID
        if 'musicbrainz_trackid' in track_object.misc:
            additional['track_mbid'] = track_object.misc['musicbrainz_trackid']

        if additional:
            metadata['additional_info'] = additional

        data["payload"].append({"track_metadata": metadata})
        #data["payload"][0]["listened_at"] = int(time.time())

        r = requests.post(self.url, headers={"Authorization": "Token " + prefs.lb_token}, data=json.dumps(data))
        if r.status_code != 200:
            show_message("There was an error submitting data to ListenBrainz", 'warning', r.text)
            print("error")
            print(r.status_code)
            print(r.json())

    def paste_key(self):

        text = copy_from_clipboard()
        if text == "":
            show_message("There is no text in the clipboard", "error")
            return
        if len(text) == 36 and text[8] == "-":
            prefs.lb_token = text
        else:
            show_message("That is not a valid token", "error")

    def clear_key(self):

        prefs.lb_token = ""
        save_prefs()
        self.enable = False


lb = ListenBrainz()

def get_love(track_object):

    star = star_store.full_get(track_object.index)
    if star is None:
        return False

    if 'L' in star[1]:
        return True
    else:
        return False

def get_love_index(index):

    star = star_store.full_get(index)
    if star is None:
        return False

    if 'L' in star[1]:
        return True
    else:
        return False

def love(set=True, index=None):

    if len(pctl.track_queue) < 1:
        return False

    if index is None:
        index = pctl.track_queue[pctl.queue_step]

    loved = False
    star = star_store.full_get(index)

    if star is not None:
        if 'L' in star[1]:
            loved = True

    if set is False:
        return loved

    # global lfm_username
    # if len(lfm_username) > 0 and not lastfm.connected and not prefs.auto_lfm:
    #     show_message("You have a last.fm account ready but it is not enabled.", 'info',
    #                  'Either connect, enable auto connect, or remove the account.')
    #     return

    if star is None:
        star = [0, ""]

    loved ^= True

    if loved:
        time.sleep(0.3)
        gui.update += 1
        gui.pl_update += 1
        star = [star[0], star[1] + "L"]
        star_store.insert(index, star)
        try:
            lastfm.love(pctl.master_library[index].artist, pctl.master_library[index].title)
        except:
            print("Failed updating last.fm love status", 'warning')
            star = [star[0], star[1].strip("L")]
            star_store.insert(index, star)

    else:
        time.sleep(0.3)
        gui.update += 1
        gui.pl_update += 1
        star = [star[0], star[1].strip("L")]
        star_store.insert(index, star)
        try:
            lastfm.unlove(pctl.master_library[index].artist, pctl.master_library[index].title)
        except:
            print("Failed updating last.fm love status", 'warning')
            star = [star[0], star[1] + "L"]
            star_store.insert(index, star)

    gui.pl_update = 2




class LastScrob:

    def __init__(self):

        self.a_index = -1
        self.a_sc = False
        self.a_pt = False
        self.queue = []
        self.running = False

    def start_queue(self):

        self.running = True
        mini_t = threading.Thread(target=self.process_queue)
        mini_t.daemon = True
        mini_t.start()

    def process_queue(self):

        time.sleep(0.5)

        while self.queue:
            try:
                tr = self.queue.pop()

                gui.pl_update = 1
                print("Submit Scrobble " + tr[0].artist + " - " + tr[0].title)

                an = True

                if lastfm.connected or lastfm.details_ready():
                    an = lastfm.scrobble(tr[0], int(time.time()))

                if lb.enable:
                    an = lb.listen_full(tr[0], int(time.time()))

                if an is False:
                    print("Re-queue scrobble")
                    self.queue.append(tr)

                time.sleep(0.2)

            except:
                print("SCROBBLE QUEUE ERROR")
                # raise

        self.running = False


    def update(self, add_time):

        if pctl.queue_step > len(pctl.track_queue) - 1:
            print("Queue step error 1")
            return

        if self.a_index != pctl.track_queue[pctl.queue_step]:
            pctl.a_time = 0
            pctl.b_time = 0
            self.a_index = pctl.track_queue[pctl.queue_step]
            self.a_pt = False
            self.a_sc = False
        if pctl.playing_time == 0 and self.a_sc is True:
            print("Reset scrobble timer")
            pctl.a_time = 0
            pctl.b_time = 0
            self.a_pt = False
            self.a_sc = False



        if pctl.a_time > 6 and self.a_pt is False and pctl.master_library[self.a_index].length > 30:
            self.a_pt = True

            if lastfm.connected or lastfm.details_ready():
                mini_t = threading.Thread(target=lastfm.update, args=([pctl.master_library[self.a_index]]))
                mini_t.daemon = True
                mini_t.start()

            if lb.enable:
                mini_t = threading.Thread(target=lb.listen_playing, args=([pctl.master_library[self.a_index]]))
                mini_t.daemon = True
                mini_t.start()

        if pctl.a_time > 6 and self.a_pt:
            pctl.b_time += add_time
            if pctl.b_time > 20:
                pctl.b_time = 0
                if lastfm.connected or lastfm.details_ready():
                    mini_t = threading.Thread(target=lastfm.update, args=([pctl.master_library[self.a_index]]))
                    mini_t.daemon = True
                    mini_t.start()

                if lb.enable:
                    mini_t = threading.Thread(target=lb.listen_playing, args=([pctl.master_library[self.a_index]]))
                    mini_t.daemon = True
                    mini_t.start()

        if pctl.master_library[self.a_index].length > 30 and pctl.a_time > pctl.master_library[self.a_index].length \
                * 0.50 and self.a_sc is False:
            self.a_sc = True
            if lastfm.connected or lastfm.details_ready() or lb.enable:
                print("Queue Scrobble")
                self.queue.append([pctl.master_library[self.a_index]])


        if self.a_sc is False and pctl.master_library[self.a_index].length > 30 and pctl.a_time > 240:
            self.a_sc = True
            if lastfm.connected or lastfm.details_ready() or lb.enable:
                print("Queue Scrobble")
                self.queue.append([pctl.master_library[self.a_index]])


lfm_scrobbler = LastScrob()

class Tauon:

    def __init__(self):

        self.pctl = pctl
        self.lfm_scrobbler = lfm_scrobbler
        self.star_store = star_store
        self.gui = gui
        self.prefs = prefs

        self.worker_save_state = False

tauon = Tauon()

# Check if BASS is present and fall back to Gstreamer if not
if prefs.backend == 1 and not os.path.isfile(install_directory + '/lib/libbass.so'):
    if system != "windows":
        print("BASS not found")
        prefs.backend = 2

if prefs.backend == 2:
    from t_modules.t_gstreamer import player3

if prefs.backend == 1:
    from t_modules.t_bass import player



class PlexService:

    def __init__(self):
        self.connected = False
        self.resource = None
        self.scanning = False

    def connect(self):

        if not prefs.plex_username:
            show_message("PLEX Account - No username in config", 'warning', 'Enter details in config file then restart app to apply.')
            self.scanning = False
            return
        if not prefs.plex_password:
            show_message("PLEX Account - No password in config", 'warning', 'Enter details in config file then restart app to apply.')
            self.scanning = False
            return
        if not prefs.plex_servername:
            show_message("PLEX - No name of plex server in config", 'warning', 'Enter details in config file then restart app to apply.')
            self.scanning = False
            return

        try:
            from plexapi.myplex import MyPlexAccount
        except:
            show_message("Error importing python-plexapi", 'error')
            return

        try:
            account = MyPlexAccount(prefs.plex_username, prefs.plex_password)
            self.resource = account.resource(prefs.plex_servername).connect()  # returns a PlexServer instance
        except:
            show_message(_("Error connecting to PLEX server"), "error", "Try check login credentials and that server is accessible.")
            self.scanning = False
            return

        # from plexapi.server import PlexServer
        # baseurl = 'http://localhost:32400'
        # token = ''

        # self.resource = PlexServer(baseurl, token)

        self.connected = True

    def resolve_stream(self, location):

        if not self.connected:
            self.connect()

        #return self.resource.url(location, True)
        return self.resource.library.fetchItem(location).getStreamURL()

    def resolve_thumbnail(self, location):

        if not self.connected:
            self.connect()
        return self.resource.url(location, True)

    def get_albums(self):

        gui.update += 1

        if not self.connected:
            self.connect()

        if not self.connected:
            return

        global master_count

        playlist = []

        albums = self.resource.library.section('Music').albums()
        for album in albums:
            year = album.year
            album_artist = album.parentTitle
            album_title = album.title

            parent = (album_artist + " - " + album_title).strip("- ")

            for track in album.tracks():
                title = track.title
                track_artist = track.grandparentTitle
                duration = track.duration / 1000

                nt = TrackClass()
                nt.index = master_count
                nt.track_number = track.index
                nt.file_ext = "PLEX"
                nt.parent_folder_path = parent
                nt.parent_folder_name = parent
                nt.album_artist = album_artist
                nt.artist = track_artist
                nt.title = title
                nt.album = album_title
                nt.length = duration

                nt.is_network = True

                if track.thumb:
                    nt.art_url_key = track.thumb

                nt.url_key = track.key
                nt.date = str(year)

                pctl.master_library[master_count] = nt
                master_count += 1

                playlist.append(nt.index)

        self.scanning = False

        pctl.multi_playlist.append(pl_gen(title="PLEX Collection", playlist=playlist))
        switch_playlist(len(pctl.multi_playlist) - 1)


plex = PlexService()


def get_network_thumbnail_url(track_object):

    if track_object.file_ext == "PLEX":
        return plex.resolve_thumbnail(track_object.art_url_key)
    return None


def plex_get_album_thread():


    pref_box.enabled = False
    fader.fall()
    if plex.scanning:
        input.mouse_click = False
        show_message("Already scanning!")
        return
    plex.scanning = True


    shoot_dl = threading.Thread(target=plex.get_albums)
    shoot_dl.daemon = True
    shoot_dl.start()


if system == "windows":
    from infi.systray import SysTrayIcon

class STray:

    def __init__(self):

        self.active = False

    def up(self, systray):
        SDL_ShowWindow(t_window)
        SDL_RaiseWindow(t_window)
        SDL_RestoreWindow(t_window)

        gui.lowered = False

    def down(self):
        if self.active:
            SDL_HideWindow(t_window)

    def advance(self, systray):
        pctl.advance()

    def back(self, systray):
        pctl.back()

    def pause(self, systray):
         pctl.play_pause()

    def track_stop(self, systray):
         pctl.stop()

    def on_quit_callback(self, systray):
        pctl.running = False

    def start(self):
        menu_options = (("Show", None, self.up),
                        ("Play/Pause", None, self.pause),
                        ("Stop", None, self.track_stop),
                        ("Forward", None, self.advance),
                        ("Back", None, self.back))
        self.systray = SysTrayIcon(install_directory + asset_subfolder + "icon.ico", "Tauon Music Box", menu_options, on_quit=self.on_quit_callback)
        self.systray.start()
        self.active = True


    def stop(self):
        self.systray.shutdown()
        self.active = False


tray = STray()

if system == "windows":
    tray.start()


# ----------------------------------------------------------------------------------------------------
mediaKey = ''
mediaKey_pressed = False


class Gnome:

    def __init__(self):

        self.bus_object = None

    def focus(self):

        if self.bus_object is not None:

            # this is what gives us the multi media keys.
            dbus_interface = 'org.gnome.SettingsDaemon.MediaKeys'
            self.bus_object.GrabMediaPlayerKeys("TauonMusicBox", 0,
                                           dbus_interface=dbus_interface)

    def main(self):

        from gi.repository import GObject
        import dbus
        import dbus.service
        import dbus.mainloop.glib


        def on_mediakey(comes_from, what):

            global mediaKey
            global mediaKey_pressed

            if what == 'Play':
                mediaKey = 'Play'
                mediaKey_pressed = True
            elif what == 'Pause':
                mediaKey = 'Pause'
                mediaKey_pressed = True
            elif what == 'Stop':
                mediaKey = 'Stop'
                mediaKey_pressed = True
            elif what == 'Next':
                mediaKey = 'Next'
                mediaKey_pressed = True
            elif what == 'Previous':
                mediaKey = 'Previous'
                mediaKey_pressed = True

            elif what == 'Rewind':
                mediaKey = 'Rewind'
                mediaKey_pressed = True
            elif what == 'FastForward':
                mediaKey = 'FastForward'
                mediaKey_pressed = True
            elif what == 'Repeat':
                mediaKey = 'Repeat'
                mediaKey_pressed = True
            elif what == 'Shuffle':
                mediaKey = 'Shuffle'
                mediaKey_pressed = True

            if mediaKey_pressed:
                gui.update = 1

        # set up the glib main loop.
        dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

        if prefs.mkey:
            try:
                bus = dbus.Bus(dbus.Bus.TYPE_SESSION)
                bus_object = bus.get_object('org.gnome.SettingsDaemon.MediaKeys',
                                            '/org/gnome/SettingsDaemon/MediaKeys')

                self.bus_object = bus_object

                # this is what gives us the multi media keys.
                dbus_interface = 'org.gnome.SettingsDaemon.MediaKeys'
                bus_object.GrabMediaPlayerKeys("TauonMusicBox", 0,
                                               dbus_interface=dbus_interface)

                # connect_to_signal registers our callback function.
                bus_object.connect_to_signal('MediaPlayerKeyPressed',
                                             on_mediakey)
            except:
                print("Could not connect to gnome media keys")


        # ----------
        if prefs.enable_mpris:
            try:
                bus = dbus.Bus(dbus.Bus.TYPE_SESSION)
                bus_name = dbus.service.BusName('org.mpris.MediaPlayer2.tauon', bus)

                class MPRIS(dbus.service.Object):

                    def update(self, force=False):

                        changed = {}

                        if pctl.playing_state == 1:
                            if self.player_properties['PlaybackStatus'] != 'Playing':
                                self.player_properties['PlaybackStatus'] = 'Playing'
                                changed['PlaybackStatus'] = self.player_properties['PlaybackStatus']
                        elif pctl.playing_state == 0:
                            if self.player_properties['PlaybackStatus'] != 'Stopped':
                                self.player_properties['PlaybackStatus'] = 'Stopped'
                                changed['PlaybackStatus'] = self.player_properties['PlaybackStatus']
                        elif pctl.playing_state == 2:
                            if self.player_properties['PlaybackStatus'] != 'Paused':
                                self.player_properties['PlaybackStatus'] = 'Paused'
                                changed['PlaybackStatus'] = self.player_properties['PlaybackStatus']

                        if pctl.player_volume / 100 != self.player_properties['Volume']:
                            self.player_properties['Volume'] = pctl.player_volume / 100
                            changed['Volume'] = self.player_properties['Volume']

                        if pctl.playing_object() is not None and (pctl.playing_object().index != self.playing_index or force):
                            track = pctl.playing_object()
                            self.playing_index = track.index

                            d = {
                                'mpris:trackid': "/org/mpris/MediaPlayer2/TrackList/" + str(pctl.playlist_playing_position),
                                'mpris:length': dbus.Int64(int(pctl.playing_length * 1000000)),
                                'xesam:album': track.album,
                                'xesam:albumArtist': dbus.Array([track.album_artist]),
                                'xesam:artist': dbus.Array([track.artist]),
                                'xesam:title': track.title,
                                'xesam:url': "file://" + track.fullpath
                            }

                            try:
                                i_path = thumb_tracks.path(track)
                                if i_path is not None:
                                    d['mpris:artUrl'] = 'file://' + i_path
                            except:
                                print("Thumbnail error")

                            self.update_progress()

                            self.player_properties['Metadata'] = dbus.Dictionary(d, signature='sv')
                            changed['Metadata'] = self.player_properties['Metadata']

                        if len(changed) > 0:
                            self.PropertiesChanged('org.mpris.MediaPlayer2.Player', changed, [])

                    def update_progress(self):
                        self.player_properties['Position'] = dbus.Int64(int(pctl.playing_time * 1000000))

                    def __init__(self, object_path):
                        dbus.service.Object.__init__(self, bus, object_path)

                        self.playing_index = -1

                        self.root_properties = {
                            'CanQuit': True,
                            #'Fullscreen'
                            #'CanSetFullscreen'
                            'CanRaise': True,
                            'HasTrackList': False,
                            'Identity': t_title,
                            'DesktopEntry': t_id,
                            #'SupportedUriSchemes': ['file']
                            'SupportedUriSchemes': dbus.Array([dbus.String("file")]),
                            'SupportedMileTypes': dbus.Array([
                                 dbus.String("audio/mpeg"),
                                 dbus.String("audio/flac"),
                                 dbus.String("audio/ogg")
                                 ])
                        }

                        self.player_properties = {

                            'PlaybackStatus': 'Stopped',
                            #'LoopStatus'
                            'Rate': 1,
                            #'Shuffle':
                            'Volume': pctl.player_volume / 100,
                            'Position': 0,
                            'MinimumRate': 1,
                            'MaximumRate': 1,
                            'CanGoNext': True,
                            'CanGoPrevious': True,
                            'CanPlay': True,
                            'CanPause': True,
                            'CanSeek': True,
                            'CanControl': True

                        }

                        # self.update()

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2')
                    def Raise(self):
                        gui.request_raise = True

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2')
                    def Quit(self):
                        exit_func()

                    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                                    in_signature='ss', out_signature='v')
                    def Get(self, interface_name, property_name):
                        if interface_name == 'org.mpris.MediaPlayer2':
                            #return self.GetAll(interface_name)[property_name]
                            return self.root_properties[property_name]
                        elif interface_name == 'org.mpris.MediaPlayer2.Player':
                            return self.player_properties[property_name]

                    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                                    in_signature='s', out_signature='a{sv}')
                    def GetAll(self, interface_name):
                        #print(interface_name)
                        if interface_name == 'org.mpris.MediaPlayer2':
                            return self.root_properties
                        elif interface_name == 'org.mpris.MediaPlayer2.Player':
                            return self.player_properties
                        else:
                            return {}

                    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                                    in_signature='ssv', out_signature='')
                    def Set(self, interface_name, property_name, value):
                        if interface_name == 'org.mpris.MediaPlayer2.Player':
                            if property_name == "Volume":
                                pctl.player_volume = min(max(int(value * 100), 0), 100)
                                pctl.set_volume()
                        if interface_name == 'org.mpris.MediaPlayer2':
                            pass

                    @dbus.service.signal(dbus_interface=dbus.PROPERTIES_IFACE,
                                    signature='sa{sv}as')
                    def PropertiesChanged(self, interface_name, change, inval):
                        pass


                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def Next(self):
                        pctl.advance()
                        pass

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def Previous(self):
                        pctl.back()
                        pass

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def Pause(self):
                        pctl.pause_only()
                        pass

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def PlayPause(self):
                        pctl.play_pause()

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def Stop(self):
                        pctl.stop()

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def Play(self):
                        pctl.play()

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def Seek(self, offset):
                        pctl.seek_time(pctl.playing_time + (offset / 1000000))

                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def SetPosition(self, id, position):
                        pctl.seek_time(position / 1000000)
                        #self.update_progress()
                        self.player_properties['Position'] = dbus.Int64(int(position))
                        self.Seeked(pctl.playing_time)


                    @dbus.service.method(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def OpenUri(self, uri):
                        pass

                    @dbus.service.signal(dbus_interface='org.mpris.MediaPlayer2.Player')
                    def Seeked(self, position):
                        pass

                    def seek_do(self, seconds):
                        self.Seeked(dbus.Int64(int(seconds * 1000000)))

                pctl.mpris = MPRIS("/org/mpris/MediaPlayer2")
            except:
                print("MPRIS2 CONNECT FAILED")

        mainloop = GLib.MainLoop()
        mainloop.run()


gnome = Gnome()

if system == "linux":
    try:

        gnomeThread = threading.Thread(target=gnome.main)
        gnomeThread.daemon = True
        gnomeThread.start()

    except:
        print("ERROR: Could not start Dbus thread")

if system == "windows":
    def keyboard_hook():
        from collections import namedtuple

        KeyboardEvent = namedtuple('KeyboardEvent', ['event_type', 'key_code',
                                                     'scan_code', 'alt_pressed',
                                                     'time'])

        handlers = []

        def listen():
            # Adapted from http://www.hackerthreads.org/Topic-42395

            event_types = {win32con.WM_KEYDOWN: 'key down',
                           win32con.WM_KEYUP: 'key up',
                           0x104: 'key down',  # WM_SYSKEYDOWN, used for Alt key.
                           0x105: 'key up',  # WM_SYSKEYUP, used for Alt key.
                           }

            def low_level_handler(nCode, wParam, lParam):
                global mediaKey
                global mediaKey_pressed

                event = KeyboardEvent(event_types[wParam], lParam[0], lParam[1],
                                      lParam[2] == 32, lParam[3])

                if event[1] == 179 and event[0] == 'key down':
                    mediaKey = 'play'
                    mediaKey_pressed = True
                elif event[1] == 178 and event[0] == 'key down':
                    mediaKey = 'stop'
                    mediaKey_pressed = True
                elif event[1] == 177 and event[0] == 'key down':
                    mediaKey = 'back'
                    mediaKey_pressed = True
                elif event[1] == 176 and event[0] == 'key down':
                    mediaKey = 'forward'
                    mediaKey_pressed = True
                if mediaKey_pressed:
                    gui.update += 1
                # Be a good neighbor and call the next hook.
                return windll.user32.CallNextHookEx(hook_id, nCode, wParam, lParam)

            # Our low level handler signature.
            CMPFUNC = CFUNCTYPE(c_int, c_int, c_int, POINTER(c_void_p))
            # Convert the Python handler into C pointer.
            pointer = CMPFUNC(low_level_handler)

            # Hook both key up and key down events for common keys (non-system).
            hook_id = windll.user32.SetWindowsHookExA(win32con.WH_KEYBOARD_LL, pointer,
                                                      win32api.GetModuleHandle(None), 0)

            # Register to remove the hook when the interpreter exits. Unfortunately a
            # try/finally block doesn't seem to work here.
            atexit.register(windll.user32.UnhookWindowsHookEx, hook_id)

            while True:
                msg = win32gui.GetMessage(None, 0, 0)
                win32gui.TranslateMessage(byref(msg))
                win32gui.DispatchMessage(byref(msg))
                time.sleep(5)

        listen()



if system == 'windows':
    print('Starting hook thread for Windows')
    keyboardHookThread = threading.Thread(target=keyboard_hook)
    keyboardHookThread.daemon = True
    keyboardHookThread.start()

class GStats:
    def __init__(self):

        self.last_db = 0
        self.last_pl = 0
        self.artist_list = []
        self.album_list = []
        self.genre_list = []
        self.genre_dict = {}

    def update(self, playlist):

        pt = 0

        if master_count != self.last_db or self.last_pl != playlist:
            self.last_db = master_count
            self.last_pl = playlist

            artists = {}

            for index in pctl.multi_playlist[playlist][2]:
                artist = pctl.master_library[index].artist

                if artist == "":
                    artist = "<Artist Unspecified>"

                pt = int(star_store.get(index))
                if pt < 30:
                    continue

                if artist in artists:
                    artists[artist] += pt
                else:
                    artists[artist] = pt

            art_list = artists.items()

            sorted_list = sorted(art_list, key=lambda x: x[1], reverse=True)

            self.artist_list = copy.deepcopy(sorted_list)

            genres = {}
            genre_dict = {}

            for index in pctl.multi_playlist[playlist][2]:
                genre_r = pctl.master_library[index].genre

                pt = int(star_store.get(index))

                gn = []
                if ',' in genre_r:
                    for g in genre_r.split(","):
                        g = g.rstrip(" ").lstrip(" ")
                        if len(g) > 0:
                            gn.append(g)
                elif ';' in genre_r:
                    for g in genre_r.split(";"):
                        g = g.rstrip(" ").lstrip(" ")
                        if len(g) > 0:
                            gn.append(g)
                elif '/' in genre_r:
                    for g in genre_r.split("/"):
                        g = g.rstrip(" ").lstrip(" ")
                        if len(g) > 0:
                            gn.append(g)
                elif ' & ' in genre_r:
                    for g in genre_r.split(" & "):
                        g = g.rstrip(" ").lstrip(" ")
                        if len(g) > 0:
                            gn.append(g)
                else:
                    gn = [genre_r]

                pt = int(pt / len(gn))

                for genre in gn:

                    if genre.lower() in {"", 'other', 'unknown', 'misc'}:
                        genre = "<Genre Unspecified>"
                    if genre.lower() in {'jpop', 'japanese pop'}:
                        genre = 'J-Pop'
                    if genre.lower() in {'jrock', 'japanese rock'}:
                        genre = 'J-Rock'
                    if genre.lower() in {'alternative music', 'alt-rock', 'alternative', 'alternrock', 'alt'}:
                        genre = 'Alternative Rock'
                    if genre.lower() in {'jpunk', 'japanese punk'}:
                        genre = 'J-Punk'
                    if genre.lower() in {'post rock', 'post-rock'}:
                        genre = 'Post-Rock'
                    if genre.lower() in {'video game', 'game', 'game music', 'video game music', 'game ost'}:
                        genre = "Video Game Soundtrack"
                    if genre.lower() in {'general soundtrack', 'ost', 'Soundtracks'}:
                        genre = "Soundtrack"
                    if genre.lower() in ('anime', 'ã¢ãã¡', 'anime ost'):
                        genre = 'Anime Soundtrack'
                    if genre.lower() in {'åäºº'}:
                        genre = 'Doujin'
                    if genre.lower() in {'chill, chill out', 'chill-out'}:
                        genre = 'Chillout'

                    genre = genre.title()

                    if len(genre) == 3 and genre[2] == 'm':
                        genre = genre.upper()

                    if genre in genres:

                        genres[genre] += pt
                    else:
                        genres[genre] = pt

                    if genre in genre_dict:
                        genre_dict[genre].append(index)
                    else:
                        genre_dict[genre] = [index]

            art_list = genres.items()
            sorted_list = sorted(art_list, key=lambda x: x[1], reverse=True)

            self.genre_list = copy.deepcopy(sorted_list)
            self.genre_dict = genre_dict

            # print('\n-----------------------\n')

            g_albums = {}

            for index in pctl.multi_playlist[playlist][2]:
                album = pctl.master_library[index].album

                if album == "":
                    album = "<Album Unspecified>"

                pt = int(star_store.get(index))

                if pt < 30:
                    continue

                if album in g_albums:
                    g_albums[album] += pt
                else:
                    g_albums[album] = pt

            art_list = g_albums.items()

            sorted_list = sorted(art_list, key=lambda x: x[1], reverse=True)

            self.album_list = copy.deepcopy(sorted_list)


stats_gen = GStats()


def draw_window_tools():

    global mouse_down
    global drag_mode

    # off_icon_colour = [120, 120, 120, 45]
    off_icon_colour = [50, 50, 50, 200]

    if colours.lm:
        off_icon_colour = [180, 180, 180, 200]

    rect = (window_size[0] - 55 * gui.scale, window_size[1] - 35 * gui.scale, 53 * gui.scale, 33 * gui.scale)
    fields.add(rect)

    if gui.mode == 3:

        rect = (window_size[0] - 96 * gui.scale, 1 * gui.scale, 30 * gui.scale, 28 * gui.scale)
        ddt.rect_a((rect[0], rect[1]), (rect[2] + 1 * gui.scale, rect[3]), colours.window_buttons_bg, True)
        fields.add(rect)
        if coll(rect):
            ddt.rect_a((rect[0], rect[1]), (rect[2] + 1 * gui.scale, rect[3]), [70, 70, 70, 100], True)
            top_panel.restore_button.render(rect[0] + 8 * gui.scale, rect[1] + 9 * gui.scale, [160, 160, 160, 160])
            if (input.mouse_click or ab_click) and coll_point(click_location, rect):

                restore_full_mode()
                gui.update += 2

        else:
            top_panel.restore_button.render(rect[0] + 8 * gui.scale, rect[1] + 9 * gui.scale, off_icon_colour)


    rect = (window_size[0] - 65 * gui.scale, 1 * gui.scale, 35 * gui.scale, 28 * gui.scale)
    ddt.rect_a((rect[0], rect[1]), (rect[2] + 1 * gui.scale, rect[3]), colours.window_buttons_bg, True)
    fields.add(rect)
    if coll(rect):
        ddt.rect_a((rect[0], rect[1]), (rect[2] + 1 * gui.scale, rect[3]), [70, 70, 70, 100], True)
        ddt.rect_a((rect[0] + 11 * gui.scale, rect[1] + 16 * gui.scale), (14 * gui.scale, 3 * gui.scale),
                   [160, 160, 160, 160], True)
        if (mouse_up or ab_click) and coll_point(click_location, rect):

            if tray.active and prefs.min_to_tray:
                tray.down()
            else:
                SDL_MinimizeWindow(t_window)

            mouse_down = False
            input.mouse_click = False
            drag_mode = False
    else:
        ddt.rect_a((rect[0] + 11 * gui.scale, rect[1] + 16 * gui.scale), (14 * gui.scale, 3 * gui.scale),
                   off_icon_colour, True)

    rect = (window_size[0] - 29 * gui.scale, 1 * gui.scale, 26 * gui.scale, 28 * gui.scale)
    ddt.rect_a((rect[0], rect[1]), (rect[2] + 1, rect[3]), colours.window_buttons_bg, True)
    fields.add(rect)
    if coll(rect):
        ddt.rect_a((rect[0], rect[1]), (rect[2] + 1 * gui.scale, rect[3]), colours.window_buttons_bg_over, True)
        top_panel.exit_button.render(rect[0] + 8 * gui.scale, rect[1] + 8 * gui.scale, colours.artist_playing)
        #top_panel.exit_button.render(rect[0] + 8 * gui.scale, rect[1] + 8 * gui.scale, colours.artist_playing)
        if input.mouse_click or ab_click:
            pctl.running = False
    else:
        top_panel.exit_button.render(rect[0] + 8 * gui.scale, rect[1] + 8 * gui.scale, off_icon_colour)





    if not fullscreen and not gui.maximized and not gui.mode == 3:
        corner_icon.render(window_size[0] - corner_icon.w, window_size[1] - corner_icon.h, [40, 40, 40, 255])

        colour = [30, 30, 30, 255]
        ddt.rect_r((0, 0, window_size[0], 1 * gui.scale), colour, True)
        ddt.rect_r((0, 0, 1 * gui.scale, window_size[1]), colour, True)
        ddt.rect_r((0, window_size[1] - 1 * gui.scale, window_size[0], 1 * gui.scale), colour, True)
        ddt.rect_r((window_size[0] - 1 * gui.scale, 0, 1 * gui.scale, window_size[1]), colour, True)

# -------------------------------------------------------------------------------------------
# initiate SDL2 --------------------------------------------------------------------C-IS-----

SDL_SetHint(SDL_HINT_VIDEO_ALLOW_SCREENSAVER, b'1')

print("Starting SDL...")

SDL_Init(SDL_INIT_VIDEO)

#TTF_Init()

window_title = t_title
window_title = window_title.encode('utf-8')


cursor_hand = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND)
cursor_standard = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_ARROW)
cursor_shift = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_SIZEWE)
cursor_text = SDL_CreateSystemCursor(SDL_SYSTEM_CURSOR_IBEAM)

flags = SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE

if draw_border:
    flags = SDL_WINDOW_BORDERLESS | SDL_WINDOW_RESIZABLE

print("Creating window...")

t_window = SDL_CreateWindow(window_title,
                            SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
                            window_size[0], window_size[1],
                            flags)

if gui.maximized:
    SDL_MaximizeWindow(t_window)

# t_window = SDL_CreateShapedWindow(window_title,
#                              SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
#                              window_size[0], window_size[1],
#                              flags)

# print(SDL_GetError())

if system == 'windows':
    sss = SDL_SysWMinfo()
    SDL_GetWindowWMInfo(t_window, sss)
    gui.window_id = sss.info.win.window


try:
    SDL_SetHint(SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH, b"1")
except:
    print("old version of SDL detected")

# get window surface and set up renderer
#renderer = SDL_CreateRenderer(t_window, 0, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC)

print("Setting up renderer...")

renderer = SDL_CreateRenderer(t_window, 0, SDL_RENDERER_ACCELERATED)

# window_surface = SDL_GetWindowSurface(t_window)

SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND)

print("Configure window...")

display_index = SDL_GetWindowDisplayIndex(t_window)
display_bounds = SDL_Rect(0, 0)
SDL_GetDisplayBounds(display_index, display_bounds)

icon = IMG_Load(b_active_directory + asset_subfolder.encode() + b"icon-64.png")
SDL_SetWindowIcon(t_window, icon)
SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "best".encode())

SDL_SetWindowMinimumSize(t_window, 560, 330)

gui.max_window_tex = 1000
if window_size[0] > gui.max_window_tex or window_size[1] > gui.max_window_tex:

    while window_size[0] > gui.max_window_tex:
        gui.max_window_tex += 1000
    while window_size[1] > gui.max_window_tex:
        gui.max_window_tex += 1000

print("Create base textures...")

gui.ttext = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.max_window_tex, gui.max_window_tex)

# gui.pl_surf = SDL_CreateRGBSurfaceWithFormat(0, gui.max_window_tex, gui.max_window_tex, 32, SDL_PIXELFORMAT_RGB888)

SDL_SetTextureBlendMode(gui.ttext, SDL_BLENDMODE_BLEND)

gui.spec2_tex = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.spec2_w, gui.spec2_y)
gui.spec1_tex = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.spec_w, gui.spec_h)
gui.spec4_tex = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.spec4_w, gui.spec4_h)
gui.spec_level_tex = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.level_ww, gui.level_hh)

SDL_SetTextureBlendMode(gui.spec4_tex, SDL_BLENDMODE_BLEND)

SDL_SetRenderTarget(renderer, None)

gui.main_texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.max_window_tex, gui.max_window_tex)
gui.main_texture_overlay_temp = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.max_window_tex, gui.max_window_tex)

SDL_SetRenderTarget(renderer, gui.main_texture)
SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255)

SDL_SetRenderTarget(renderer, gui.main_texture_overlay_temp)
SDL_SetTextureBlendMode(gui.main_texture_overlay_temp, SDL_BLENDMODE_BLEND)
SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255)

SDL_RenderClear(renderer)

gui.abc = SDL_Rect(0, 0, gui.max_window_tex, gui.max_window_tex)
gui.pl_update = 2

SDL_SetWindowOpacity(t_window, prefs.window_opacity)

def bass_player_thread(player):

    logging.basicConfig(filename=user_directory + '/crash.log', level=logging.ERROR,
                        format='%(asctime)s %(levelname)s %(name)s %(message)s')

    try:
        player(pctl, gui, prefs, lfm_scrobbler, star_store)
    except:
        logging.exception('Exception on player thread')
        show_message("Playback thread has crashed. Sorry about that.", 'error', "App will need to re restarted.")
        time.sleep(1)
        show_message("Playback thread has crashed. Sorry about that.", 'error', "App will need to re restarted.")
        time.sleep(1)
        show_message("Playback thread has crashed. Sorry about that.", 'error', "App will need to re restarted.")

if prefs.backend == 1:

    playerThread = threading.Thread(target=bass_player_thread, args=[player])
    playerThread.daemon = True
    playerThread.start()

elif prefs.backend == 2:

    playerThread = threading.Thread(target=player3, args=[tauon])
    playerThread.daemon = True
    playerThread.start()


if system == 'windows' and taskbar_progress:

    class WinTask:

        def __init__(self, ):
            self.start = time.time()
            self.updated_state = 0
            self.window_id = gui.window_id
            import comtypes.client as cc
            cc.GetModule("TaskbarLib.tlb")
            import comtypes.gen.TaskbarLib as tbl
            self.taskbar = cc.CreateObject(
                "{56FDF344-FD6D-11d0-958A-006097C9A090}",
                interface=tbl.ITaskbarList3)
            self.taskbar.HrInit()

            self.d_timer = Timer()

        def update(self, force=False):
            if self.d_timer.get() > 2 or force:
                self.d_timer.set()

                if pctl.playing_state == 1 and self.updated_state != 1:
                    self.taskbar.SetProgressState(self.window_id, 0x2)

                if pctl.playing_state == 1:
                    self.updated_state = 1
                    if pctl.playing_length > 2:
                        perc = int(pctl.playing_time * 100 / int(pctl.playing_length))
                        if perc < 2:
                            perc = 1
                        elif perc > 100:
                            prec = 100
                    else:
                        perc = 0

                    self.taskbar.SetProgressValue(self.window_id, perc, 100)

                elif pctl.playing_state == 2 and self.updated_state != 2:
                    self.updated_state = 2
                    self.taskbar.SetProgressState(self.window_id, 0x8)

                elif pctl.playing_state == 0 and self.updated_state != 0:
                    self.updated_state = 0
                    self.taskbar.SetProgressState(self.window_id, 0x2)
                    self.taskbar.SetProgressValue(self.window_id, 0, 100)


    if os.path.isfile("TaskbarLib.tlb"):
        print("Taskbar progress enabled")
        pctl.windows_progress = WinTask()

    else:
        pctl.taskbar_progress = False
        print("Could not find TaskbarLib.tlb")

# ---------------------------------------------------------------------------------------------
# ABSTRACT SDL DRAWING FUNCTIONS -----------------------------------------------------


def coll_point(l, r):
    # rect point collision detection
    return r[0] <= l[0] <= r[0] + r[2] and r[1] <= l[1] <= r[1] + r[3]

def coll(r):
    return r[0] <= mouse_position[0] <= r[0] + r[2] and r[1] <= mouse_position[1] <= r[1] + r[3]

from t_modules.t_draw import TDraw

ddt = TDraw(renderer)
ddt.scale = gui.scale

class Drawing:

    def button(self, text, x, y, w=None, h=None, font=212, fore_text=None, back_text=None, bg=None, fg=None, press=None, tooltip=""):

        if w is None:
            w = ddt.get_text_w(text, font) + 18 * gui.scale
        if h is None:
            h = 22 * gui.scale

        rect = (x, y, w, h)
        fields.add(rect)

        if fore_text is None:
            fore_text = colours.grey(240)
        if back_text is None:
            back_text = colours.grey(220)
        if bg is None:
            bg = alpha_blend([255, 255, 255, 9], colours.sys_background_3)
        if fg is None:
            fg = alpha_blend([255, 255, 255, 20], colours.sys_background_3)

        click = False

        if press is None:
            press = input.mouse_click

        if coll(rect):
            if tooltip:
                tool_tip.test(x + 15 * gui.scale, y - 28 * gui.scale, tooltip)
            ddt.rect_r(rect, fg, True)
            ddt.draw_text((rect[0] + int(rect[2] / 2), rect[1] + 2 * gui.scale, 2), text, fore_text, font,
                      bg=fg)
            if press:
                click = True
        else:
            ddt.rect_r(rect, bg, True)
            ddt.draw_text((rect[0] + int(rect[2] / 2), rect[1] + 2 * gui.scale, 2), text, back_text, font,
                      bg=bg)
        return click


print("Scanning fonts...")

draw = Drawing()

if system == "linux":
    standard_font = prefs.linux_font
    ddt.prime_font(standard_font, 8, 9)
    ddt.prime_font(standard_font, 8, 10)
    ddt.prime_font(standard_font, 8.5, 11)
    ddt.prime_font(standard_font, 8.7, 11.5)
    ddt.prime_font(standard_font, 9, 12)
    ddt.prime_font(standard_font, 10, 13)
    ddt.prime_font(standard_font, 10, 14)
    ddt.prime_font(standard_font, 10.2, 14.5)
    ddt.prime_font(standard_font, 11, 15)
    ddt.prime_font(standard_font, 12, 16)
    ddt.prime_font(standard_font, 12, 17)
    ddt.prime_font(standard_font, 12, 18)
    ddt.prime_font(standard_font, 24, 30)

    ddt.prime_font(standard_font, 9, 412)
    ddt.prime_font(standard_font, 10, 413)

    standard_font = prefs.linux_font_semibold
    ddt.prime_font(standard_font, 8, 309)
    ddt.prime_font(standard_font, 8, 310)
    ddt.prime_font(standard_font, 8.5, 311)
    ddt.prime_font(standard_font, 9, 312)
    ddt.prime_font(standard_font, 10, 313)
    ddt.prime_font(standard_font, 10.5, 314)
    ddt.prime_font(standard_font, 11, 315)
    ddt.prime_font(standard_font, 12, 316)
    ddt.prime_font(standard_font, 12, 317)
    ddt.prime_font(standard_font, 12, 318)
    ddt.prime_font(standard_font, 24, 330)


    standard_font = prefs.linux_font_bold

    ddt.prime_font(standard_font, 6, 209)
    ddt.prime_font(standard_font, 7, 210)
    ddt.prime_font(standard_font, 8, 211)
    ddt.prime_font(standard_font, 9, 212)
    ddt.prime_font(standard_font, 10, 213)
    ddt.prime_font(standard_font, 11, 214)
    ddt.prime_font(standard_font, 12, 215)
    ddt.prime_font(standard_font, 13, 216)
    ddt.prime_font(standard_font, 14, 217)
    ddt.prime_font(standard_font, 17, 218)
    ddt.prime_font(standard_font, 19, 219)
    ddt.prime_font(standard_font, 25, 228)


else:
    standard_font = "Meiryo"
    standard_font = "Arial"
    semibold_font = "Meiryo Semibold"
    semibold_font = "Arial Bold"
    standard_weight = 500
    bold_weight = 600
    ddt.win_prime_font(standard_font, 14, 10, weight=standard_weight, y_offset=0)
    ddt.win_prime_font(standard_font, 15, 11, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 15, 11.5, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 15, 12, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 15, 13, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 16, 14, weight=standard_weight, y_offset=0)
    ddt.win_prime_font(standard_font, 16, 14.5, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 17, 15, weight=standard_weight, y_offset=-1)
    ddt.win_prime_font(standard_font, 20, 16, weight=standard_weight, y_offset=-2)
    ddt.win_prime_font(standard_font, 20, 17, weight=standard_weight, y_offset=-1)

    ddt.win_prime_font(standard_font, 30 + 4, 30, weight=standard_weight, y_offset=-12)
    ddt.win_prime_font(semibold_font, 9, 209, weight=bold_weight, y_offset=1)
    ddt.win_prime_font('Arial', 10 + 4, 210, weight=600, y_offset=2)
    ddt.win_prime_font('Arial', 11 + 3, 211, weight=600, y_offset=2)
    ddt.win_prime_font(semibold_font, 12 + 4, 212, weight=bold_weight, y_offset=1)
    ddt.win_prime_font(semibold_font, 13 + 3, 213, weight=bold_weight, y_offset=-1)
    ddt.win_prime_font(semibold_font, 14 + 2, 214, weight=bold_weight, y_offset=1)
    ddt.win_prime_font(semibold_font, 15 + 2, 215, weight=bold_weight, y_offset=1)
    ddt.win_prime_font(semibold_font, 16 + 2, 216, weight=bold_weight, y_offset=1)
    ddt.win_prime_font(semibold_font, 28 + 2, 228, weight=bold_weight, y_offset=1)

    if gui.scale == 1:
        ddt.win_prime_font("Arial", 14 + 1, 412, weight=500, y_offset=1)
        ddt.win_prime_font("Arial", 15 + 1, 413, weight=500, y_offset=1)
    else:
        ddt.win_prime_font("Arial", 14 + 1, 412, weight=500, y_offset=2)
        ddt.win_prime_font("Arial", 15 + 1, 413, weight=500, y_offset=2)

    standard_weight = 550
    ddt.win_prime_font(standard_font, 14, 310, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 15, 311, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 16, 312, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 17, 313, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 18, 314, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 19, 315, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 20, 316, weight=standard_weight, y_offset=1)
    ddt.win_prime_font(standard_font, 21, 317, weight=standard_weight, y_offset=1)

class DropShadow:

    def __init__(self):

        self.readys = {}
        self.underscan = int(15 * gui.scale)
        self.radius = 4
        self.grow = 2 * gui.scale
        self.opacity = 90

    def prepare(self, w, h):

        fh = h + self.underscan
        fw = w + self.underscan

        im = Image.new("RGBA", (round(fw), round(fh)), 0x00000000)
        draw = ImageDraw.Draw(im)
        draw.rectangle(((self.underscan, self.underscan), (w + 2, h + 2)), fill="black")

        im = im.filter(ImageFilter.GaussianBlur(self.radius))

        g = io.BytesIO()
        g.seek(0)
        im.save(g, 'PNG')
        g.seek(0)

        wop = rw_from_object(g)
        s_image = IMG_Load_RW(wop, 0)
        c = SDL_CreateTextureFromSurface(renderer, s_image)
        SDL_SetTextureAlphaMod(c, self.opacity)

        tex_w = pointer(c_int(0))
        tex_h = pointer(c_int(0))
        SDL_QueryTexture(c, None, None, tex_w, tex_h)

        dst = SDL_Rect(0, 0)
        dst.w = int(tex_w.contents.value)
        dst.h = int(tex_h.contents.value)

        SDL_FreeSurface(s_image)
        g.close()
        im.close()

        unit = (dst, c)
        self.readys[(w, h)] = unit

    def render(self, x, y, w, h):

        if (w, h) not in self.readys:
            self.prepare(w, h)

        unit = self.readys[(w, h)]
        unit[0].x = round(x) - round(self.underscan)
        unit[0].y = round(y) - round(self.underscan)
        SDL_RenderCopy(renderer, unit[1], None, unit[0])


drop_shadow = DropShadow()


class LyricsRenMini:

    def __init__(self):

        self.index = -1
        self.text = ""


        self.lyrics_position = 0

    def generate(self, index, w):

        self.text = pctl.master_library[index].lyrics
        self.lyrics_position = 0

    def render(self, index, x, y, w, h, p):


        if not prefs.show_side_art:  # Hacky tweak
            y += 5 * gui.scale

        if index != self.index or self.text != pctl.master_library[index].lyrics:
            self.index = index
            self.generate(index, w)

        colour = colours.side_bar_line1


        ddt.draw_text((x, y, 4, w), self.text, colour, 15, w - (w % 2), colours.side_panel_background)


lyrics_ren_mini = LyricsRenMini()

class LyricsRen:

    def __init__(self):

        self.index = -1
        self.text = ""

        self.lyrics_position = 0

    def generate(self, index, w):

        self.text = pctl.master_library[index].lyrics
        self.lyrics_position = 0

    def render(self, index, x, y, w, h, p):

        if index != self.index or self.text != pctl.master_library[index].lyrics:
            self.index = index
            self.generate(index, w)

        colour = colours.lyrics
        if test_lumi(colours.gallery_background) < 0.5:
            colour = colours.grey(40)

        ddt.draw_text((x, y, 4, w), self.text, colour, 17, w, colours.playlist_panel_background)


lyrics_ren = LyricsRen()



class TimedLyricsRen:

    def __init__(self):

        self.index = -1

        self.scanned = {}
        self.ready = False
        self.data = []

        self.scroll_position = 0


    def generate(self, index):

        if self.index == index:
            return self.ready

        self.ready = False
        self.index = index
        self.data = []
        self.scroll_position = 0

        if pctl.master_library[index].is_network:
            return False

        track = pctl.master_library[index]
        direc = track.parent_folder_path
        name = track.filename.split(".")[0] + ".lrc"

        for file in os.listdir(direc):
            if file == name:
                f = open(os.path.join(direc, name), 'r')
                data = f.readlines()
                f.close()

                break
        else:
            return False

        for line in data:
            if len(line) < 9:
                continue

            #print(line)
            if line[0] != "[" or line[9] != "]" or ":" not in line or "." not in line:
                continue

            es = 0
            s = 0
            try:

                text = line.split("]")[-1].rstrip("\n")
                t = line

                while t[0] == "[" and t[9] == "]" and ":" in t and "." in t:

                    a = t.lstrip("[")
                    t = t.split("]")[1] + "]"

                    a = a.split("]")[0]
                    mm, b = a.split(":")
                    ss, ms = b.split(".")

                    s = int(mm) * 60 + int(ss) + int(ms) / 100
                    self.data.append((s, text))

                    if len(t) < 10:
                        break
            except:
                continue

        self.data = sorted(self.data, key=lambda x: x[0])
        # print(self.data)

        self.ready = True
        return True


    def render(self, index, x, y):

        if index != self.index:
            #self.index = index
            self.ready = False
            self.generate(index)

        if not self.ready:
            return False


        if pctl.playing_state != 1 or pctl.track_queue[pctl.queue_step] != index:
            self.scroll_position += int(mouse_wheel * 30 * gui.scale)



        line_active = -1
        last = -1

        highlight = True

        test_time = max(0, pctl.playing_time - (prefs.sync_lyrics_time_offset / 1000))

        if pctl.track_queue[pctl.queue_step] == index:

            for i, line in (enumerate(self.data)):
                if line[0] < test_time:

                    last = i

                if line[0] > pctl.playing_time:
                    line_active = last
                    if not gui.frame_callback_list:
                        gui.frame_callback_list.append(TestTimer(line[0] - test_time + 0.001))

                    break
            else:
                line_active = len(self.data) - 1


            if pctl.playing_state == 1:
                self.scroll_position = (max(0, line_active)) * 23 * gui.scale * -1

        yy = y + self.scroll_position

        for i, line in enumerate(self.data):

            if 0 < yy < window_size[1]:

                colour = colours.lyrics
                if test_lumi(colours.gallery_background) < 0.5:
                    colour = colours.grey(40)

                if i == line_active and highlight:
                    colour = [255, 210, 50, 255]
                    if colours.lm:
                        colour = [180, 130, 210, 255]


                ddt.draw_text((x, yy), line[1], colour, 17, 2000, colours.playlist_panel_background)

            yy += 23 * gui.scale




timed_lyrics_ren = TimedLyricsRen()



def draw_internel_link(x, y, text, colour, font):

    tweak = font
    while tweak > 100:
        tweak -= 100

    if gui.scale == 2:
        tweak *= 2
        tweak += 4
    if gui.scale == 1.25:
        tweak = round(tweak * 1.25)
        tweak += 1

    sp = ddt.draw_text((x, y), text, colour, font)

    rect = [x - 5 * gui.scale, y - 2 * gui.scale, sp + 11 * gui.scale, 23 * gui.scale]
    fields.add(rect)

    if coll(rect):
        if not input.mouse_click:
            gui.cursor_want = 3
        ddt.line(x, y + tweak + 2, x + sp, y + tweak + 2, alpha_mod(colour, 180))
        if input.mouse_click:
            return True
    return False




# No hit detect
def draw_linked_text(location, text, colour, font):
    base = ""
    link_text = ""
    rest = ""
    on_base = True
    for i in range(len(text)):
        if text[i:i + 7] == "http://" or text[i:i + 4] == "www." or text[i:i + 8] == "https://":
            on_base = False
        if on_base:
            base += text[i]
        else:
            if i == len(text) or text[i] in '\\) "\'':
                rest = text[i:]
                break
            else:
                link_text += text[i]

    left = ddt.get_text_w(base, font)
    right = ddt.get_text_w(base + link_text, font)

    x = location[0]
    y = location[1]

    ddt.draw_text((x, y), base, colour, font)
    ddt.draw_text((x + left, y), link_text, colours.link_text, font)
    ddt.draw_text((x + right, y), rest, colour, font)

    tweak = font
    while tweak > 100:
        tweak -= 100

    if gui.scale == 2:
        tweak *= 2
        tweak += 4
    if gui.scale == 1.25:
        tweak = round(tweak * 1.25)
        tweak += 1

    if system == "windows":
        tweak += 1

    ddt.line(x + left, y + tweak + 2, x + right, y + tweak + 2, alpha_mod(colours.link_text, 120))

    return left, right - left, link_text


def link_activate(x, y, link_pa):

    link_rect = [x + link_pa[0], y - 2 * gui.scale, link_pa[1], 20 * gui.scale]

    fields.add(link_rect)
    if coll(link_rect):
        if not input.mouse_click:
            gui.cursor_want = 3
        if input.mouse_click:
            webbrowser.open(link_pa[2], new=2, autoraise=True)
            track_box = True


class TextBox:

    cursor = True

    def __init__(self):

        self.text = ""
        self.cursor_position = 0
        self.selection = 0
        self.down_lock = False

    def paste(self):

        if SDL_HasClipboardText():
            clip = SDL_GetClipboardText().decode('utf-8')

            if 'http://' in self.text and 'http://' in clip:
                self.text = ""

            clip = clip.rstrip(" ").lstrip(" ")
            clip = clip.replace('\n', ' ').replace('\r', '')

            self.eliminate_selection()
            self.text = self.text[0: len(self.text) - self.cursor_position] + clip + self.text[len(
                self.text) - self.cursor_position:]

    def copy(self):

        text = self.get_selection()
        if text != "":
            SDL_SetClipboardText(text.encode('utf-8'))

    def set_text(self, text):

        self.text = text
        self.cursor_position = 0
        self.selection = 0

    def clear(self):
        self.text = ""

    def highlight_all(self):

        self.selection = len(self.text)
        self.cursor_position = 0

    def eliminate_selection(self):
        if self.selection != self.cursor_position:
            if self.selection > self.cursor_position:
                self.text = self.text[0: len(self.text) - self.selection] + self.text[len(self.text) - self.cursor_position:]
                self.selection = self.cursor_position
            else:
                self.text = self.text[0: len(self.text) -  self.cursor_position] + self.text[len(self.text) - self.selection:]
                self.cursor_position = self.selection

    def get_selection(self, p=1):
        if self.selection != self.cursor_position:
            if p == 1:
                if self.selection > self.cursor_position:
                    return self.text[len(self.text) - self.selection : len(self.text) - self.cursor_position]

                else:
                    return self.text[len(self.text) -  self.cursor_position: len(self.text) - self.selection]
            if p == 0:
                return self.text[0: len(self.text) - max(self.cursor_position, self.selection)]
            if p == 2:
                return self.text[len(self.text) - min(self.cursor_position, self.selection):]

        else:
            return ""

    def draw(self, x, y, colour, active=True, secret=False, font=13, width=0, click=False, selection_height=18, big=False):

        # A little bit messy.
        # For now, this is set up so where 'width' is set > 0, the cursor position becomes editable,
        # otherwise it is fixed to end

        selection_height *= gui.scale

        if click is False:
            click = input.mouse_click


        if width > 0 and active:

            rect = (x - 3, y - 2, width - 3, 21)

            # Activate Menu
            if coll(rect):
                if right_click or level_2_right_click:
                    field_menu.activate(self)

            if click and field_menu.active:
                # field_menu.click()
                click = False

            # Add text from input
            if input_text != "":
                self.eliminate_selection()
                self.text = self.text[0: len(self.text) - self.cursor_position] + input_text + self.text[len(self.text) - self.cursor_position:]

            # Handle backspace
            if key_backspace_press and len(self.text) > 0 and self.cursor_position < len(self.text):
                if self.selection != self.cursor_position:
                    self.eliminate_selection()
                else:
                    self.text = self.text[0:len(self.text) - self.cursor_position- 1] + self.text[len(self.text) - self.cursor_position:]
            elif key_backspace_press and len(self.get_selection()) > 0:
                self.eliminate_selection()

            # Left and right arrow keys to move cursor
            if key_right_press:
                if self.cursor_position > 0:
                    self.cursor_position -= 1
                if not key_shift_down and not key_shiftr_down:
                    self.selection = self.cursor_position

            if key_left_press:
                if self.cursor_position < len(self.text):
                    self.cursor_position += 1
                if not key_shift_down and not key_shiftr_down:
                    self.selection = self.cursor_position

            # Paste via ctrl-v
            if key_ctrl_down and key_v_press:
                clip = SDL_GetClipboardText().decode('utf-8')
                self.eliminate_selection()
                self.text = self.text[0: len(self.text) - self.cursor_position] + clip + self.text[len(
                    self.text) - self.cursor_position:]

            if key_ctrl_down and key_c_press:
                self.copy()

            if key_ctrl_down and key_x_press:
                if len(self.get_selection()) > 0:
                    text = self.get_selection()
                    if text != "":
                        SDL_SetClipboardText(text.encode('utf-8'))
                    self.eliminate_selection()


            # ddt.rect_r(rect, [255, 50, 50, 80], True)
            if coll(rect) and not field_menu.active:
                gui.cursor_want = 2


            fields.add(rect)


            # Delete key to remove text in front of cursor
            if key_del:
                if self.selection != self.cursor_position:
                    self.eliminate_selection()
                else:
                    self.text = self.text[0:len(self.text) - self.cursor_position] + self.text[len(
                        self.text) - self.cursor_position + 1:]
                    if self.cursor_position > 0:
                        self.cursor_position -= 1
                    self.selection = self.cursor_position

            if key_home_press:
                self.cursor_position = len(self.text)
                if not key_shift_down and not key_shiftr_down:
                    self.selection = self.cursor_position
            if key_end_press:
                self.cursor_position = 0
                if not key_shift_down and not key_shiftr_down:
                    self.selection = self.cursor_position

            if coll((x - 15, y, width + 16, selection_height + 1)):
                #ddt.rect_r((x - 15, y, width + 16, 19), [50, 255, 50, 50], True)
                if click:
                    pre = 0
                    post = 0
                    if mouse_position[0] < x + 1:
                        self.cursor_position = len(self.text)
                    else:
                        for i in range(len(self.text)):
                            post = ddt.get_text_w(self.text[0:i+1], font)
                            # pre_half = int((post - pre) / 2)

                            if x + pre - 0 <= mouse_position[0] <= x + post + 0:
                                diff = post - pre
                                if mouse_position[0] >= x + pre + int(diff / 2):
                                    self.cursor_position = len(self.text) - i - 1
                                else:
                                    self.cursor_position = len(self.text) - i
                                break
                            pre = post
                        else:
                            self.cursor_position = 0
                    self.selection = 0
                    self.down_lock = True



            if mouse_up:
                self.down_lock = False
            if self.down_lock:
                pre = 0
                post = 0
                if mouse_position[0] < x + 1:

                    self.selection = len(self.text)
                else:

                    for i in range(len(self.text)):
                        post = ddt.get_text_w(self.text[0:i + 1], font)
                        # pre_half = int((post - pre) / 2)

                        if x + pre - 0 <= mouse_position[0] <= x + post + 0:
                            diff = post - pre

                            if mouse_position[0] >= x + pre + int(diff / 2):
                                self.selection = len(self.text) - i - 1

                            else:
                                self.selection = len(self.text) - i

                            break
                        pre = post

                    else:
                        self.selection = 0

            a = ddt.get_text_w(self.text[0: len(self.text) - self.cursor_position], font)
            # print("")
            # print(self.selection)
            # print(self.cursor_position)

            b = ddt.get_text_w(self.text[0: len(self.text) - self.selection], font)

            #rint((a, b))

            top = y
            if big:
                top -= 12 * gui.scale

            ddt.rect_r([x + a, top, b - a, selection_height], [40, 120, 180, 255], True)

            if self.selection != self.cursor_position:
                inf_comp = 0
                space = ddt.draw_text((x, y), self.get_selection(0), colour, font)
                space += ddt.draw_text((x + space - inf_comp, y), self.get_selection(1), [240,240,240,255], font, bg=[40, 120, 180, 255],)
                ddt.draw_text((x + space - (inf_comp * 2), y), self.get_selection(2), colour, font)
            else:
                ddt.draw_text((x, y), self.text, colour, font)

            space = ddt.get_text_w(self.text[0: len(self.text) - self.cursor_position], font)

            if TextBox.cursor and self.selection == self.cursor_position:
                #ddt.line(x + space, y + 2, x + space, y + 15, colour)

                if big:
                    #ddt.rect_r((xx + 1 , yy - 12 * gui.scale, 2 * gui.scale, 27 * gui.scale), colour, True)
                    ddt.rect_r((x + space, y - 15 * gui.scale + 2, 1 * gui.scale, 30 * gui.scale), colour, True)
                else:
                    ddt.rect_r((x + space, y + 2, 1 * gui.scale, 14 * gui.scale), colour, True)

            if click:
                self.selection = self.cursor_position

        else:
            if active:
                self.text += input_text
                if input_text != "":
                    self.cursor = True
                if key_backspace_press and len(self.text) > 0:
                    self.text = self.text[:-1]
                if key_ctrl_down and key_v_press:
                    self.paste()

            if secret:
                space = ddt.draw_text((x, y), 'â' * len(self.text), colour, font)
            else:
                space = ddt.draw_text((x, y), self.text, colour, font)

            if active and TextBox.cursor:
                xx = x + space + 1
                yy = y + 3
                if big:
                    ddt.rect_r((xx + 1 , yy - 12 * gui.scale, 2 * gui.scale, 27 * gui.scale), colour, True)
                else:
                    ddt.rect_r((xx, yy, 1 * gui.scale, 14 * gui.scale), colour, True)

        if active and editline != "" and editline != input_text:
            ex = ddt.draw_text((x + space + 4, y), editline, [240, 230, 230, 255], font)
            #ddt.line(x + space + 4, y + 13, x + space + 4 + ex, y + 13, [245, 245, 245, 255])

        animate_monitor_timer.set()


rename_text_area = TextBox()
search_text = TextBox()
last_fm_user_field = TextBox()
last_fm_pass_field = TextBox()
rename_files = TextBox()
rename_files.text = prefs.rename_tracks_template
if rename_files_previous:
    rename_files.text = rename_files_previous
radio_field = TextBox()
radio_field.text = radio_field_text
rename_folder = TextBox()
rename_folder.text = prefs.rename_folder_template
if rename_folder_previous:
    rename_folder.text = rename_folder_previous

temp_dest = SDL_Rect(0, 0)


class GallClass:
    def __init__(self, size=250, save_out=True):
        self.gall = {}
        self.size = size
        self.queue = []
        self.key_list = []
        self.save_out = save_out
        self.i = 0

    def get_file_source(self, index):

        global album_art_gen

        sources = album_art_gen.get_sources(index)

        if len(sources) == 0:
            return False
        offset = album_art_gen.get_offset(pctl.master_library[index].fullpath, sources)
        return sources[offset] + [offset]

    def worker_render(self):

        while len(self.queue) > 0:

            self.i += 1

            key = self.queue[0]
            order = self.gall[key]

            size = key[1]

            source = self.get_file_source(key[0])

            if source is False:
                order[0] = 0
                self.gall[key] = order
                del self.queue[0]
                continue

            img_name = str(key[2]) + "-" + str(size) + '-' + str(key[0]) + "-" + str(source[2])

            # gall_render_last_timer.set()

            try:
                if prefs.cache_gallery and os.path.isfile(os.path.join(cache_directory, img_name + '.jpg')):
                    source_image = open(os.path.join(cache_directory, img_name + '.jpg'), 'rb')
                    # print('load from cache')

                elif source[0] == 1:
                    # print('tag')
                    source_image = io.BytesIO(album_art_gen.get_embed(key[0]))

                elif source[0] == 2:
                    try:
                        response = urllib.request.urlopen(get_network_thumbnail_url(pctl.g(key[0])))
                        source_image = response
                    except:
                        print("IMAGE NETWORK LOAD ERROR")
                else:
                    source_image = open(source[1], 'rb')

                g = io.BytesIO()
                g.seek(0)
                # print('pro stage 1')
                im = Image.open(source_image)
                if im.mode != "RGB":
                    im = im.convert("RGB")
                im.thumbnail((size, size), Image.ANTIALIAS)

                im.save(g, 'BMP')
                if self.save_out and prefs.cache_gallery and not os.path.isfile(os.path.join(cache_directory, img_name + '.jpg')):
                    im.save(os.path.join(cache_directory, img_name + '.jpg'), 'JPEG', quality=95)

                g.seek(0)

                source_image.close()

                order = [2, g, None, None]
                self.gall[key] = order


                del source

                if not prefs.cache_gallery:
                    time.sleep(0.01)
                else:
                    time.sleep(0.002)

                gui.update += 1
                if gui.combo_mode:
                    gui.pl_update = 1

            except:
                # raise
                print('Image load failed on track: ' + pctl.master_library[key[0]].fullpath)
                order = [0, None, None, None]
                self.gall[key] = order

            del self.queue[0]

        if self.i > 0:
            self.i = 0
            return True
        else:
            return False

    def render(self, index, location, size=None):

        x = round(location[0])
        y = round(location[1])

        # time.sleep(0.1)
        if size is None:
            size = self.size

        size = round(size)

        #offset = self.get_offset(pctl.master_library[index].fullpath, self.get_sources(index))
        if pctl.master_library[index].parent_folder_path in folder_image_offsets:
            offset = folder_image_offsets[pctl.master_library[index].parent_folder_path]
        else:
            offset = 0

        if (index, size, offset) in self.gall:
            # print("old")

            order = self.gall[(index, size, offset)]

            if order[0] == 0:
                # broken
                return False

            if order[0] == 1:
                # not done yet
                return False

            if order[0] == 2:
                # finish processing

                wop = rw_from_object(order[1])
                s_image = IMG_Load_RW(wop, 0)
                c = SDL_CreateTextureFromSurface(renderer, s_image)
                SDL_FreeSurface(s_image)
                tex_w = pointer(c_int(size))
                tex_h = pointer(c_int(size))
                SDL_QueryTexture(c, None, None, tex_w, tex_h)
                dst = SDL_Rect(x, y)
                dst.w = int(tex_w.contents.value)
                dst.h = int(tex_h.contents.value)

                order[0] = 3
                order[1] = None
                order[2] = c
                order[3] = dst
                self.gall[(index, size, offset)] = order

            if order[0] == 3:
                # ready

                order[3].x = x
                order[3].y = y
                order[3].x = int((size - order[3].w) / 2) + order[3].x
                order[3].y = int((size - order[3].h) / 2) + order[3].y
                SDL_RenderCopy(renderer, order[2], None, order[3])

                if (index, size, offset) in self.key_list:
                    self.key_list.remove((index, size, offset))
                self.key_list.append((index, size, offset))

                return True

        else:
            # Create new
            # stage, raw, texture, rect
            self.gall[(index, size, offset)] = [1, None, None, None]
            self.queue.append((index, size, offset))
            self.key_list.append((index, size, offset))

            # Remove old images to conserve RAM usage
            if len(self.key_list) > 100:
                key = self.key_list[0]
                while key in self.queue:
                    self.queue.remove(key)
                if self.gall[key][2] is not None:
                    SDL_DestroyTexture(self.gall[key][2])
                del self.gall[key]
                del self.key_list[0]

        return False


gall_ren = GallClass(album_mode_art_size)

pl_thumbnail = GallClass(save_out=False)


class ThumbTracks:
    def __init__(self):
        pass

    def path(self, track):
        image_name = track.album
        if image_name == "":
            image_name = track.title
        if image_name == "":
            image_name = "noname"

        source = gall_ren.get_file_source(track.index)

        if source is False:
            # print("NO ART")
            return None

        image_name += "-" + str(source[2])
        image_name = "".join([c for c in image_name if c.isalpha() or c.isdigit() or c == ' ']).rstrip()


        #t_path = user_directory + "/cache/" + image_name + '.jpg'
        t_path = os.path.join(cache_directory, image_name + '.jpg')

        if os.path.isfile(t_path):
            return t_path

        #print(source[0])

        if source[0] == 1:
        # print('tag')
            source_image = io.BytesIO(album_art_gen.get_embed(track.index))

        elif source[0] == 2:
            try:
                response = urllib.request.urlopen(get_network_thumbnail_url(track))
                source_image = response
            except:
                print("IMAGE NETWORK LOAD ERROR")
        else:
            source_image = open(source[1], 'rb')

        if not os.path.isdir(cache_directory):
            os.makedirs(cache_directory)


        # with open("test", 'wb') as w:
        #     w.write(source_image.read())


        im = Image.open(source_image)
        if im.mode != "RGB":
            im = im.convert("RGB")
        im.thumbnail((1000, 1000), Image.ANTIALIAS)

        im.save(t_path, 'JPEG')
        source_image.close()

        return t_path


thumb_tracks = ThumbTracks()


def img_slide_update_gall(value):

    global album_mode_art_size
    album_mode_art_size = value
    clear_img_cache()

    # Update sizes
    gall_ren.size = album_mode_art_size


def clear_img_cache(delete_disk=True):
    global album_art_gen
    album_art_gen.clear_cache()
    prefs.failed_artists.clear()
    gall_ren.key_list = []
    while len(gall_ren.queue) > 0:
        time.sleep(0.01)

    for key, value in gall_ren.gall.items():
        SDL_DestroyTexture(value[2])
    gall_ren.gall = {}

    if prefs.cache_gallery and delete_disk:
        direc = os.path.join(cache_directory)
        if os.path.isdir(direc):
            for item in os.listdir(direc):
                if "-lfm" not in item and "-ftv" not in item and "-dcg" not in item:
                    os.remove(os.path.join(direc, item))

                # Get rid of those annoying star images
                elif item.endswith("lfm.png") and os.path.getsize(os.path.join(direc, item)) < 5000:
                    os.remove(os.path.join(direc, item))

        else:
            os.makedirs(direc)

    prefs.failed_artists.clear()
    for key, value in artist_list_box.thumb_cache.items():
        if value:
            SDL_DestroyTexture(value[0])
    artist_list_box.thumb_cache.clear()
    gui.update += 1



class ImageObject():
    def __init__(self):
        self.index = 0
        self.texture = None
        self.rect = None
        self.request_size = (0, 0)
        self.original_size = (0, 0)
        self.actual_size = (0, 0)
        self.source = ""
        self.offset = 0
        self.stats = True
        self.format = ""




class AlbumArt():
    def __init__(self):
        self.image_types = {'jpg', 'JPG', 'jpeg', 'JPEG', 'PNG', 'png', 'BMP', 'bmp', 'GIF', 'gif'}
        self.art_folder_names = {'art', 'scans', 'scan', 'booklet', 'images', 'image', 'cover',
                                 'covers', 'coverart', 'albumart', 'gallery', 'jacket', 'artwork',
                                 'bonus', 'bk', 'cover artwork', 'cover art'}
        self.source_cache = {}
        self.image_cache = []
        self.current_wu = None

        self.blur_texture = None
        self.blur_rect = None

    def get_info(self, index):

        sources = self.get_sources(index)
        if len(sources) == 0:
            return None
        offset = self.get_offset(pctl.master_library[index].fullpath, sources)

        o_size = (0, 0)
        format = "ERROR"

        for item in self.image_cache:
            if item.index == index and item.offset == offset:
                o_size = item.original_size
                format = item.format
                break

        else:
            # Hacky fix
            # A quirk is the index stays of the cached image.
            # This workaround can be done since (currently) cache has max size of 1
            if self.image_cache:
                o_size = self.image_cache[0].original_size
                format = self.image_cache[0].format

        return [sources[offset][0], len(sources), offset, o_size, format]

    def get_sources(self, index):

        tr = pctl.master_library[index]
        filepath = tr.fullpath
        ext = tr.file_ext

        # Check if source list already exists, if not, make it
        if index in self.source_cache:
            return self.source_cache[index]
        else:
            pass

        source_list = []  # istag,

        # Source type the is first element in list
        # 0 = File
        # 1 = Embedded in tag
        # 2 = Network location

        if tr.is_network:
            # Add url if network target
            if tr.art_url_key:
                source_list.append([2, tr.art_url_key])
        else:
            # Check for local image files
            try:
                direc = os.path.dirname(filepath)
                items_in_dir = os.listdir(direc)
            except:
                print("Error loading directroy")
                return []

        # Check for embedded image
        try:
            if ext == 'MP3':

                tag = stagger.read_tag(filepath)

                try:
                    tt = tag[APIC][0]
                except:
                    tt = tag[PIC][0]

                if len(tt.data) > 30:
                    source_list.append([1, filepath])


            elif ext == 'OGG' or ext == 'OPUS':

                tt = Opus(filepath)
                tt.read()
                if tt.has_picture is True and len(tt.picture) > 30:
                    source_list.append([1, filepath])


            elif ext == 'FLAC':

                tt = Flac(filepath)
                tt.read(True)
                if tt.has_picture is True and len(tt.picture) > 30:
                    source_list.append([1, filepath])

            elif ext == 'APE':

                tt = Ape(filepath)
                tt.read()
                if tt.has_picture is True and len(tt.picture) > 30:
                    source_list.append([1, filepath])

            elif ext == 'M4A':

                tt = M4a(filepath)
                tt.read()
                if tt.has_picture:
                    source_list.append([1, filepath])

                    # elif '.opus' in filepath or '.OPUS' in filepath or ".ogg" in filepath or ".OGG" in filepath:
                    #
                    #     tt = Opus(filepath)
                    #     tt.read()
                    #     print("test")
                    #     if tt.has_picture is True and len(tt.picture) > 30:
                    #         source_list.append([True, filepath])

        except:

            pass

        if not tr.is_network:

            dirs_in_dir = [subdirec for subdirec in items_in_dir if
                           os.path.isdir(os.path.join(direc, subdirec)) and subdirec.lower() in self.art_folder_names]

            for i in range(len(items_in_dir)):
                if os.path.splitext(items_in_dir[i])[1][1:] in self.image_types:
                    dir_path = os.path.join(direc, items_in_dir[i]).replace('\\', "/")
                    #print(dir_path)
                    source_list.append([0, dir_path])

            for i in range(len(dirs_in_dir)):
                subdirec = os.path.join(direc, dirs_in_dir[i])
                items_in_dir2 = os.listdir(subdirec)

                for y in range(len(items_in_dir2)):
                    if os.path.splitext(items_in_dir2[y])[1][1:] in self.image_types:
                        dir_path = os.path.join(subdirec, items_in_dir2[y]).replace('\\', "/")
                        source_list.append([0, dir_path])

        self.source_cache[index] = source_list

        return source_list


    def fast_display(self, index, location, box, source, offset):

        # Renders cached image only by given size for faster performance

        found_unit = None
        max_h = 0

        for unit in self.image_cache:
            if unit.source == source[offset][1]:
                if unit.actual_size[1] > max_h:
                    max_h = unit.actual_size[1]
                    found_unit = unit

        if found_unit == None:
            return 1

        unit = found_unit

        temp_dest.x = round(location[0])
        temp_dest.y = round(location[1])

        temp_dest.w = unit.original_size[0]#round(box[0])
        temp_dest.h = unit.original_size[1]#round(box[1])

        bh = round(box[1])
        bw = round(box[0])

        # Constrain image to given box
        if temp_dest.w > bw:
            temp_dest.w = bw
            temp_dest.h = int(bw * (unit.original_size[1] / unit.original_size[0]))

        if temp_dest.h > bh:
            temp_dest.h = bh
            temp_dest.w = int(temp_dest.h * (unit.original_size[0] / unit.original_size[1]))


        # prevent scaling larger than original image size
        if temp_dest.w > unit.original_size[0] or temp_dest.h > unit.original_size[1]:
            temp_dest.w = unit.original_size[0]
            temp_dest.h = unit.original_size[1]

        # center the image
        temp_dest.x = int((box[0] - temp_dest.w) / 2) + temp_dest.x
        temp_dest.y = int((box[1] - temp_dest.h) / 2) + temp_dest.y

        # render the image
        SDL_RenderCopy(renderer, unit.texture, None, temp_dest)
        style_overlay.hole_punches.append(temp_dest)

    def open_external(self, index):

        source = self.get_sources(index)
        if len(source) == 0:
            return 0

        offset = self.get_offset(pctl.master_library[index].fullpath, source)

        if source[offset][0] > 0:
            return 0

        if system == "windows":
            os.startfile(source[offset][1])
        elif system == 'mac':
            subprocess.call(["open", source[offset][1]])
        else:
            subprocess.call(["xdg-open", source[offset][1]])

        return 0

    def cycle_offset(self, index, reverse=False):

        filepath = pctl.master_library[index].fullpath
        sources = self.get_sources(index)
        if len(sources) == 0:
            return 0
        parent_folder = os.path.dirname(filepath)
        # Find cached offset
        if parent_folder in folder_image_offsets:

            if reverse:
                folder_image_offsets[parent_folder] -= 1
            else:
                folder_image_offsets[parent_folder] += 1

            folder_image_offsets[parent_folder] %= len(sources)
        return 0

    def cycle_offset_reverse(self, index):
        self.cycle_offset(index, True)

    def get_offset(self, filepath, source):

        # Check if folder offset already exsts, if not, make it
        parent_folder = os.path.dirname(filepath)

        if parent_folder in folder_image_offsets:

            # Reset the offset if greater than number of images available
            if folder_image_offsets[parent_folder] > len(source) - 1:
                folder_image_offsets[parent_folder] = 0
        else:
            folder_image_offsets[parent_folder] = 0

        return folder_image_offsets[parent_folder]

    def get_embed(self, index):

        filepath = pctl.master_library[index].fullpath

        if pctl.master_library[index].file_ext == 'MP3':

            tag = stagger.read_tag(filepath)
            try:
                return tag[APIC][0].data
            except:
                return tag[PIC][0].data



        elif pctl.master_library[index].file_ext == 'FLAC':
            tag = Flac(filepath)
            tag.read(True)
            return tag.picture

        elif pctl.master_library[index].file_ext == 'APE':
            tag = Ape(filepath)
            tag.read()
            return tag.picture

        elif pctl.master_library[index].file_ext == 'M4A':
            tag = M4a(filepath)
            tag.read(True)
            return tag.picture

        elif pctl.master_library[index].file_ext == 'OPUS' or pctl.master_library[index].file_ext == 'OGG':
            tag = Opus(filepath)
            tag.read()
            a = io.BytesIO(base64.b64decode(tag.picture))
            a.seek(0)

            image = parse_picture_block(a)
            a.close()
            return image

    def get_source_raw(self, offset, source, index):

        source_image = None
        if source[offset][0] == 1:
            # Target is a embedded image
            source_image = io.BytesIO(self.get_embed(index))
        elif source[offset][0] == 2:
            try:
                response = urllib.request.urlopen(get_network_thumbnail_url(tr))
                source_image = response
            except:
                print("IMAGE NETWORK LOAD ERROR")

        else:
            source_image = open(source[offset][1], 'rb')
        return source_image

    def get_base64(self, index, size):

        filepath = pctl.master_library[index].fullpath
        sources = self.get_sources(index)

        if len(sources) == 0:
            return False

        offset = self.get_offset(filepath, sources)

        # Get source IO
        source_image = self.get_source_raw(offset, sources, index)

        if source_image is None:
            return ""



        im = Image.open(source_image)
        if im.mode != "RGB":
            im = im.convert("RGB")
        im.thumbnail(size, Image.ANTIALIAS)
        buff = io.BytesIO()
        im.save(buff, format="JPEG")
        sss = base64.b64encode(buff.getvalue())
        return sss


    def get_blur_im(self, index):


        filepath = pctl.master_library[index].fullpath
        sources = self.get_sources(index)

        if len(sources) == 0:
            return False

        offset = self.get_offset(filepath, sources)

        source_image = self.get_source_raw(offset, sources, index)

        if source_image is None:
            return None

        im = Image.open(source_image)

        ox_size = im.size[0]
        oy_size = im.size[1]

        format = im.format
        if im.format == "JPEG":
            format = "JPG"

        # print(im.size)
        if im.mode != "RGB":
            im = im.convert("RGB")

        ratio = window_size[0] / ox_size
        ratio += 0.2

        if (oy_size * ratio) - ((oy_size * ratio) // 4)  < window_size[1]:
            print("Adjust bg vertical")
            ratio = window_size[1] / (oy_size - (oy_size // 4))
            ratio += 0.2

        new_x = round(ox_size * ratio)
        new_y = round(oy_size * ratio)


        im = im.resize((new_x, new_y))

        if ox_size < 500 or prefs.art_bg_always_blur:
            im = im.filter(ImageFilter.GaussianBlur(prefs.art_bg_blur))

        g = io.BytesIO()
        g.seek(0)

        a_channel = Image.new('L', im.size, 255)  # 'L' 8-bit pixels, black and white
        im.putalpha(a_channel)

        im.save(g, 'PNG')
        g.seek(0)

        source_image.close()

        return g


    # def display_blur(self, index, size):
    #
    #     if self.blur_texture is not None:
    #
    #         self.blur_rect.y = 0 - self.blur_rect.h // 3
    #         SDL_RenderCopy(renderer, self.blur_texture, None, self.blur_rect)
    #
    #         return
    #
    #     filepath = pctl.master_library[index].fullpath
    #     sources = self.get_sources(index)
    #
    #     if len(sources) == 0:
    #         return False
    #
    #     offset = self.get_offset(filepath, sources)
    #
    #     source_image = self.get_source_raw(offset, sources, index)
    #
    #     if source_image is None:
    #         return
    #
    #     im = Image.open(source_image)
    #
    #     format = im.format
    #     if im.format == "JPEG":
    #         format = "JPG"
    #
    #     # print(im.size)
    #     if im.mode != "RGB":
    #         im = im.convert("RGB")
    #
    #
    #     rim = im.resize((1400, 1400))
    #     #bim = rim.filter(ImageFilter.GaussianBlur())
    #     # im.save(save_path + '.jpg', 'JPEG')
    #     #im = bim
    #     im = rim
    #
    #     g = io.BytesIO()
    #     g.seek(0)
    #
    #     a_channel = Image.new('L', im.size, 255)  # 'L' 8-bit pixels, black and white
    #     im.putalpha(a_channel)
    #
    #     im.save(g, 'PNG')
    #
    #     g.seek(0)
    #
    #     wop = rw_from_object(g)
    #     s_image = IMG_Load_RW(wop, 0)
    #     # print(IMG_GetError())
    #
    #     c = SDL_CreateTextureFromSurface(renderer, s_image)
    #
    #     tex_w = pointer(c_int(0))
    #     tex_h = pointer(c_int(0))
    #
    #     SDL_QueryTexture(c, None, None, tex_w, tex_h)
    #
    #     dst = SDL_Rect(round(0, 0))
    #     dst.w = int(tex_w.contents.value)
    #     dst.h = int(tex_h.contents.value)
    #
    #     # Clean uo
    #     SDL_FreeSurface(s_image)
    #     g.close()
    #     source_image.close()
    #
    #     print(SDL_SetTextureAlphaMod(c, 10))
    #     #print(SDL_SetTextureAlphaMod(c, 40))
    #
    #     self.blur_texture = c
    #     self.blur_rect = dst
    #
    #     self.display_blur(index, size)



    def save_thumb(self, index, size, save_path):

        filepath = pctl.master_library[index].fullpath
        sources = self.get_sources(index)

        if len(sources) == 0:
            return False

        offset = self.get_offset(filepath, sources)

        # Get source IO
        if sources[offset][0] == 1:
            # Target is a embedded image
            source_image = io.BytesIO(self.get_embed(index))
        elif sources[offset][0] == 2:
            try:
                response = urllib.request.urlopen(get_network_thumbnail_url(tr))
                source_image = response
            except:
                print("IMAGE NETWORK LOAD ERROR")

        else:
            source_image = open(sources[offset][1], 'rb')

        im = Image.open(source_image)
        if im.mode != "RGB":
            im = im.convert("RGB")
        im.thumbnail(size, Image.ANTIALIAS)
        im.save(save_path + '.jpg', 'JPEG')

        g = io.BytesIO()
        g.seek(0)
        #im = Image.open(source_image)
        #_size = im.size

        #format = im.format

        im.save(g, 'BMP')
        g.close()


    def display(self, index, location, box, fast=False):

        tr = pctl.master_library[index]
        filepath = tr.fullpath

        if prefs.colour_from_image and index != gui.theme_temp_current and box[0] != 115: #mark2233
            if tr.album in gui.temp_themes:
                global colours
                colours = gui.temp_themes[tr.album]

                gui.theme_temp_current = index

        source = self.get_sources(index)
        if len(source) == 0:
            return False

        offset = self.get_offset(filepath, source)

        # Check if request matches previous
        if self.current_wu is not None and self.current_wu.source == source[offset][1] and \
                        self.current_wu.request_size == box:
            self.render(self.current_wu, location)
            return 0

        if fast:
            return self.fast_display(index, location, box, source, offset)

        # Check if cached
        for unit in self.image_cache:
            if unit.index == index and unit.request_size == box and unit.offset == offset:
                self.render(unit, location)
                return 0

        # Render new...
        try:

            # Get source IO
            if source[offset][0] == 1:
                # Target is a embedded image
                source_image = io.BytesIO(self.get_embed(index))
            elif source[offset][0] == 2:
                try:
                    response = urllib.request.urlopen(get_network_thumbnail_url(tr))
                    source_image = response
                except:
                    print("IMAGE NETWORK LOAD ERROR")

            else:
                source_image = open(source[offset][1], 'rb')


            # # Temporary Fix
            # quick_d_timer.set()

            # Generate
            g = io.BytesIO()
            g.seek(0)
            im = Image.open(source_image)
            o_size = im.size

            format = im.format
            if im.format == "JPEG":
                format = "JPG"

            # print(im.size)
            if im.mode != "RGB":
                im = im.convert("RGB")
            im.thumbnail((box[0], box[1]), Image.ANTIALIAS)
            im.save(g, 'BMP')
            g.seek(0)

            if prefs.colour_from_image and box[0] != 115 and index != gui.theme_temp_current: # and pctl.master_library[index].parent_folder_path != colours.last_album: #mark2233
                colours.last_album = tr.parent_folder_path

                im.thumbnail((50, 50), Image.ANTIALIAS)
                pixels = im.getcolors(maxcolors=2500)
                # print(pixels)
                pixels = sorted(pixels, key=lambda x: x[0], reverse=True)[:]
                # print(pixels)

                min_colour_varience = 75

                x_colours = []
                for item in pixels:
                    colour = item[1]
                    for cc in x_colours:
                        if abs(colour[0] - cc[0]) < min_colour_varience and abs(
                                        colour[1] - cc[1]) < min_colour_varience and abs(
                                        colour[2] - cc[2]) < min_colour_varience:
                            break
                    else:
                        x_colours.append(colour)

                # print(x_colours)

                colours.playlist_panel_background = x_colours[0] + (255,)
                if len(x_colours) > 1:
                    colours.side_panel_background = x_colours[1] + (255,)
                    if len(x_colours) > 2:
                        colours.title_text = x_colours[2] + (255,)
                        colours.title_playing = x_colours[2] + (255,)
                        if len(x_colours) > 3:
                            colours.artist_text = x_colours[3] + (255,)
                            colours.artist_playing = x_colours[3] + (255,)

                bg = 0
                ar = 0
                ti = 0

                # print("")

                if colour_value(colours.playlist_panel_background) < 120:
                    # print("Backgroud is dark")
                    bg = 1
                if colour_value(colours.playlist_panel_background) > 300:
                    # print("Backgroud is Light")
                    bg = 2
                if colour_value(colours.title_text) < 190:
                    # print("Title is dark")
                    ti = 1
                if colour_value(colours.title_text) > 300:
                    # print("Title is Light")
                    ti = 2
                if colour_value(colours.artist_text) < 190:
                    # print("Artist is dark")
                    ar = 1
                if colour_value(colours.artist_text) > 400:
                    # print("Artist is Light")
                    ar = 2

                if bg == 2 and ti == 2:
                    # print("fix!")
                    colours.title_text = [40, 40, 40, 255]
                    colours.title_playing = [40, 40, 40, 255]

                if bg == 2 and ar == 2:
                    # print("fix!")
                    colours.artist_text = [20, 20, 20, 255]
                    colours.artist_playing = [20, 20, 20, 255]

                if bg == 1 and ti == 1:
                    # print("fix!")
                    colours.title_text = [200, 200, 200, 255]
                    colours.title_playing = [200, 200, 200, 255]

                if bg == 1 and ar == 1:
                    # print("fix!")
                    colours.artist_text = [170, 170, 170, 255]
                    colours.artist_playing = [170, 170, 170, 255]

                if (colour_value(colours.side_panel_background)) > 350:
                    colours.side_bar_line1 = [25, 25, 25, 255]
                    colours.side_bar_line2 = [35, 35, 35, 255]
                else:
                    colours.side_bar_line1 = [220, 220, 220, 255]
                    colours.side_bar_line2 = [205, 205, 205, 255]

                colours.album_text = colours.title_text
                colours.album_playing = colours.title_playing

                gui.pl_update = 1
                # print("Bgr1: ", end="")
                # print(colours.playlist_panel_background)
                # print("Bgr2: ", end="")
                # print(colours.side_panel_background)
                # print("Txt1: ", end="")
                # print(colours.artist_text)
                # print("Txt2: ", end="")
                # print(colours.title_text)
                #
                # print("Colours found: ", end="")
                # print(len(x_colours))
                # print("Background perceived lightness: ", end="")
                prcl = 100 - int(test_lumi(colours.playlist_panel_background) * 100)
                # print(prcl, end="")
                # print("%")

                if prcl > 45:
                    ce = alpha_blend([0, 0, 0, 180], colours.playlist_panel_background) #[40, 40, 40, 255]
                    colours.index_text = ce
                    colours.index_playing = ce
                    colours.time_text = ce
                    colours.bar_time = ce
                    colours.folder_title = ce
                    colours.star_line = [60, 60, 60, 255]
                    colours.row_select_highlight = [0, 0, 0, 30]
                    colours.row_playing_highlight = [0, 0, 0, 20]
                    colours.gallery_background = hls_mod_add(colours.playlist_panel_background, 0, -0.03, 0)
                else:
                    ce = alpha_blend([255, 255, 255, 160], colours.playlist_panel_background) #[165, 165, 165, 255]
                    colours.index_text = ce
                    colours.index_playing = ce
                    colours.time_text = ce
                    colours.bar_time = ce
                    colours.folder_title = ce
                    colours.star_line = ce #[150, 150, 150, 255]
                    colours.row_select_highlight = [255, 255, 255, 12]
                    colours.row_playing_highlight = [255, 255, 255, 8]
                    colours.gallery_background = hls_mod_add(colours.playlist_panel_background, 0, 0.03, 0)

                gui.temp_themes[pctl.master_library[index].album] = copy.deepcopy(colours)
                gui.theme_temp_current = index

            wop = rw_from_object(g)
            s_image = IMG_Load_RW(wop, 0)
            # print(IMG_GetError())

            c = SDL_CreateTextureFromSurface(renderer, s_image)

            tex_w = pointer(c_int(0))
            tex_h = pointer(c_int(0))

            SDL_QueryTexture(c, None, None, tex_w, tex_h)

            dst = SDL_Rect(round(location[0]), round(location[1]))
            dst.w = int(tex_w.contents.value)
            dst.h = int(tex_h.contents.value)

            # Clean uo
            SDL_FreeSurface(s_image)
            g.close()
            source_image.close()

            unit = ImageObject()
            unit.index = index
            unit.texture = c
            unit.rect = dst
            unit.request_size = box
            unit.original_size = o_size
            unit.actual_size = (dst.w, dst.h)
            unit.source = source[offset][1]
            unit.offset = offset
            unit.format = format

            self.current_wu = unit
            self.image_cache.append(unit)

            self.render(unit, location)

            if len(self.image_cache) > 5:
                SDL_DestroyTexture(self.image_cache[0].texture)
                del self.image_cache[0]
            if prefs.colour_from_image and len(self.image_cache) > 1:
                SDL_DestroyTexture(self.image_cache[0].texture)
                del self.image_cache[0]

            # temp fix
            global move_on_title
            global playlist_hold
            global quick_drag
            quick_drag = False
            move_on_title = False
            playlist_hold = False


        except OSError as error:

            print("Image processing error: " + str(error))
            self.current_wu = None
            del self.source_cache[index][offset]
            return 1
        except Exception as error:

            print("Image processing error" + str(error))
            self.current_wu = None
            del self.source_cache[index][offset]
            return 1

        return 0

    def render(self, unit, location):

        rect = unit.rect

        gui.art_aspect_ratio = unit.actual_size[0] / unit.actual_size[1]

        rect.x = round(int((unit.request_size[0] - unit.actual_size[0]) / 2) + location[0])
        rect.y = round(int((unit.request_size[1] - unit.actual_size[1]) / 2) + location[1])

        style_overlay.hole_punches.append(rect)

        SDL_RenderCopy(renderer, unit.texture, None, rect)

    def clear_cache(self):

        for unit in self.image_cache:
            SDL_DestroyTexture(unit.texture)

        self.image_cache = []
        self.source_cache = {}
        self.current_wu = None


album_art_gen = AlbumArt()


# 0 - blank
# 1 - preparing first
# 2 - render first
# 3 - preparing 2nd

class StyleOverlay:

    def __init__(self):

        self.min_on_timer = Timer()
        self.fade_on_timer = Timer(0)
        self.fade_off_timer = Timer()

        self.stage = 0

        self.im = None

        self.a_texture = None
        self.a_rect = None

        self.b_texture = None
        self.b_rect = None

        self.window_size = None
        self.parent_path = None

        self.hole_punches = []

        self.go_to_sleep = False

        self.current_track_album = "none"
        self.current_track_id = -1


    def worker(self):

        if self.stage == 0:
            if pctl.playing_ready() and self.min_on_timer.get() > 0:
                index = pctl.playing_object().index
                self.window_size = copy.copy(window_size)
                self.parent_path = pctl.playing_object().parent_folder_path
                self.current_track_id = pctl.playing_object().index
                self.current_track_album = pctl.playing_object().album

                self.im = album_art_gen.get_blur_im(index)
                if self.im is None or self.im is False:
                    if self.a_texture:
                        self.stage = 2
                        self.fade_off_timer.set()
                        self.go_to_sleep = True
                        return
                    else:
                        self.flush()
                        self.min_on_timer.force_set(-8)
                        return

                self.stage = 1
                gui.update += 1
                return

    def flush(self):

        if self.a_texture is not None:
            SDL_DestroyTexture(self.a_texture)
            self.a_texture = None
        if self.b_texture is not None:
            SDL_DestroyTexture(self.b_texture)
            self.b_texture = None
        self.min_on_timer.force_set(-1)
        self.parent_path = "None"
        self.stage = 0

    def display(self):

        if self.min_on_timer.get() < 0:
            return

        # if prefs.bg_showcase_only:
        #     if not gui.combo_mode:
        #
        #         if self.a_texture is not None:
        #                 print("FLUSH")
        #                 self.flush()
        #                 self.fade_off_timer.set()
        #                 self.go_to_sleep = True
        #
        #         return

        if self.stage == 1:

            wop = rw_from_object(self.im)
            s_image = IMG_Load_RW(wop, 0)

            c = SDL_CreateTextureFromSurface(renderer, s_image)

            tex_w = pointer(c_int(0))
            tex_h = pointer(c_int(0))

            SDL_QueryTexture(c, None, None, tex_w, tex_h)

            dst = SDL_Rect(round(-40, 0))
            dst.w = int(tex_w.contents.value)
            dst.h = int(tex_h.contents.value)

            # Clean uo
            SDL_FreeSurface(s_image)
            self.im.close()

            #SDL_SetTextureAlphaMod(c, 10)
            self.fade_on_timer.set()

            if self.a_texture is not None:
                self.b_texture = self.a_texture
                self.b_rect = self.a_rect

            self.a_texture = c
            self.a_rect = dst
            self.stage = 2

            gui.update += 1




        if self.stage == 2:
            track = pctl.playing_object()
            if not self.go_to_sleep and self.b_texture is None and self.current_track_id != track.index:

                if not track.album:
                    self.stage = 0
                else:
                    self.current_track_id = track.index
                    if (self.parent_path != pctl.playing_object().parent_folder_path or self.current_track_album != pctl.playing_object().album):
                        self.stage = 0


        if prefs.bg_showcase_only:
            if not gui.combo_mode:
                return

        t = self.fade_on_timer.get()
        SDL_SetRenderTarget(renderer, gui.main_texture_overlay_temp)
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255)
        SDL_RenderClear(renderer)

        if self.a_texture is not None:
            if self.window_size != window_size:
                self.flush()

        if self.b_texture is not None:

            self.b_rect.y = 0 - self.b_rect.h // 4

            if t < 0.4:

                SDL_RenderCopy(renderer, self.b_texture, None, self.b_rect)

            else:
                SDL_DestroyTexture(self.b_texture)
                self.b_texture = None
                self.b_rect = None


        if self.a_texture is not None:

            self.a_rect.y = 0 - self.a_rect.h // 4

            if t < 0.4:
                fade = round(t / 0.4 * 255)
                gui.update += 1

            else:
                fade = 255

            if self.go_to_sleep:
                t = self.fade_off_timer.get()
                gui.update += 1

                if t < 1:
                    fade = 255
                elif t < 1.4:
                    fade = 255 - round((t - 1) / 0.4 * 255)
                else:
                    self.go_to_sleep = False
                    self.flush()
                    return


            if prefs.bg_showcase_only:
                tb = SDL_Rect(0, 0, window_size[0], gui.panelY)
                bb = SDL_Rect(0, window_size[1] - gui.panelBY, window_size[0], gui.panelBY)
                self.hole_punches.append(tb)
                self.hole_punches.append(bb)


            SDL_SetRenderTarget(renderer, gui.main_texture_overlay_temp)
            SDL_SetTextureAlphaMod(self.a_texture, fade)
            SDL_RenderCopy(renderer, self.a_texture, None, self.a_rect)


            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0)
            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE)
            for rect in self.hole_punches:
                SDL_RenderFillRect(renderer, rect)


            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND)

            SDL_SetRenderTarget(renderer, gui.main_texture)
            SDL_SetTextureAlphaMod(gui.main_texture_overlay_temp, prefs.art_bg_opactiy)
            SDL_RenderCopy(renderer, gui.main_texture_overlay_temp, None, None)

            SDL_SetRenderTarget(renderer, gui.main_texture)

        else:
            SDL_SetRenderTarget(renderer, gui.main_texture)





style_overlay = StyleOverlay()



def trunc_line(line, font, px, dots=True):  # This old function is slow and should be avoided

    if ddt.get_text_w(line, font) < px + 10:
        return line

    if dots:
        while ddt.get_text_w(line.rstrip(" ") + gui.trunk_end, font) > px:
            if len(line) == 0:
                return gui.trunk_end
            line = line[:-1]
        return line.rstrip(" ") + gui.trunk_end

    else:
        while ddt.get_text_w(line, font) > px:

            line = line[:-1]
            if len(line) < 2:
                break

        return line

def right_trunc(line, font, px, dots=True):

    if ddt.get_text_w(line, font) < px + 10:
        return line

    if dots:
        while ddt.get_text_w(line.rstrip(" ") + gui.trunk_end, font) > px:
            if len(line) == 0:
                return gui.trunk_end
            line = line[1:]
        return gui.trunk_end + line.rstrip(" ")

    else:
        while ddt.get_text_w(line, font) > px:
            # trunk = True
            line = line[1:]
            if len(line) < 2:
                break
        # if trunk and dots:
        #     line = line.rstrip(" ") + gui.trunk_end
        return line

# def trunc_line2(line, font, px):
#     trunk = False
#     p = ddt.get_text_w(line, font)
#     if p == 0 or p < px + 15:
#         return line
#
#     tl = line[0:(int(px / p * len(line)) + 3)]
#
#     if ddt.get_text_w(line.rstrip(" ") + gui.trunk_end, font) > px:
#         line = tl
#
#     while ddt.get_text_w(line.rstrip(" ") + gui.trunk_end, font) > px + 10:
#         trunk = True
#         line = line[:-1]
#         if len(line) < 1:
#             break
#
#     return line.rstrip(" ") + gui.trunk_end



click_time = time.time()
scroll_hold = False
scroll_point = 0
scroll_bpoint = 0
sbl = 50
sbp = 100

asbp = 50
album_scroll_hold = False


def fix_encoding(index, mode, enc):
    global default_playlist
    global enc_field

    todo = []

    if mode == 1:
        todo = [index]
    elif mode == 0:
        for b in range(len(default_playlist)):
            if pctl.master_library[default_playlist[b]].parent_folder_name == pctl.master_library[
                index].parent_folder_name:
                todo.append(default_playlist[b])

    for q in range(len(todo)):

        # key = pctl.master_library[todo[q]].title + pctl.master_library[todo[q]].filename
        old_star = star_store.full_get(todo[q])
        if old_star != None:
            star_store.remove(todo[q])

        if enc_field == 'All' or enc_field == 'Artist':
            line = pctl.master_library[todo[q]].artist
            line = line.encode("Latin-1", 'ignore')
            line = line.decode(enc, 'ignore')
            pctl.master_library[todo[q]].artist = line

        if enc_field == 'All' or enc_field == 'Album':
            line = pctl.master_library[todo[q]].album
            line = line.encode("Latin-1", 'ignore')
            line = line.decode(enc, 'ignore')
            pctl.master_library[todo[q]].album = line

        if enc_field == 'All' or enc_field == 'Title':
            line = pctl.master_library[todo[q]].title
            line = line.encode("Latin-1", 'ignore')
            line = line.decode(enc, 'ignore')
            pctl.master_library[todo[q]].title = line

        if old_star != None:
            star_store.insert(todo[q], old_star)

        # if key in pctl.star_library:
        #     newkey = pctl.master_library[todo[q]].title + pctl.master_library[todo[q]].filename
        #     if newkey not in pctl.star_library:
        #         pctl.star_library[newkey] = copy.deepcopy(pctl.star_library[key])
        #         # del pctl.star_library[key]


def transfer_tracks(index, mode, to):
    todo = []

    if mode == 0:
        todo = [index]
    elif mode == 1:
        for b in range(len(default_playlist)):
            if pctl.master_library[default_playlist[b]].parent_folder_name == pctl.master_library[
                index].parent_folder_name:
                todo.append(default_playlist[b])
    elif mode == 2:
        todo = default_playlist

    pctl.multi_playlist[to][2] += todo


def prep_gal():
    global albums
    albums = []

    folder = ""

    for index in default_playlist:

        if folder != pctl.master_library[index].parent_folder_name:
            albums.append([index, 0])
            folder = pctl.master_library[index].parent_folder_name


def load_xspf(path):
    global master_count
    global to_got

    name = os.path.basename(path)[:-5]
    try:
        parser = ET.XMLParser(encoding="utf-8")
        e = ET.parse(path, parser).getroot()

        a = []

        b = {}
        if 'track' in e[0][0].tag:
            for track in e[0]:
                for item in track:
                    if 'title' in item.tag and item.text:
                        b['title'] = item.text
                    if 'location' in item.tag and item.text:
                        l = item.text
                        if l[:5] == "file:":
                            l = l.replace('file:', "")
                            l = l.lstrip("/")
                            l = "/" + l
                        b['location'] = l
                    if 'creator' in item.tag and item.text:
                        b['artist'] = item.text
                    if 'album' in item.tag and item.text:
                        b['album'] = item.text
                    if 'duration' in item.tag and item.text:
                        b['duration'] = item.text

                a.append(copy.deepcopy(b))
                b = {}

    except:
        show_message("Error importing XSPF playlist.", 'warning', "Sorry about that.")
        return

    playlist = []
    missing = 0

    if len(a) > 5000:
        to_got = 'xspfl'

    # Generate location dict
    location_dict = {}
    base_names = {}
    r_base_names = {}
    titles = {}
    for key, value in pctl.master_library.items():
        if value.fullpath != "":
            location_dict[value.fullpath] = key
        if value.filename != "":
            base_names[value.filename] = 0
            r_base_names[key] = value.filename
        if value.title != "":
            titles[value.title] = 0

    for track in a:
        found = False

        # Check if we already have a track with full file path in database
        if 'location' in track:

            location = track['location']
            if location in location_dict:
                playlist.append(location_dict[location])
                found = True

            if found is True:
                continue

        # Then check for title, artist and filename match
        if 'location' in track and 'duration' in track and 'title' in track and 'artist' in track:
            base = os.path.basename(track['location'])
            if base in base_names:
                for index, bn in r_base_names.items():
                    va = pctl.master_library[index]
                    if va.artist == track['artist'] and va.title == track['title'] and \
                                    os.path.isfile(va.fullpath) and \
                                    va.filename == base:
                        playlist.append(index)
                        found = True
                        break
                if found is True:
                    continue

        # Then check for just title and artist match
        if 'title' in track and 'artist' in track and track['title'] in titles:
            for key, value in pctl.master_library.items():
                if value.artist == track['artist'] and value.title == track['title'] and os.path.isfile(value.fullpath):
                    playlist.append(key)
                    found = True
                    break
            if found is True:
                continue

        if 'location' in track or 'title' in track:
            nt = TrackClass()
            nt.index = master_count
            nt.found = False

            if 'location' in track:
                location = track['location']
                nt.fullpath = location.replace('\\', '/')
                nt.filename = os.path.basename(location)
                nt.parent_folder_path = os.path.dirname(location.replace('\\', '/'))
                nt.parent_folder_name = os.path.splitext(os.path.basename(nt.parent_folder_path))[0]
                nt.file_ext = os.path.splitext(os.path.basename(location))[1][1:].upper()
                if os.path.isfile(location):
                    nt.found = True
                    missing -= 1
            elif 'album' in track:
                nt.parent_folder_name = track['album']
            if 'artist' in track:
                nt.artist = track['artist']
            if 'title' in track:
                nt.title = track['title']
            if 'duration' in track:
                nt.length = int(float((track['duration'])) / 1000)
            if 'album' in track:
                nt.album = track['album']
            nt.is_cue = False
            if nt.found is True:
                nt = tag_scan(nt)

            pctl.master_library[master_count] = nt
            playlist.append(master_count)
            master_count += 1

        missing += 1

    if missing > 0:
        show_message('Failed to locate ' + str(missing) + ' out of ' + str(len(a)) + ' tracks.')

    pctl.multi_playlist.append(pl_gen(title=name,
                                      playlist=playlist))
    gui.update = 1


bb_type = 0

# gui.scroll_hide_box = (0, gui.panelY, 28, window_size[1] - gui.panelBY - gui.panelY)

encoding_menu = False
enc_index = 0
enc_setting = 0
enc_field = 'All'

gen_menu = False

transfer_setting = 0

b_panel_size = 300
b_info_bar = False

class LoadImageAsset:
    def __init__(self, local_path, is_full_path=False):
        if is_full_path:
            raw_image = IMG_Load(local_path.encode('utf-8'))
        else:
            raw_image = IMG_Load(b_active_directory + local_path.encode('utf-8'))

        self.sdl_texture = SDL_CreateTextureFromSurface(renderer, raw_image)

        p_w = pointer(c_int(0))
        p_h = pointer(c_int(0))
        SDL_QueryTexture(self.sdl_texture, None, None, p_w, p_h)

        if is_full_path:
            SDL_SetTextureAlphaMod(self.sdl_texture, prefs.custom_bg_opacity)

        self.rect = SDL_Rect(0, 0, p_w.contents.value, p_h.contents.value)
        self.w = p_w.contents.value
        self.h = p_h.contents.value

    def render(self, x, y, colour=None):
        self.rect.x = round(x)
        self.rect.y = round(y)
        SDL_RenderCopy(renderer, self.sdl_texture, None, self.rect)

class WhiteModImageAsset:
    def __init__(self, local_path):
        raw_image = IMG_Load(b_active_directory + local_path.encode('utf-8'))
        self.sdl_texture = SDL_CreateTextureFromSurface(renderer, raw_image)
        self.colour = [255, 255, 255, 255]
        p_w = pointer(c_int(0))
        p_h = pointer(c_int(0))
        SDL_QueryTexture(self.sdl_texture, None, None, p_w, p_h)
        self.rect = SDL_Rect(0, 0, p_w.contents.value, p_h.contents.value)
        SDL_FreeSurface(raw_image)
        self.w = p_w.contents.value
        self.h = p_h.contents.value

    def render(self, x, y, colour):
        if colour != self.colour:
            SDL_SetTextureColorMod(self.sdl_texture, colour[0], colour[1], colour[2])
            SDL_SetTextureAlphaMod(self.sdl_texture, colour[3])
            self.colour = colour
        self.rect.x = round(x)
        self.rect.y = round(y)
        SDL_RenderCopy(renderer, self.sdl_texture, None, self.rect)


if gui.scale == 2:
    asset_dir = asset_subfolder + "2x/"
elif gui.scale == 1.25:
    asset_dir = asset_subfolder + "1.25x/"
else:
    asset_dir = asset_subfolder


def asset_loader(name, mod=False):

    if mod:
        return WhiteModImageAsset(asset_dir + name)
    return LoadImageAsset(asset_dir + name)

message_info_icon = asset_loader("notice.png")
message_warning_icon = asset_loader("warning.png")
message_tick_icon = asset_loader("done.png")
message_arrow_icon = asset_loader("ext.png")
message_error_icon = asset_loader("error.png")
message_bubble_icon = asset_loader("bubble.png")


class ToolTip:

    def __init__(self):
        self.text = ""
        self.h = 24 * gui.scale
        self.w = 62 * gui.scale
        self.x = 0
        self.y = 0
        self.timer = Timer()
        self.trigger = 1.1
        self.font = 13
        self.called = False
        self.a = False

    def test(self, x, y, text):

        if self.text != text:
            self.text = text
            #self.timer.set()
            self.a = False

            self.x = x
            self.y = y
            self.w = ddt.get_text_w(text, self.font) + 20 * gui.scale

        self.called = True

        if self.a is False:
            self.timer.set()
            gui.frame_callback_list.append(TestTimer(self.trigger))
        self.a = True

    def render(self):

        if self.called is True:

            if self.timer.get() > self.trigger:

                ddt.rect_r((self.x, self.y, self.w, self.h), colours.menu_background, True)
                ddt.rect_r((self.x, self.y, self.w, self.h), colours.grey(45))
                ddt.draw_text((self.x + int(self.w / 2), self.y + 4 * gui.scale, 2), self.text, colours.message_box_text, self.font, bg=colours.menu_background)
            else:
                #gui.update += 1
                pass
        else:
            self.timer.set()
            self.a = False

        self.called = False

tool_tip = ToolTip()
tool_tip2 = ToolTip()
tool_tip2.trigger = 1.8
track_box_path_tool_timer = Timer()

def ex_tool_tip(x, y, text1_width, text, font):

    text2_width = ddt.get_text_w(text, font)
    if text2_width == text1_width:
        return

    y -= 10 * gui.scale

    w = ddt.get_text_w(text, 312) + 24 * gui.scale
    h = 24 * gui.scale

    x = x - int(w / 2)

    border = 1 * gui.scale
    ddt.rect_r((x - border, y - border, w + border * 2, h + border * 2), colours.grey(60))
    ddt.rect_r((x, y, w, h), colours.menu_background, True)
    p = ddt.draw_text((x + int(w / 2), y + 3 * gui.scale, 2), text, colours.message_box_text, 312, bg=colours.menu_background)


class ToolTip3:

    def __init__(self):
        self.x = 0
        self.y = 0
        self.text = ""
        self.font = None
        self.show = False
        self.width = 0
        self.height = 24 * gui.scale
        self.timer = Timer()
        self.pl_position = 0
        self.click_exclude_point = (0, 0)

    def set(self, x, y, text, font, rect):

        y = y - 11 * gui.scale
        if self.show == False or self.y != y or x != self.x or self.pl_position != pctl.playlist_view_position:
            self.timer.set()

        if point_proximity_test(self.click_exclude_point, mouse_position, 20 * gui.scale):
            self.timer.set()
            return

        if input.mouse_click:
            self.click_exclude_point = copy.copy(mouse_position)
            self.timer.set()
            return

        self.x = x
        self.y = y
        self.text = text
        self.font = font
        self.show = True
        self.rect = rect
        self.pl_position = pctl.playlist_view_position


    def render(self):

        if not self.show:
            return

        if not point_proximity_test(self.click_exclude_point, mouse_position, 20 * gui.scale):
            self.click_exclude_point = (0, 0)

        if not coll(self.rect) or input.mouse_click or gui.level_2_click or self.pl_position != pctl.playlist_view_position:
            self.show = False

        gui.frame_callback_list.append(TestTimer(0.02))

        if self.timer.get() < 0.6:
            return

        w = ddt.get_text_w(self.text, 312) + self.height
        x = self.x #- int(self.width / 2)
        y = self.y
        h = self.height

        border = 1 * gui.scale

        ddt.rect_r((x - border, y - border, w + border * 2, h + border * 2), colours.grey(60))
        ddt.rect_r((x, y, w, h), colours.menu_background, True)
        p = ddt.draw_text((x + int(w / 2), y + 3 * gui.scale, 2), self.text, colours.message_box_text, 312,
                          bg=colours.menu_background)

        if not coll(self.rect):
            self.show = False

columns_tool_tip = ToolTip3()


# Right click context menu generator

class MenuIcon:

    def __init__(self, asset):

        self.asset = asset
        self.colour = [170, 170, 170, 255]
        self.base_asset = None
        self.base_asset_mod = None
        self.colour_callback = None
        self.mode_callback = None
        self.xoff = 0
        self.yoff = 0


class Menu:
    switch = 0
    count = switch + 1
    instances = []

    def __init__(self, width, show_icons=False):

        self.active = False
        self.clicked = False
        self.pos = [0, 0]
        self.vertical_size = 22 * gui.scale#20
        if gui.scale == 1.25:
            self.vertical_size = 28

        self.h = self.vertical_size
        self.w = width * gui.scale
        if gui.scale == 2:
            self.w += 15
        self.reference = 0
        self.items = []
        self.subs = []
        self.selected = -1
        self.up = False
        self.down = False
        self.font = 412
        self.show_icons = show_icons
        self.sub_arrow = MenuIcon(asset_loader("sub.png", True))

        self.id = Menu.count
        self.break_height = round(4 * gui.scale)

        Menu.count += 1

        self.sub_number = 0
        self.sub_active = -1
        self.sub_y_postion = 0
        Menu.instances.append(self)

    @staticmethod
    def deco(_=_):
        return [colours.menu_text, colours.menu_background, None]

    def click(self):
        self.clicked = True
        # cheap hack to prevent scroll bar from being activated when closing menu
        global click_location
        click_location = [0, 0]

    def add(self, title, func, render_func=None, no_exit=False, pass_ref=False, hint=None, icon=None, show_test=None, pass_ref_deco=False, disable_test=None):
        if render_func is None:
            render_func = self.deco
        self.items.append([title, False, func, render_func, no_exit, pass_ref, hint, icon, show_test, pass_ref_deco, disable_test])

    def br(self):
        self.items.append(None)

    def add_sub(self, title, width):
        self.items.append([title, True, self.sub_number, self.deco, width * gui.scale])
        self.sub_number += 1
        self.subs.append([])

    def add_to_sub(self, title, sub, func, render_func=None, no_exit=False, pass_ref=False, args=None, icon=None, pass_ref_deco=False):
        if render_func is None:
            render_func = self.deco
        item = [title, False, func, render_func, no_exit, pass_ref, args, icon, pass_ref_deco]
        self.subs[sub].append(item)

    def test_item_active(self, item):

        if item[1] is False and item[8] is not None:
            if item[8](1) is False:
                return False
        return True

    def render_icon(self, x, y, icon, selected):

        if colours.lm:
            selected = True

        if icon is not None:

            x += icon.xoff * gui.scale
            y += icon.yoff * gui.scale

            colour = None

            if icon.base_asset is None:
                # Colourise mode

                if icon.colour_callback is not None: #and icon.colour_callback() is not None:
                    colour = icon.colour_callback()

                elif selected:
                    colour = icon.colour


                if colour is None and icon.base_asset_mod:
                    colour = [50, 50, 50, 255]
                    if colours.lm:
                        colour = [160, 160, 160, 255]
                    icon.base_asset_mod.render(x, y, colour)
                    return

                if colour is None:
                    colour = [50, 50, 50, 255]

                icon.asset.render(x, y, colour)

            else:
                # Pre-rendered mode
                if icon.mode_callback is not None:
                    if icon.mode_callback():
                        icon.asset.render(x, y)
                    else:
                        icon.base_asset.render(x, y)
                else:
                    if selected:
                        icon.asset.render(x, y)
                    else:
                        icon.base_asset.render(x, y)

    def render(self):
        if self.active:

            if Menu.switch != self.id:
                self.active = False
                return

            ytoff = 3
            y_run = round(self.pos[1])
            to_call = None

            if window_size[1] < 250 * gui.scale:
                self.h = 14 * gui.scale
                ytoff = -1 * gui.scale
            else:
                self.h = self.vertical_size

            for i in range(len(self.items)):
                # print(self.items[i])
                if self.items[i] is None:


                    ddt.rect_a((self.pos[0], y_run), (self.w, self.break_height),
                              colours.menu_background, True)
                    ddt.rect_a((self.pos[0], y_run + 2 * gui.scale), (self.w, 2 * gui.scale),
                              [255, 255, 255, 13], True)
                    # Draw tab
                    ddt.rect_a((self.pos[0], y_run), (4 * gui.scale, self.break_height),
                              colours.grey(30), True)
                    y_run += self.break_height
                    continue

                if self.test_item_active(self.items[i]) is False:
                    continue
                # if self.items[i][1] is False and self.items[i][8] is not None:
                #     if self.items[i][8](1) == False:
                #         continue

                # Get properties for menu item
                if len(self.items[i]) > 7 and self.items[i][9]:
                    fx = self.items[i][3](self.reference)
                else:
                    fx = self.items[i][3]()

                if fx[2] is not None:
                    label = fx[2]
                else:
                    label = self.items[i][0]

                # Show text as disabled is pass disable test
                if len(self.items[i]) > 7 and self.items[i][10] is not None:
                    if self.items[i][9]:
                        if self.items[i][10](self.reference):
                            fx[0] = colours.menu_text_disabled
                    else:
                        if self.items[i][10]():
                            fx[0] = colours.menu_text_disabled

                # Draw item background, black by default
                ddt.rect_a((self.pos[0], y_run), (self.w, self.h),
                          fx[1], True)
                bg = fx[1]

                # Detect if mouse is over this item
                selected = False
                rect = (self.pos[0], y_run, self.w, self.h - 1)
                fields.add(rect)

                if coll_point(mouse_position,
                              (self.pos[0], y_run, self.w, self.h - 1)):
                    ddt.rect_a((self.pos[0], y_run), (self.w, self.h),
                              colours.menu_highlight_background,
                              True)  # [15, 15, 15, 255]
                    selected = True
                    bg = alpha_blend(colours.menu_highlight_background, bg)

                    # Call menu items callback if clicked
                    if self.clicked:

                        if self.items[i][1] is False:
                            to_call = i

                        else:
                            self.clicked = False
                            self.sub_active = self.items[i][2]
                            self.sub_y_postion = y_run

                # Draw tab
                ddt.rect_a((self.pos[0], y_run), (4 * gui.scale, self.h),
                          colours.grey(30), True)

                # Draw Icon
                x = 12 * gui.scale
                if self.items[i][1] is False and self.show_icons:

                    icon = self.items[i][7]
                    self.render_icon(self.pos[0] + x , y_run + 5 * gui.scale, icon, selected)

                if self.show_icons:
                    x += 25 * gui.scale

                # Draw arrow icon for sub menu
                if self.items[i][1] is True:
                    colour = [50, 50, 50, 255]
                    if selected:
                        colour = [150, 150, 150, 255]
                    if self.sub_active == self.items[i][2]:
                        colour = [150, 150, 150, 255]
                    self.sub_arrow.asset.render(self.pos[0] + self.w - 13 * gui.scale, y_run + 7 * gui.scale, colour)

                # Render the items label
                ddt.draw_text((self.pos[0] + x, y_run + ytoff), label, fx[0], self.font, bg=bg)

                # Render the items hint
                if len(self.items[i]) > 6 and self.items[i][6] != None:
                    colo = alpha_blend([255, 255, 255, 50], bg)
                    ddt.draw_text((self.pos[0] + self.w - 5, y_run + ytoff, 1), self.items[i][6],
                              colo, self.font, bg=bg)

                y_run += self.h

                # Render sub menu if active
                if self.sub_active > -1 and self.items[i][1] and self.sub_active == self.items[i][2]:

                    # sub_pos = [self.pos[0] + self.w, self.pos[1] + i * self.h]
                    sub_pos = [self.pos[0] + self.w, self.sub_y_postion]
                    sub_w = self.items[i][4]
                    fx = self.deco()

                    minY = window_size[1] - self.h * len(self.subs[self.sub_active]) - 15 * gui.scale
                    sub_pos[1] = min(sub_pos[1], minY)

                    xoff = 0
                    for i in self.subs[self.sub_active]:
                        if i[7] is not None:
                            xoff = 24 * gui.scale

                    for w in range(len(self.subs[self.sub_active])):

                        # Get item colours
                        if len(self.subs[self.sub_active][w]) > 5 and self.subs[self.sub_active][w][8]:
                            fx = self.subs[self.sub_active][w][3](self.reference)
                        else:
                            fx = self.subs[self.sub_active][w][3]()

                        # Item background
                        ddt.rect_a((sub_pos[0], sub_pos[1] + w * self.h), (sub_w, self.h), fx[1], True)

                        # Detect if mouse is over this item
                        rect = (sub_pos[0], sub_pos[1] + w * self.h, sub_w, self.h - 1)
                        fields.add(rect)
                        this_select = False
                        bg = colours.menu_background
                        if coll_point(mouse_position,
                                      (sub_pos[0], sub_pos[1] + w * self.h, sub_w, self.h - 1)):
                            ddt.rect_a((sub_pos[0], sub_pos[1] + w * self.h), (sub_w, self.h),
                                      colours.menu_highlight_background,
                                      True)
                            bg = alpha_blend(colours.menu_highlight_background, bg)
                            this_select = True

                            # Call Callback
                            if self.clicked:

                                # If callback needs args
                                if self.subs[self.sub_active][w][6] is not None:
                                    self.subs[self.sub_active][w][2](self.reference, self.subs[self.sub_active][w][6])

                                # If callback just need ref
                                elif self.subs[self.sub_active][w][5]:
                                    self.subs[self.sub_active][w][2](self.reference)

                                else:
                                    self.subs[self.sub_active][w][2]()


                        if fx[2] is not None:
                            label = fx[2]
                        else:
                            label = self.subs[self.sub_active][w][0]

                        # Render sub items icon
                        icon = self.subs[self.sub_active][w][7]
                        self.render_icon(sub_pos[0] + 11 * gui.scale, sub_pos[1] + w * self.h + 5 * gui.scale, icon, this_select)

                        # Render the items label
                        ddt.draw_text((sub_pos[0] + 10 * gui.scale + xoff, sub_pos[1] + ytoff + w * self.h), label, fx[0],
                                  self.font, bg=bg)

                        # Draw tab
                        ddt.rect_a((sub_pos[0], sub_pos[1] + w * self.h), (4 * gui.scale, self.h),
                                  colours.grey(30), True)

                        # Render the menu outline
                        # ddt.rect_a(sub_pos, (sub_w, self.h * len(self.subs[self.sub_active])), colours.grey(40))


            # Process Click Actions
            if to_call is not None:

                if self.items[to_call][5]:
                    self.items[to_call][2](self.reference)
                else:
                    self.items[to_call][2]()


            if self.clicked or key_esc_press:
                self.active = False
                self.clicked = False


                # Render the menu outline
                # ddt.rect_a(self.pos, (self.w, self.h * len(self.items)), colours.grey(40))

    def activate(self, in_reference=0, position=None):

        if position != None:
            self.pos = [position[0], position[1]]
        else:
            self.pos = [copy.deepcopy(mouse_position[0]), copy.deepcopy(mouse_position[1])]

        self.reference = in_reference
        Menu.switch = self.id
        self.sub_active = -1

        # Reposition the menu if it would otherwise intersect with window border
        if self.pos[0] + self.w > window_size[0]:
            self.pos[0] = self.pos[0] - self.w - 3 * gui.scale
        if self.pos[1] + len(self.items) * self.h > window_size[1]:
            #self.pos[1] -= len(self.items) * self.h
            self.pos[0] += 3 * gui.scale
            for i in range(len(self.items)):
                if self.items[i] is None:
                    self.pos[1] -= self.break_height
                elif self.test_item_active(self.items[i]) is False:
                    pass
                else:
                    self.pos[1] -= self.h
            if self.pos[1] < 30 * gui.scale:
                self.pos[1] = 30 * gui.scale
                self.pos[0] += 5 * gui.scale
        self.active = True


def menu_standard_or_grey(bool):
    if bool:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]

# Create empty area menu
playlist_menu = Menu(130)
showcase_menu = Menu(125)
cancel_menu = Menu(100)
gallery_menu = Menu(170, show_icons=True)
artist_info_menu = Menu(135)
queue_menu = Menu(140)
repeat_menu = Menu(120)
shuffle_menu = Menu(120)
artist_list_menu = Menu(150)

def menu_repeat_off():
    pctl.repeat_mode = False
    pctl.album_repeat_mode = False

def menu_set_repeat():
    pctl.repeat_mode = True
    pctl.album_repeat_mode = False

def menu_album_repeat():
    pctl.repeat_mode = True
    pctl.album_repeat_mode = True

repeat_menu.add("Repeat OFF", menu_repeat_off)
repeat_menu.add("Repeat Track", menu_set_repeat)
repeat_menu.add("Repeat Album", menu_album_repeat)


def menu_shuffle_off():
    pctl.random_mode = False
    pctl.album_shuffle_mode = False

def menu_set_random():
    pctl.random_mode = True
    pctl.album_shuffle_mode = False

def menu_album_random():
    pctl.random_mode = True
    pctl.album_shuffle_mode = True

shuffle_menu.add("Shuffle OFF", menu_shuffle_off)
shuffle_menu.add("Shuffle Tracks", menu_set_random)
shuffle_menu.add("Random Albums", menu_album_random)

def bio_set_large():
    if window_size[0] >= round(1000 * gui.scale):
        gui.artist_panel_height = 320 * gui.scale
        if gui.artist_info_panel:
            artist_info_box.get_data(artist_info_box.artist_on)


def bio_set_small():
    gui.artist_panel_height = 200 * gui.scale
    if gui.artist_info_panel:
        artist_info_box.get_data(artist_info_box.artist_on)


def artist_info_panel_close():

    gui.artist_info_panel ^= True
    gui.update_layout()


def toggle_bio_size_deco():
    line = _("Make Large Size")
    if gui.artist_panel_height > 300:
        line = _("Make Compact Size")

    return [colours.menu_text, colours.menu_background, line]


def toggle_bio_size():

    if gui.artist_panel_height > 300:
        bio_set_small()
        prefs.bio_large = False
    else:
        bio_set_large()
        prefs.bio_large = True
    gui.update_layout()

artist_info_menu.add(_("Close Panel"), artist_info_panel_close)
artist_info_menu.add(_("Make Large"), toggle_bio_size, toggle_bio_size_deco)


def show_in_playlist():


    pctl.playlist_view_position = playlist_selected
    shift_selection.clear()
    shift_selection.append(playlist_selected)
    pctl.render_playlist()


folder_icon = MenuIcon(asset_loader('folder.png', True))
info_icon = MenuIcon(asset_loader('info.png', True))

folder_icon.colour = [244, 220, 66, 255]
info_icon.colour = [61, 247, 163, 255]


def open_folder(index):
    if system == 'windows':
        line = r'explorer /select,"%s"' % (
            pctl.master_library[index].fullpath.replace("/", "\\"))
        subprocess.Popen(line)
    else:
        line = pctl.master_library[index].parent_folder_path
        line += "/"
        if system == 'mac':
            subprocess.Popen(['open', line])
        else:
            subprocess.Popen(['xdg-open', line])

gallery_menu.add(_('Open Folder'), open_folder, pass_ref=True, icon=folder_icon)
gallery_menu.add(_("Show in Playlist"), show_in_playlist)


def finish_current():

    playing_object = pctl.playing_object()
    if playing_object is None:
        show_message("")

    if not pctl.force_queue:

        pctl.force_queue.insert(0, queue_item_gen(playing_object.index,
                                    pctl.playlist_playing_position, pl_to_id(pctl.active_playlist_playing), 1, 1))



def add_album_to_queue(ref, position=None):

    # if prefs.finish_current:
    #     finish_current()
    if position is None:
        position = r_menu_position

    partway = 0
    playing_object = pctl.playing_object()
    if not pctl.force_queue and playing_object is not None:
        if pctl.g(ref).parent_folder_path == playing_object.parent_folder_path:
            partway = 1

    # pctl.force_queue.append([ref,
    #                          position, pl_to_id(pctl.active_playlist_viewing), 1, partway, uid_gen()])
    pctl.force_queue.append(queue_item_gen(ref,
                             position, pl_to_id(pctl.active_playlist_viewing), 1, partway))

gallery_menu.add(_("Add Album to Queue"), add_album_to_queue, pass_ref=True)


def add_album_to_queue_fc(ref):

    playing_object = pctl.playing_object()
    if playing_object is None:
        show_message("")

    if not pctl.force_queue:
        pctl.force_queue.insert(0, queue_item_gen(playing_object.index,
                                    pctl.playlist_playing_position, pl_to_id(pctl.active_playlist_playing), 1, 1))
        add_album_to_queue(ref)
        return

    if pctl.force_queue[0][4] == 1:
        pctl.force_queue.insert(1, queue_item_gen(ref,
                                    pctl.playlist_playing_position, pl_to_id(pctl.active_playlist_playing), 1, 0))
    else:
        pctl.force_queue.insert(0, queue_item_gen(ref,
                                    pctl.playlist_playing_position, pl_to_id(pctl.active_playlist_playing), 1, 0,))


def cancel_import():

    if transcode_list:
        del transcode_list[1:]
        gui.tc_cancel = True
    if loading_in_progress:
        gui.im_cancel = True


cancel_menu.add("Cancel", cancel_import)


def toggle_lyrics_show(a):
    return not gui.combo_mode


def toggle_side_art_deco():
    colour = colours.menu_text
    if prefs.show_side_art:
        line = "Hide Art box"
    else:
        line = "Show Art Box"
    # if pctl.playing_object().lyrics == "":
    #     colour = colours.menu_text_disabled

    return [colour, colours.menu_background, line]


def toggle_side_art(track_object):
    prefs.show_side_art ^= True


showcase_menu.add(_('Toggle art box'), toggle_side_art, toggle_side_art_deco, pass_ref=True,
                  show_test=toggle_lyrics_show)




def toggle_lyrics_deco():

    if gui.combo_mode:

        colour = colours.menu_text
        if prefs.show_lyrics_showcase:
            line = "Hide lyrics"
        else:
            line = "Show lyrics"
        if pctl.playing_object().lyrics == "":
            colour = colours.menu_text_disabled

    else:

        colour = colours.menu_text
        if prefs.show_lyrics_side:
            line = "Hide lyrics"
        else:
            line = "Show lyrics"
        if pctl.playing_object().lyrics == "":
            colour = colours.menu_text_disabled

    return [colour, colours.menu_background, line]

def toggle_lyrics(track_object):

    if gui.combo_mode:
        prefs.show_lyrics_showcase ^= True
        if prefs.show_lyrics_showcase and track_object.lyrics == "":
            show_message("No lyrics for this track")
    else:

        prefs.show_lyrics_side ^= True
        if prefs.show_lyrics_side and track_object.lyrics == "":
            show_message("No lyrics for this track")

showcase_menu.add(_('Toggle Lyrics'), toggle_lyrics, toggle_lyrics_deco, pass_ref=True)


def get_lyric_fire(track_object, silent=False):

    if not prefs.lyrics_enables:
        if not silent:
            show_message(_("There are no lyric sources enabled."), 'info',
                           "See 'lyrics settings' under 'functions' tab in settings.")
        return

    t = lyrics_fetch_timer.get()
    print("Lyric rate limit timer is: " + str(t) + " / -60")
    if t < -40:
        print("Lets try again later")
        if not silent:
            show_message(_("Let's be polite and try later."))

            if t < -65:
                show_message("Stop requesting lyrics AAAAAA.", 'error')

        # If the user keeps pressing, lets mess with them haha
        lyrics_fetch_timer.force_set(t - 5)

        return 'later'

    if t > 0:
        lyrics_fetch_timer.set()
        t = 0

    lyrics_fetch_timer.force_set(t - 20)

    if not silent:
        show_message(_("Searching..."))

    found = False
    for source in prefs.lyrics_enables:

        if source == 'lyricwiki':

            print("Query Lyric Wiki...")
            try:

                lyrics = PyLyrics.getLyrics(track_object.artist, track_object.title)

                if lyrics and lyrics[0] == "<" and "Instrumental" in lyrics:
                    lyrics = "[Instrumental]"

                track_object.lyrics = lyrics

                found = True
                print("Found")
                break

            except:
                if not silent:
                    print("LyricWiki does not appear to have lyrics for this song")
                continue

        if source == 'apiseeds':

            print("Query Apiseeds...")
            try:

                point = 'https://orion.apiseeds.com/api/music/lyric/' + urllib.parse.quote(track_object.artist) + \
                    "/" + urllib.parse.quote(track_object.title) + "?apikey=" + prefs.apsed_ke

                r = requests.get(point)
                d = r.json()['result']['track']['text'].replace("\r\n", "\n")

                track_object.lyrics = d

                print("Found")
                found = True
                break

            except:
                if not silent:
                    print("Apiseeds does not appear to have lyrics for this song")
                continue

    if not found:
        print("no lyrics found")
        if not silent:
            show_message("No lyrics for this track were found")
    else:
        gui.message_box = False
        if not gui.showcase_mode:
            prefs.show_lyrics_side = True
        gui.update += 1
        lyrics_ren.lyrics_position = 0


def get_lyric_wiki(track_object):

    if track_object.artist == "" or track_object.title == "":
        show_message("Insufficient metadata to get lyrics", 'warning')
        return

    shoot_dl = threading.Thread(target=get_lyric_fire, args=([track_object]))
    shoot_dl.daemon = True
    shoot_dl.start()

    print("..Done")

def get_lyric_wiki_silent(track_object):

    print("Searching for lyrics...")

    if track_object.artist == "" or track_object.title == "":
        return

    shoot_dl = threading.Thread(target=get_lyric_fire, args=([track_object, True]))
    shoot_dl.daemon = True
    shoot_dl.start()

    print("..Done")

def test_auto_lyrics(track_object):

    if prefs.auto_lyrics and not track_object.lyrics and track_object.index not in prefs.auto_lyrics_checked:
        if lyrics_check_timer.get() > 5 and pctl.playing_time > 1:
            result = get_lyric_wiki_silent(track_object)
            if result == "later":
                pass
            else:
                lyrics_check_timer.set()
                prefs.auto_lyrics_checked.append(track_object.index)


def get_bio(track_object):

    if track_object.artist != "":
        lastfm.get_bio(track_object.artist)


showcase_menu.add(_('Search Lyrics'), get_lyric_wiki, pass_ref=True)


def search_guitarparty(track_object):
    if not track_object.title:
        show_message("Insufitent metadata to search")
    gc.fetch(track_object)

def search_guitarparty_showtest(_):
    return gui.combo_mode and prefs.guitar_chords

showcase_menu.add(_('Search GuitarParty'), search_guitarparty, pass_ref=True, show_test=search_guitarparty_showtest)


def paste_lyrics_deco():

    if SDL_HasClipboardText():
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]

def paste_lyrics(track_object):

    if SDL_HasClipboardText():
        clip = SDL_GetClipboardText()
        #print(clip)
        track_object.lyrics = clip.decode('utf-8')

    else:
        print('NO TEXT TO PASTE')


def paste_chord_lyrics(track_object):
    if track_object.title:
        gc.save_format_b(track_object)

def chord_lyrics_paste_show_test(_):

    return gui.combo_mode and prefs.guitar_chords

def clear_chord_lyrics(track_object):
    if track_object.title:
        gc.clear(track_object)

showcase_menu.add(_('Paste Chord Lyrics'), paste_chord_lyrics, pass_ref=True, show_test=chord_lyrics_paste_show_test)
showcase_menu.add(_('Clear Chord Lyrics'), clear_chord_lyrics, pass_ref=True, show_test=chord_lyrics_paste_show_test)

showcase_menu.add(_('Paste Lyrics'), paste_lyrics, paste_lyrics_deco, pass_ref=True)

def copy_lyrics_deco():

    if gui.force_showcase_index >= 0:
        index = gui.force_showcase_index
        track = pctl.master_library[index]
    else:
        index = pctl.track_queue[pctl.queue_step]
        track = pctl.master_library[pctl.track_queue[pctl.queue_step]]

    if len(track.lyrics) > 0:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]

def copy_lyrics(track_object):
    copy_to_clipboard(track_object.lyrics)

showcase_menu.add(_('Copy Lyrics'), copy_lyrics, copy_lyrics_deco, pass_ref=True)



def clear_lyrics(track_object):
    track_object.lyrics = ""

def clear_lyrics_deco():

    if gui.force_showcase_index >= 0:
        index = gui.force_showcase_index
        track = pctl.master_library[index]
    else:
        index = pctl.track_queue[pctl.queue_step]
        track = pctl.master_library[pctl.track_queue[pctl.queue_step]]


    if track.lyrics != "":
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]

def split_lyrics(track_object):


    if track_object.lyrics != "":
        track_object.lyrics = track_object.lyrics.replace(". ", ". \n")
    else:
        pass


showcase_menu.add(_('Clear Lyrics'), clear_lyrics, clear_lyrics_deco, pass_ref=True)
showcase_menu.add(_('Split Lines'), split_lyrics, clear_lyrics_deco, pass_ref=True)


def save_embed_img():
    index = pctl.track_queue[pctl.queue_step]
    filepath = pctl.master_library[index].fullpath
    folder = pctl.master_library[index].parent_folder_path
    ext = pctl.master_library[index].file_ext

    try:
        if ext == 'MP3':
            tag = stagger.read_tag(filepath)
            try:
                tt = tag[APIC][0]
            except:
                try:
                    tt = tag[PIC][0]
                except:
                    show_message("Image save error.", 'warning', "No embedded album art found in MP3 file")
                    return
            pic = tt.data

        elif ext in ('FLAC', 'APE', 'TTA', 'WV'):

            tt = Flac(filepath)
            tt.read(True)
            if tt.has_picture is False:
                show_message("Image save error.", 'warning', "No embedded album art found in FLAC file")
                return
            pic = tt.picture

        elif ext == 'M4A':
            tt = M4a(filepath)
            tt.read(True)
            if tt.has_picture is False:
                show_message("Image save error.", 'warning', "No embedded album art found in M4A file")
                return
            pic = tt.picture

        source_image = io.BytesIO(pic)
        im = Image.open(source_image)
        print(im.format)
        # im.format
        source_image.close()

        ext = "." + im.format.lower()
        if im.format == "JPEG":
            ext = ".jpg"

        target = os.path.join(folder, "embed-" + str(im.height) + "px-" + str(index) + ext)
        if len(pic) > 30:
            with open(target, 'wb') as w:
                w.write(pic)
        open_folder(index)


    except:
        show_message("Image save error.", "error", "A mysterious error occurred")

picture_menu = Menu(170)

def open_image_deco():

    info = album_art_gen.get_info(pctl.track_queue[pctl.queue_step])

    if info is None:
        return [colours.menu_text_disabled, colours.menu_background, None]

    if pctl.playing_state > 0 and info[0] == 0:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]

def open_image():

    if pctl.playing_state > 0 and pctl.track_queue:
        album_art_gen.open_external(pctl.track_queue[pctl.queue_step])

def extract_image_deco():

    info = album_art_gen.get_info(pctl.track_queue[pctl.queue_step])

    if info is None:
        return [colours.menu_text_disabled, colours.menu_background, None]

    if pctl.playing_state > 0 and info[0] == 1:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]


picture_menu.add(_("Open Image"), open_image, open_image_deco)


def cycle_image_deco():

    info = album_art_gen.get_info(pctl.track_queue[pctl.queue_step])

    if pctl.playing_state != 0 and (info is not None and info[1] > 1):
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]


def cycle_offset():
    album_art_gen.cycle_offset(pctl.track_queue[pctl.queue_step])


def cycle_offset_b():
    album_art_gen.cycle_offset_reverse(pctl.track_queue[pctl.queue_step])

# Next and previous pictures
picture_menu.add(_("Next"), cycle_offset, cycle_image_deco)
picture_menu.add(_("Previous"), cycle_offset_b, cycle_image_deco)

# Extract embedded artwork from file
picture_menu.add(_('Extract Image'), save_embed_img, extract_image_deco)


def dl_art_deco(index):

    tr = pctl.master_library[index]
    if pctl.playing_state == 0 or not tr.album or not tr.artist:
        return [colours.menu_text_disabled, colours.menu_background, None]
    return [colours.menu_text, colours.menu_background, None]


def remove_embed_deco():
    info = album_art_gen.get_info(pctl.track_queue[pctl.queue_step])

    if info is None:
        return [colours.menu_text_disabled, colours.menu_background, None]

    if pctl.playing_state > 0 and info[0] == 1 and (pctl.playing_object().file_ext == "MP3" or pctl.playing_object().file_ext == "FLAC"):
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    text = _("Delete Embedded | Folder")
    if key_shift_down or key_shiftr_down:
        text = _("Delete Embedded | Track")

    return [line_colour, colours.menu_background, text]


def download_art1(index):

    tr = pctl.master_library[index]

    if tr.is_network:
        show_message("Cannot download art for network tracks.")
        return

    if not os.path.isdir(tr.parent_folder_path):
        show_message("Directroy missing.")
        return

    try:
        show_message("Looking up MusicBrainz ID...")
        if 'musicbrainz_releasegroupid' not in tr.misc or 'musicbrainz_artistids' not in tr.misc or not tr.misc['musicbrainz_artistids']:

            print("MusicBrainz ID lookup...")

            artist = tr.album_artist
            if not tr.album:
                return
            if not artist:
                artist = tr.artist

            s = musicbrainzngs.search_release_groups(tr.album, artist=artist, limit=1)

            album_id = s['release-group-list'][0]['id']
            artist_id = s['release-group-list'][0]['artist-credit'][0]['artist']['id']

            print("Found release group ID: " + album_id)
            print("Found artist ID: " + artist_id)

        else:

            album_id = tr.misc['musicbrainz_releasegroupid']
            artist_id = tr.misc['musicbrainz_artistids'][0]

            print("Using tagged release group ID: " + album_id)
            print("Using tagged artist ID: " + artist_id)

        try:
            show_message("Searching fanart.tv for cover art...")

            r = requests.get("http://webservice.fanart.tv/v3/music/albums/" \
                             + artist_id + "?api_key=" + prefs.fatvap)

            artlink = r.json()['albums'][album_id]['albumcover'][0]['url']
            id = r.json()['albums'][album_id]['albumcover'][0]['id']

            response = urllib.request.urlopen(artlink)
            info = response.info()

            t = io.BytesIO()
            t.seek(0)
            t.write(response.read())
            l = 0
            t.seek(0, 2)
            l = t.tell()
            t.seek(0)

            if info.get_content_maintype() == 'image' and l > 1000:

                if info.get_content_subtype() == 'jpeg':
                    filepath = os.path.join(tr.parent_folder_path, "cover-" + id + ".jpg")
                elif info.get_content_subtype() == 'png':
                    filepath = os.path.join(tr.parent_folder_path, "cover-" + id + ".png")
                else:
                    show_message("Could not detect downloaded filetype.", 'error')
                    return

                f = open(filepath, 'wb')
                f.write(t.read())
                f.close()

                show_message("Cover art downloaded from fanart.tv", 'done')
                clear_img_cache()
                return
        except:
            print("Failed to get from fanart.tv")

        show_message("Searching MusicBrainz for cover art...")
        t = io.BytesIO(musicbrainzngs.get_release_group_image_front(album_id, size=None))
        l = 0
        t.seek(0, 2)
        l = t.tell()
        t.seek(0)
        if l > 1000:
            filepath = os.path.join(tr.parent_folder_path, album_id + ".jpg")
            f = open(filepath, 'wb')
            f.write(t.read())
            f.close()

            show_message("Cover art downloaded from MusicBrainz", 'done')
            clear_img_cache()
            return

    except:
        show_message("Matching cover art or ID could not be found.")

def download_art1_fire(index):

    shoot_dl = threading.Thread(target=download_art1, args=[index])
    shoot_dl.daemon = True
    shoot_dl.start()


def remove_embed_picture(index):


    if key_shift_down or key_shiftr_down:
        tracks = [index]
        if pctl.g(index).is_cue or pctl.g(index).is_network:
            show_message("Error - No handling for this kind of track", 'warning')
            return
    else:
        tracks = []
        original_parent_folder = pctl.master_library[index].parent_folder_name
        for k in default_playlist:
            tr = pctl.g(k)
            if original_parent_folder == tr.parent_folder_name:
                tracks.append(k)

    removed = 0
    pr = pctl.stop(True)
    processed = False
    try:
        for item in tracks:

            tr = pctl.g(item)

            if tr.is_cue:
                continue

            if tr.is_network:
                continue

            if "MP3" == tr.file_ext:
                tag = stagger.read_tag(tr.fullpath)
                remove = False
                try:
                    del tag[APIC]
                    print("Delete APIC successful")
                    remove = True
                except:
                    print("No APIC found")

                try:
                    del tag[PIC]
                    print("Delete PIC successful")
                    remove = True
                except:
                    print("No PIC found")

                if remove is True:
                    tag.write()
                    removed += 1

            if "FLAC" == tr.file_ext:

                if flatpak_mode:
                    print("Finding app from within Flatpak...")
                    complete = subprocess.run(shlex.split("flatpak-spawn --host which metaflac"),
                                              stdout=subprocess.PIPE,
                                              stderr=subprocess.PIPE)

                    r = complete.stdout.decode()

                    if "/metaflac" in r:

                        command = 'flatpak-spawn --host metaflac --remove --block-type=PICTURE "' \
                                  + tr.fullpath.replace('"', '\\"') + '"'

                    else:
                        show_message("Please install Flac on your host system for this.", 'info', "e.g. sudo apt install flac")


                else:
                    command = 'metaflac --remove --block-type=PICTURE "' \
                              + tr.fullpath.replace('"', '\\"') + '"'

                subprocess.call(shlex.split(command), stdout=subprocess.PIPE, shell=False)
                removed += 1
                processed = True

    except Exception as e:
        show_message("Image remove error", 'error')
        return

    if removed == 0:
        show_message(_("Image removal failed."), "error")
        return
    elif removed == 1:
        if processed:
            show_message(_("Processed one FLAC files"), 'done')
        else:
            show_message(_("Deleted embedded picture from file"), 'done')
    else:
        if processed:
            show_message("Processed " + str(removed) + " files", 'done')
        else:
            show_message("Deleted embedded picture from " + str(removed) + " files", 'done')
    if pr == 1:
        pctl.revert()
    clear_img_cache()

# Delete all embedded album artwork from all files in the same folder as this track
picture_menu.add('Delete Embedded | Folder', remove_embed_picture, remove_embed_deco, pass_ref=True)

delete_icon = MenuIcon(asset_loader('del.png', True))

def test_shift(_):
    return key_shift_down or key_shiftr_down

def delete_file_image_deco(tid):

    info = album_art_gen.get_info(tid)
    if pctl.playing_state > 0 and info and info[0] == 0:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]

def delete_file_image(tid):

    try:
        tid = pctl.track_queue[pctl.queue_step]
        showc = album_art_gen.get_info(tid)
        if showc is not None and showc[0] == 0:
            source = album_art_gen.get_sources(tid)[showc[2]][1]
            os.remove(source)
            clear_img_cache()
            print("Deleted file: " + source)
    except:
        show_message("Something went wrong", 'error')


picture_menu.add(_('Delete Image File'), delete_file_image, delete_file_image_deco, pass_ref=True, pass_ref_deco=True, icon=delete_icon)

picture_menu.add(_('Quick-Fetch Cover Art'), download_art1_fire, dl_art_deco, pass_ref=True, pass_ref_deco=True)


def toggle_gimage(mode=0):
    if mode == 1:
        return prefs.show_gimage
    prefs.show_gimage ^= True


def search_image_deco():

    if pctl.playing_state > 0:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]

def ser_gimage(index):
    track = pctl.master_library[index]
    line = "https://www.google.com/search?tbm=isch&q=" + urllib.parse.quote(track.artist + " " + track.album)
    webbrowser.open(line, new=2, autoraise=True)

picture_menu.add(_('Search Google for Images'), ser_gimage, search_image_deco, pass_ref=True, show_test=toggle_gimage)


def append_here():
    global cargo
    global default_playlist
    default_playlist += cargo


def paste_deco():

    if len(cargo) > 0:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]


def lightning_move_test(discard):
    return gui.lightning_copy and prefs.show_transfer



def copy_deco():
    line = "Copy"
    if key_shift_down:
        line = "Copy" #Folder From Library"
    else:
        line = "Copy"


    return [colours.menu_text, colours.menu_background, line]


#playlist_menu.add('Paste', append_here, paste_deco)

def unique_template(string):

    return "<t>" in string or \
        "<title>" in string or \
        "<n>" in string or \
        "<number>" in string or \
        "<tracknumber>" in string or \
        "<tn>" in string or \
        "<sn>" in string or \
        "<singlenumber>" in string or \
        "<s>" in string or "%t" in string or "%tn" in string

def re_template_word(word, tr):

    if word == "aa" or word == "albumartist":

        if tr.album_artist:
            return tr.album_artist
        else:
            return tr.artist

    if word == "a" or word == "artist":
        return tr.artist

    if word == "t" or word == "title":
        return tr.title

    if word == "n" or word == "number" or word == "tracknumber" or word == "tn":
        if len(str(tr.track_number)) < 2:
            return "0" + str(tr.track_number)
        else:
            return str(tr.track_number)

    if word == "sn" or word == "singlenumber" or word == "singletracknumber" or word == "s":
        return str(tr.track_number)

    if word == "d" or word == "date" or word == "year":
        return str(tr.date)

    if word == "b" or "album" in word:
        return str(tr.album)

    if word == "g" or word == "genre":
        return tr.genre

    if word == "x" or "ext" in word or "file" in word:
        return tr.file_ext.lower()

    if word == "ux" or "upper" in word:
        return tr.file_ext.upper()

    return ""


def parse_template2(string, track_object, strict=False):

    temp = ""
    out = ""

    mode = 0

    for c in string:

        if mode == 0:

            if c == "<":
                mode = 1
            else:
                out += c

        else:

            if c == ">":

                test = re_template_word(temp, track_object)
                if strict:
                    assert test
                out += test

                mode = 0
                temp = ""

            else:

                temp += c

    if "<und" in string:
        out = out.replace(" ", "_")

    return parse_template(out, track_object, strict=strict)

def parse_template(string, track_object, up_ext=False, strict=False):
    set = 0
    underscore = False
    output = ""

    while set < len(string):
        if string[set] == "%" and set < len(string) - 1:
            set += 1
            if string[set] == 'n':
                if len(str(track_object.track_number)) < 2:
                    output += "0"
                if strict:
                    assert str(track_object.track_number)
                output += str(track_object.track_number)
            elif string[set] == 'a':
                if up_ext and track_object.album_artist != "": # Context of renaming a folder
                    output += track_object.album_artist
                else:
                    if strict:
                        assert track_object.artist
                    output += track_object.artist
            elif string[set] == 't':
                if strict:
                    assert track_object.title
                output += track_object.title
            elif string[set] == 'd':
                if strict:
                    assert track_object.date
                output += track_object.date
            elif string[set] == 'b':
                if strict:
                    assert track_object.album
                output += track_object.album
            elif string[set] == 'x':
                if up_ext:
                    output += track_object.file_ext.upper()
                else:
                    output += "." + track_object.file_ext.lower()
            elif string[set] == 'u':
                underscore = True
        else:
            output += string[set]
        set += 1

    output = output.rstrip(" -").lstrip(" -")

    if underscore:
        output = output.replace(' ', "_")

    # Attempt to ensure the output text is filename safe
    for char in output:
        if char in '\\/:*?"<>|':
            output = output.replace(char, '')

    return output

# Create playlist tab menu
tab_menu = Menu(160, show_icons=True)


def rename_playlist(index):

    gui.rename_playlist_box = True
    rename_box.playlist_index = index
    rename_box.x = mouse_position[0]
    rename_box.y = mouse_position[1]

    if rename_box.y < gui.panelY:
        rename_box.y = gui.panelY + 10 * gui.scale

    rename_text_area.set_text(pctl.multi_playlist[index][0])
    rename_text_area.highlight_all()





tab_menu.add(_('Rename'), rename_playlist, pass_ref=True, hint="Ctrl+R")


def pl_lock_deco(pl):

    if pctl.multi_playlist[pl][9] == True:
        return [colours.menu_text, colours.menu_background, "Unlock"]
    else:
        return [colours.menu_text, colours.menu_background, 'Lock']


def view_pl_is_locked(_):
    return pctl.multi_playlist[pctl.active_playlist_viewing][9]


def pl_is_locked(pl):
    if not pctl.multi_playlist:
        return False
    return pctl.multi_playlist[pl][9]

def lock_playlist_toggle(pl):
    pctl.multi_playlist[pl][9] ^= True


def lock_colour_callback():
    if pctl.multi_playlist[gui.tab_menu_pl][9]:
        if colours.lm:
            return [230, 180, 60, 255]
        return [240, 190, 10, 255]
    else:
        return None

lock_icon = MenuIcon(asset_loader('lock.png', True))
lock_icon.base_asset_mod = asset_loader('unlock.png', True)
lock_icon.colour = [240, 190, 10, 255]
lock_icon.colour_callback = lock_colour_callback
lock_icon.xoff = 4
lock_icon.yoff = -1



tab_menu.add(_('Lock'), lock_playlist_toggle, pl_lock_deco, pass_ref=True, pass_ref_deco=True, icon=lock_icon)


def export_xspf(pl):
    if len(pctl.multi_playlist[pl][2]) < 1:
        show_message("There are no tracks in this playlist. Nothing to export")
        return

    direc = os.path.join(user_directory, 'playlists')
    if not os.path.exists(direc):
        os.makedirs(direc)
    target = os.path.join(direc, pctl.multi_playlist[pl][0] + '.xspf')

    xport = open(target, 'w', encoding='utf-8')
    xport.write('<?xml version="1.0" encoding="UTF-8"?>\n')
    xport.write('<playlist version="1" xmlns="http://xspf.org/ns/0/">\n')
    xport.write('  <trackList>\n')

    for number in pctl.multi_playlist[pl][2]:
        track = pctl.master_library[number]
        xport.write('    <track>\n')
        if track.title != "":
            xport.write('      <title>' + escape(track.title) + '</title>\n')
        if track.is_cue is False and track.fullpath != "":
            xport.write('      <location>' + escape(track.fullpath) + '</location>\n')
        if track.artist != "":
            xport.write('      <creator>' + escape(track.artist) + '</creator>\n')
        if track.album != "":
            xport.write('      <album>' + escape(track.album) + '</album>\n')
        xport.write('      <duration>' + str(track.length * 1000) + '</duration>\n')
        xport.write('    </track>\n')
    xport.write('  </trackList>\n')
    xport.write('</playlist>\n\n')
    xport.close()

    line = direc
    line += "/"
    if system == 'mac':
        subprocess.Popen(['open', line])
    else:
        subprocess.Popen(['xdg-open', line])


def reload():
    if album_mode:
        reload_albums(quiet=True)
    # elif gui.combo_mode:
    #     reload_albums(quiet=True)
    #     combo_pl_render.prep()


def clear_playlist(index):
    global default_playlist

    if pl_is_locked(index):
        show_message("Playlist is locked to prevent accidental erasure")
        return

    #pctl.playlist_backup.append(copy.deepcopy(pctl.multi_playlist[index]))
    #undo.bk_playlist(index)
    if not pctl.multi_playlist[index][2]:
        print("Playlist is already empty")
        return

    li = []
    for i, ref in enumerate(pctl.multi_playlist[index][2]):
        li.append((i, ref))

    undo.bk_tracks(index, list(reversed(li)))

    del pctl.multi_playlist[index][2][:]
    if pctl.active_playlist_viewing == index:
        default_playlist = pctl.multi_playlist[index][2]
        reload()

    # pctl.playlist_playing = 0
    pctl.multi_playlist[index][3] = 0

    gui.pl_update = 1


def convert_playlist(pl):
    global transcode_list

    if system == 'windows':
        if not os.path.isfile(user_directory + '/encoder/ffmpeg.exe'):
            show_message("Error: Missing ffmpeg.exe from '/encoder' directory")
            return
        # if prefs.transcode_codec == 'mp3' and not os.path.isfile(user_directory + '/encoder/lame.exe'):
        #     show_message("Error: Missing lame.exe from '/encoder' directory")
        #     return
    else:
        if shutil.which('ffmpeg') is None:
            show_message("Error: ffmpeg does not appear to be installed")
            return
        # if prefs.transcode_codec == 'mp3' and shutil.which('lame') is None:
        #     show_message("Error: LAME does not appear to be installed")
        #     return

    paths = []

    for track in pctl.multi_playlist[pl][2]:
        if pctl.master_library[track].parent_folder_path not in paths:
            paths.append(pctl.master_library[track].parent_folder_path)

    for path in paths:
        folder = []
        for track in pctl.multi_playlist[pl][2]:
            if pctl.master_library[track].parent_folder_path == path:
                folder.append(track)
                if prefs.transcode_codec == 'flac' and pctl.master_library[track].file_ext.lower() in ('mp3', 'opus',
                                                                                                       'm4a', 'mp4',
                                                                                                     'ogg', 'aac'):
                    show_message("This includes the conversion of a lossy codec to a lossless one!")

        transcode_list.append(folder)
        print(transcode_list)


def get_folder_tracks_local(pl_in):
    selection = []
    parent = os.path.normpath(pctl.master_library[default_playlist[pl_in]].parent_folder_path)
    while pl_in < len(default_playlist) and parent == os.path.normpath(pctl.master_library[default_playlist[pl_in]].parent_folder_path):
        selection.append(pl_in)
        pl_in += 1
    return selection


def test_pl_tab_locked(pl):
    return pctl.multi_playlist[pl][9]


# Clear playlist
tab_menu.add(_('Clear'), clear_playlist, pass_ref=True, disable_test=test_pl_tab_locked, pass_ref_deco=True)


def move_playlist(source, dest):
    global default_playlist
    if dest > source:
        dest += 1

    active = pctl.multi_playlist[pctl.active_playlist_playing]
    view = pctl.multi_playlist[pctl.active_playlist_viewing]

    temp = pctl.multi_playlist[source]
    pctl.multi_playlist[source] = "old"
    pctl.multi_playlist.insert(dest, temp)
    pctl.multi_playlist.remove("old")

    pctl.active_playlist_playing = pctl.multi_playlist.index(active)
    pctl.active_playlist_viewing = pctl.multi_playlist.index(view)
    default_playlist = default_playlist = pctl.multi_playlist[pctl.active_playlist_viewing][2]


def delete_playlist(index):
    global default_playlist

    if pl_is_locked(index):
        show_message("Playlist is locked to prevent accidental deletion")
        return

    if gui.rename_playlist_box:
        return

    # Set screen to be redwarn
    gui.pl_update = 1
    gui.update += 1

    # Backup the playlist to be deleted
    #pctl.playlist_backup.append(pctl.multi_playlist[index])
    #pctl.playlist_backup.append(pctl.multi_playlist[index])
    undo.bk_playlist(index)

    # If we're deleting the final playlist, delete it and create a blank one in place
    if len(pctl.multi_playlist) == 1:
        pctl.multi_playlist.clear()
        pctl.multi_playlist.append(pl_gen())
        default_playlist = pctl.multi_playlist[0][2]
        pctl.active_playlist_playing = 0
        return

    # Take note of the id of the playing playlist
    old_playing_id = pctl.multi_playlist[pctl.active_playlist_playing][6]

    # Take note of the id of the viewed open playlist
    old_view_id = pctl.multi_playlist[pctl.active_playlist_viewing][6]

    # Delete the requested playlist
    del pctl.multi_playlist[index]


    # Re-set the open viewed playlist number by uid
    for i, pl in enumerate(pctl.multi_playlist):

        if pl[6] == old_view_id:
            pctl.active_playlist_viewing = i
            break
    else:
        print("Lost the viewed playlist!")
        # Try find the playing playlist and make it the viewed playlist
        for i, pl in enumerate(pctl.multi_playlist):
            if pl[6] == old_playing_id:
                pctl.active_playlist_viewing = i
                break
        else:
            # Playing playlist was deleted, lets just move down one playlist
            if pctl.active_playlist_viewing > 0:
                pctl.active_playlist_viewing -= 1

    # Re-initiate the now viewed playlist
    if old_view_id != pctl.multi_playlist[pctl.active_playlist_viewing][6]:
        default_playlist = pctl.multi_playlist[pctl.active_playlist_viewing][2]
        pctl.playlist_view_position = pctl.multi_playlist[pctl.active_playlist_viewing][3]
        playlist_selected = pctl.multi_playlist[pctl.active_playlist_viewing][5]
        shift_selection = [playlist_selected]

    if album_mode:
        reload_albums(True)
        goto_album(pctl.playlist_view_position)

    # Re-set the playing playlist number by uid
    for i, pl in enumerate(pctl.multi_playlist):

        if pl[6] == old_playing_id:
            pctl.active_playlist_playing = i
            break
    else:
        print("Lost the playing playlist!")
        pctl.active_playlist_playing = pctl.active_playlist_viewing
        pctl.playlist_playing_position = -1

    reload()
    test_show_add_home_music()


to_scan = []

def rescan_tags(pl):

    for track in pctl.multi_playlist[pl][2]:
        if pctl.master_library[track].is_cue is False:
            to_scan.append(track)


def re_import(pl):

    path = pctl.multi_playlist[pl][7]
    if path == "":
        return
    for i in reversed(range(len(pctl.multi_playlist[pl][2]))):
        if path.replace('\\', '/') in pctl.master_library[pctl.multi_playlist[pl][2][i]].parent_folder_path:
            del pctl.multi_playlist[pl][2][i]

    load_order = LoadClass()
    load_order.replace_stem = True
    load_order.target = path
    load_order.playlist = pctl.multi_playlist[pl][6]
    load_orders.append(copy.deepcopy(load_order))


def re_import2(pl):

    path = pctl.multi_playlist[pl][7]
    if path == "":
        return
    load_order = LoadClass()
    load_order.replace_stem = True
    load_order.target = path
    load_order.notify = True
    load_order.playlist = pctl.multi_playlist[pl][6]
    load_orders.append(copy.deepcopy(load_order))
    show_message("Rescanning folder...", 'info', path)

def s_append(index):
    paste(playlist=index)


def append_playlist(index):

    global cargo
    pctl.multi_playlist[index][2] += cargo

    gui.pl_update = 1
    reload()


def tryint(s):
    try:
        return int(s)
    except:
        return s

def index_key(index):
    s = str(pctl.master_library[index].track_number)
    d = str(pctl.master_library[index].disc_number)

    # Make sure the value for disc number is an interger, make 1 if 0, otherwise ignore
    if d:
        try:
            dd = int(d)
            if dd < 2:
                dd = 1
            d = str(dd)
        except:
            d = ""

    # Add the disc number for sorting by CD, make it '1' if theres isnt one
    if s or d:
        if not d:
            s = "1" + "d" + s
        else:
            s = d + "d" + s

    # Use the filename if we dont have any metadata to sort by,
    # since it could likely have the track number in it
    else:
        s = pctl.master_library[index].filename

    # This splits the line by groups of numbers, causing the sorting algorithum to sort
    # by those numbers. Should work for filenames, even with the disc number in the name.
    try:
        return [tryint(c) for c in re.split('([0-9]+)', s)]
    except:
        return "a"


def sort_track_2(pl, custom_list=None):
    current_folder = ""
    albums = []
    if custom_list is None:
        playlist = pctl.multi_playlist[pl][2]
    else:
        playlist = custom_list

    for i in range(len(playlist)):
        if i == 0:
            albums.append(i)
            current_folder = pctl.master_library[playlist[i]].parent_folder_name
        else:
            if pctl.master_library[playlist[i]].parent_folder_name != current_folder:
                current_folder = pctl.master_library[playlist[i]].parent_folder_name
                albums.append(i)


    i = 0
    while i < len(albums) - 1:
        playlist[albums[i]:albums[i + 1]] = sorted(playlist[albums[i]:albums[i + 1]], key=index_key)
        i += 1
    if len(albums) > 0:
        playlist[albums[i]:] = sorted(playlist[albums[i]:], key=index_key)



def sort_path_pl(pl):

    def path(index):
        track = pctl.master_library[index]
        return (track.parent_folder_path.lower(), track.filename)

    pctl.multi_playlist[pl][2].sort(key=path)

def append_current_playing(index):
    if pctl.playing_state > 0 and len(pctl.track_queue) > 0:
        pctl.multi_playlist[index][2].append(pctl.track_queue[pctl.queue_step])
        gui.pl_update = 1


def export_stats(pl):
    playlist_time = 0
    play_time = 0
    for index in pctl.multi_playlist[pl][2]:
        playlist_time += int(pctl.master_library[index].length)
        # key = pctl.master_library[index].title + pctl.master_library[index].filename
        # if key in pctl.star_library:
        #     play_time += pctl.star_library[key]
        play_time += star_store.get(index)

    stats_gen.update(pl)
    line = 'Playlist: ' + pctl.multi_playlist[pl][0] + "\r\n"
    line += 'Generated: ' + time.strftime("%c") + "\r\n"
    line += '\r\nTracks in playlist: ' + str(len(pctl.multi_playlist[pl][2]))
    line += '\r\n\r\nTotal Duration: ' + str(datetime.timedelta(seconds=int(playlist_time)))
    line += '\r\nTotal Playtime: ' + str(datetime.timedelta(seconds=int(play_time)))

    line += "\r\n\r\n-------------- Top Artists --------------------\r\n\r\n"

    ls = stats_gen.artist_list
    for i, item in enumerate(ls[:50]):
        line += str(i + 1) + ".\t" + stt2(item[1]) + "\t" + item[0] + "\r\n"

    line += "\r\n\r\n-------------- Top Albums --------------------\r\n\r\n"
    ls = stats_gen.album_list
    for i, item in enumerate(ls[:50]):
        line += str(i + 1) + ".\t" + stt2(item[1]) + "\t" + item[0] + "\r\n"
    line += "\r\n\r\n-------------- Top Genres --------------------\r\n\r\n"
    ls = stats_gen.genre_list
    for i, item in enumerate(ls[:50]):
        line += str(i + 1) + ".\t" + stt2(item[1]) + "\t" + item[0] + "\r\n"

    line = line.encode('utf-8')
    xport = open(user_directory + '/stats.txt', 'wb')
    xport.write(line)
    xport.close()
    target = os.path.join(user_directory, "stats.txt")
    if system == "windows":
        os.startfile(target)
    elif system == 'mac':
        subprocess.call(['open', target])
    else:
        subprocess.call(["xdg-open", target])


def standard_sort(pl):

    if pl_is_locked(pl):
        show_message("Playlist is locked")
        return

    sort_path_pl(pl)
    sort_track_2(pl)
    reload_albums()


def year_s(plt):

    sorted_temp = sorted(plt, key=lambda x: x[1])
    temp = []

    for album in sorted_temp:
        temp += album[0]
    return temp


def year_sort(pl):

    playlist = pctl.multi_playlist[pl][2]
    plt = []
    pl2 = []
    artist = ""

    p = 0
    while p < len(playlist):
        if get_object(playlist[p]).artist != artist:
            artist = get_object(playlist[p]).artist
            pl2 += year_s(plt)
            plt = []

        if p > len(playlist) - 1:
            break

        album = []
        on = get_object(playlist[p]).parent_folder_path
        album.append(playlist[p])
        t = 1

        while t + p < len(playlist) - 1 and get_object(playlist[p + t]).parent_folder_path == on:
                album.append(playlist[p + t])
                t += 1

        date = get_object(playlist[p]).date

        # If date is xx-xx-yyyy format, just grab the year from the end
        # so that the M and D don't interfere with the sorter
        if len(date) > 4 and date[-4:].isnumeric():
            date = date[-4:]

        # If we don't have a date, see if we can grab one from the folder name
        # following the format: (XXXX)
        if date == "":
            pfn = get_object(playlist[p]).parent_folder_name
            if len(pfn) > 6 and pfn[-1] == ")" and pfn[-6] == "(":
                date = pfn[-5:-1]

        plt.append((album, date, artist + " " + get_object(playlist[p]).album))
        p += len(album)
        # print(album)

    if plt:
        pl2 += year_s(plt)
        plt = []

    # We can't just assign the playlist because it may disconnect the 'pointer' default_playlist
    pctl.multi_playlist[pl][2][:] = pl2[:]
    reload_albums()





def pl_toggle_playlist_break(ref):
    pctl.multi_playlist[ref][4] ^= 1
    gui.pl_update = 1



delete_icon.xoff = 3
delete_icon.colour = [249, 70, 70, 255]

tab_menu.add(_('Delete'), delete_playlist, pass_ref=True, hint="Ctrl+W", icon=delete_icon, disable_test=test_pl_tab_locked, pass_ref_deco=True)

def gen_unique_pl_title(base, extra="", start=1):

    ex = start
    title = base
    while ex < 100:
        for playlist in pctl.multi_playlist:
            if playlist[0] == title:
                ex += 1
                if ex == 1:
                    title = base + " (" + extra.rstrip(" ") + ")"
                else:
                    title = base + " (" + extra + str(ex) + ")"
                break
        else:
            break

    return title


def new_playlist(switch=True):

    title = gen_unique_pl_title("New Playlist")

    pctl.multi_playlist.append(pl_gen(title=title))  # [title, 0, [], 0, 0, 0])
    if switch:
        switch_playlist(len(pctl.multi_playlist) - 1)
    return len(pctl.multi_playlist) - 1

heartx_icon = MenuIcon(asset_loader('heart-menu.png', True))
transcode_icon = MenuIcon(asset_loader('transcode.png', True))
mod_folder_icon = MenuIcon(asset_loader('mod_folder.png', True))
settings_icon = MenuIcon(asset_loader('settings2.png', True))
rename_tracks_icon = MenuIcon(asset_loader('pen.png', True))
add_icon = MenuIcon(asset_loader('new.png', True))

tab_menu.br()

def append_deco():

    if pctl.playing_state > 0:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]


def rescan_deco(pl):

    if pctl.multi_playlist[pl][7]:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    #base = os.path.basename(pctl.multi_playlist[pl][7])

    return [line_colour, colours.menu_background, None]


def open_filter_box(pl):
    filter_box.active = True

extra_tab_menu = Menu(155, show_icons=True)

extra_tab_menu.add(_("New Playlist"), new_playlist, icon=add_icon)

#tab_menu.add(_("SORT"), open_filter_box, pass_ref=True)

tab_menu.add_sub(_("Sortedâ¦"), 133)
extra_tab_menu.add_sub(_("From Currentâ¦"), 133)
tab_menu.add(_("Sort by Filepath"), standard_sort, pass_ref=True, disable_test=test_pl_tab_locked, pass_ref_deco=True)
tab_menu.add(_("Sort Year per Artist"), year_sort, pass_ref=True)

# tab_menu.add('Transcode All Folders', convert_playlist, pass_ref=True)
# tab_menu.add('Rescan Tags', rescan_tags, pass_ref=True)
# tab_menu.add('Re-Import Last Folder', re_import, pass_ref=True)
# tab_menu.add('Export XSPF', export_xspf, pass_ref=True)
tab_menu.br()
#tab_menu.add('Paste Tracks', append_playlist, paste_deco, pass_ref=True)

tab_menu.add(_('Rescan Folder'), re_import2, rescan_deco, pass_ref=True, pass_ref_deco=True)

tab_menu.add(_('Paste'), s_append, paste_deco, pass_ref=True)
tab_menu.add(_("Append Playing"), append_current_playing, append_deco, pass_ref=True)
tab_menu.br()
# tab_menu.add("Sort Track Numbers", sort_track_2, pass_ref=True)
# tab_menu.add("Sort By Filepath", sort_path_pl, pass_ref=True)

tab_menu.add_sub(_("Miscâ¦"), 145)


def forget_pl_import_folder(pl):

    pctl.multi_playlist[pl][7] = ""




tab_menu.add_to_sub(_("Export Playlist Stats"), 1, export_stats, pass_ref=True)
tab_menu.add_to_sub(_('Transcode All'), 1, convert_playlist, pass_ref=True)
tab_menu.add_to_sub(_('Rescan Tags'), 1, rescan_tags, pass_ref=True)
tab_menu.add_to_sub(_('Forget Import Folder'), 1, forget_pl_import_folder, rescan_deco, pass_ref=True, pass_ref_deco=True)
# tab_menu.add_to_sub(_('Re-Import Last Folder'), 1, re_import, pass_ref=True)
tab_menu.add_to_sub(_('Export XSPF'), 1, export_xspf, pass_ref=True)
tab_menu.add_to_sub(_("Toggle Breaks"), 1, pl_toggle_playlist_break, pass_ref=True)







#tab_menu.add_to_sub("Empty Playlist", 0, new_playlist)

def best(index):
    #key = pctl.master_library[index].title + pctl.master_library[index].filename
    if pctl.master_library[index].length < 1:
        return 0
    return int(star_store.get(index))
    # if key in pctl.star_library:
    #     return int(pctl.star_library[key])  # / pctl.master_library[index].length)
    # else:
    #     return 0

def key_modified(index):
    return pctl.master_library[index].modified_time

def key_playcount(index):
    #key = pctl.master_library[index].title + pctl.master_library[index].filename
    if pctl.master_library[index].length < 1:
        return 0
    return star_store.get(index) / pctl.master_library[index].length
    # if key in pctl.star_library:
    #     return pctl.star_library[key] / pctl.master_library[index].length
    # else:
    #     return 0

def gen_top_100(index):


    playlist = copy.deepcopy(pctl.multi_playlist[index][2])
    playlist = sorted(playlist, key=best, reverse=True)

    # if len(playlist) > 1000:
    #     playlist = playlist[:1000]

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Playtime Sorted>",
                               playlist=copy.deepcopy(playlist),
                               hide_title=1))
    #    [pctl.multi_playlist[index][0] + " <Playtime Sorted>", 0, copy.deepcopy(playlist), 0, 1, 0])


tab_menu.add_to_sub(_("Top Played Tracks"), 0, gen_top_100, pass_ref=True)
extra_tab_menu.add_to_sub(_("Top Played Tracks"), 0, gen_top_100, pass_ref=True)




def gen_folder_top(pl, get_sets=False):
    if len(pctl.multi_playlist[pl][2]) < 3:
        return

    sets = []
    se = []
    last = pctl.master_library[pctl.multi_playlist[pl][2][0]].parent_folder_path
    last_al = pctl.master_library[pctl.multi_playlist[pl][2][0]].album
    for track in pctl.multi_playlist[pl][2]:
        if last != pctl.master_library[track].parent_folder_path or last_al != pctl.master_library[track].album:
            last = pctl.master_library[track].parent_folder_path
            last_al = pctl.master_library[track].album
            sets.append(copy.deepcopy(se))
            se = []
        se.append(track)
    sets.append(copy.deepcopy(se))

    def best(folder):
        #print(folder)
        total_star = 0
        for item in folder:
            # key = pctl.master_library[item].title + pctl.master_library[item].filename
            # if key in pctl.star_library:
            #     total_star += int(pctl.star_library[key])
            total_star += int(star_store.get(item))
        #print(total_star)
        return total_star

    if get_sets:
        r = []
        for item in sets:
            r.append((item, best(item)))
        return r

    sets = sorted(sets, key=best, reverse=True)


    playlist = []

    for se in sets:
        playlist += se

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[pl][0] + " <Most Played Albums>", 0, copy.deepcopy(playlist), 0, 0, 0])


    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[pl][0] + " <Most Played Albums>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=0))

tab_menu.add_to_sub(_("Top Played Albums"), 0, gen_folder_top, pass_ref=True)
extra_tab_menu.add_to_sub(_("Top Played Albums"), 0, gen_folder_top, pass_ref=True)


def gen_lyrics(pl):
    playlist = []

    for item in pctl.multi_playlist[pl][2]:
        if pctl.master_library[item].lyrics != "":
            playlist.append(item)

    if len(playlist) > 0:
        pctl.multi_playlist.append(pl_gen(title="Tracks with lyrics",
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=0))
    else:
        show_message("No tracks with lyrics were found.")

def gen_codec_pl(codec):

    playlist = []

    for pl in pctl.multi_playlist:
        for item in pl[2]:
            if pctl.master_library[item].file_ext == codec and item not in playlist:
                playlist.append(item)

    if len(playlist) > 0:
        pctl.multi_playlist.append(pl_gen(title="Codec: " + codec,
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=0))



def gen_last_modified(index):

    playlist = copy.deepcopy(pctl.multi_playlist[index][2])
    playlist = sorted(playlist, key=key_modified, reverse=True)
    sort_track_2(0, playlist)

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <File modified>",
                               playlist=copy.deepcopy(playlist),
                               hide_title=0))



tab_menu.add_to_sub(_("File Modified"), 0, gen_last_modified, pass_ref=True)
extra_tab_menu.add_to_sub(_("File Modified"), 0, gen_last_modified, pass_ref=True)

# tab_menu.add_to_sub(_("File Path"), 0, standard_sort, pass_ref=True)
# extra_tab_menu.add_to_sub(_("File Path"), 0, standard_sort, pass_ref=True)



def gen_love(pl):
    playlist = []

    for item in pctl.multi_playlist[pl][2]:
        if get_love_index(item):
            playlist.append(item)

    if len(playlist) > 0:
        #pctl.multi_playlist.append(["Interesting Comments", 0, copy.deepcopy(playlist), 0, 0, 0])
        pctl.multi_playlist.append(pl_gen(title="Loved",
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=0))
    else:
        show_message("No loved tracks were found.")

def gen_comment(pl):
    playlist = []

    for item in pctl.multi_playlist[pl][2]:
        cm = pctl.master_library[item].comment
        if len(cm) > 20 and \
                        cm[0] != "0" and \
                        'http://' not in cm and \
                        'www.' not in cm and \
                        'Release' not in cm and \
                        'EAC' not in cm and \
                        '@' not in cm and \
                        '.com' not in cm and \
                        'ipped' not in cm and \
                        'ncoded' not in cm and \
                        'ExactA' not in cm and \
                        'WWW.' not in cm and \
                        cm[2] != "+" and \
                        cm[1] != "+":
            playlist.append(item)

    if len(playlist) > 0:
        #pctl.multi_playlist.append(["Interesting Comments", 0, copy.deepcopy(playlist), 0, 0, 0])
        pctl.multi_playlist.append(pl_gen(title="Interesting Comments",
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=0))
    else:
        show_message("Nothing of interest was found.")


def gen_sort_len(index):
    global pctl

    def length(index):

        if pctl.master_library[index].length < 1:
            return 0
        else:
            return int(pctl.master_library[index].length)

    playlist = copy.deepcopy(pctl.multi_playlist[index][2])
    playlist = sorted(playlist, key=length, reverse=True)

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0] + " <Duration Sorted>", 0, copy.deepcopy(playlist), 0, 1, 0])

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Duration Sorted>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=1))

tab_menu.add_to_sub(_("Longest Tracks"), 0, gen_sort_len, pass_ref=True)
extra_tab_menu.add_to_sub(_("Longest Tracks"), 0, gen_sort_len, pass_ref=True)


def gen_folder_duration(pl, get_sets=False):
    if len(pctl.multi_playlist[pl][2]) < 3:
        return

    sets = []
    se = []
    last = pctl.master_library[pctl.multi_playlist[pl][2][0]].parent_folder_path
    last_al = pctl.master_library[pctl.multi_playlist[pl][2][0]].album
    for track in pctl.multi_playlist[pl][2]:
        if last != pctl.master_library[track].parent_folder_path or last_al != pctl.master_library[track].album:
            last = pctl.master_library[track].parent_folder_path
            last_al = pctl.master_library[track].album
            sets.append(copy.deepcopy(se))
            se = []
        se.append(track)
    sets.append(copy.deepcopy(se))

    def best(folder):
        total_duration = 0
        for item in folder:
            total_duration += pctl.master_library[item].length
        return total_duration

    if get_sets:
        r = []
        for item in sets:
            r.append((item, best(item)))
        return r

    sets = sorted(sets, key=best, reverse=True)
    playlist = []

    for se in sets:
        playlist += se

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[pl][0] + " <Longest Albums>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=0))


tab_menu.add_to_sub(_("Longest Albums"), 0, gen_folder_duration, pass_ref=True)
extra_tab_menu.add_to_sub(_("Longest Albums"), 0, gen_folder_duration, pass_ref=True)


def gen_sort_date(index, rev=False):
    global pctl

    def g_date(index):

        if pctl.master_library[index].date != "":
            return str(pctl.master_library[index].date)
        else:
            return "z"

    playlist = []
    lowest = 0
    highest = 0
    first = True

    for item in pctl.multi_playlist[index][2]:
        date = pctl.master_library[item].date
        if date != "":
            playlist.append(item)
            if len(date) > 4 and date[:4].isdigit():
                date = date[:4]
            if len(date) == 4 and date.isdigit():
                year = int(date)
                if first:
                    lowest = year
                    highest = year
                    first = False
                if year < lowest:
                    lowest = year
                if year > highest:
                    highest = year

    playlist = sorted(playlist, key=g_date, reverse=rev)

    line = " <Year Sorted>"
    if lowest != highest and lowest != 0 and highest != 0:
        if rev:
            line = " <" + str(highest) + "-" + str(lowest) + ">"
        else:
            line = " <" + str(lowest) + "-" + str(highest) + ">"

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0] + line, 0, copy.deepcopy(playlist), 0, 0, 0])

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + line,
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=0))

tab_menu.add_to_sub(_("Year by Oldest"), 0, gen_sort_date, pass_ref=True)
extra_tab_menu.add_to_sub(_("Year by Oldest"), 0, gen_sort_date, pass_ref=True)


def gen_sort_date_new(index):
    gen_sort_date(index, True)


tab_menu.add_to_sub(_("Year by Latest"), 0, gen_sort_date_new, pass_ref=True)
extra_tab_menu.add_to_sub(_("Year by Latest"), 0, gen_sort_date_new, pass_ref=True)


# tab_menu.add_to_sub(_("Year by Artist"), 0, year_sort, pass_ref=True)
# extra_tab_menu.add_to_sub(_("Year by Artist"), 0, year_sort, pass_ref=True)

def gen_500_random(index):
    global pctl

    playlist = copy.deepcopy(pctl.multi_playlist[index][2])
    playlist = list(set(playlist))
    random.shuffle(playlist)

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0] + " <Shuffled>", 0, copy.deepcopy(playlist), 0,
    #      1, 0])

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Shuffled>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=1))

tab_menu.add_to_sub(_("Shuffled Tracks"), 0, gen_500_random, pass_ref=True)
extra_tab_menu.add_to_sub(_("Shuffled Tracks"), 0, gen_500_random, pass_ref=True)


def gen_folder_shuffle(index):
    folders = []
    dick = {}
    for track in pctl.multi_playlist[index][2]:
        parent = pctl.master_library[track].parent_folder_path
        if parent not in folders:
            folders.append(parent)
        if parent not in dick:
            dick[parent] = []
        dick[parent].append(track)

    random.shuffle(folders)
    playlist = []

    for folder in folders:
        playlist += dick[folder]

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Shuffled Folders>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=0))

tab_menu.add_to_sub(_("Shuffled Albums"), 0, gen_folder_shuffle, pass_ref=True)
extra_tab_menu.add_to_sub(_("Shuffled Albums"), 0, gen_folder_shuffle, pass_ref=True)


def gen_best_random(index):

    playlist = []

    for p in pctl.multi_playlist[index][2]:
        time = star_store.get(p)

        if time > 300:
            playlist.append(p)
        # key = pctl.master_library[p].title + pctl.master_library[p].filename
        # if key in pctl.star_library:
        #     if pctl.star_library[key] > 300:
        #         playlist.append(p)
    random.shuffle(playlist)
    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0] + " <Random Played>", 0, copy.deepcopy(playlist), 0, 1, 0])
    if len(playlist) > 0:

        pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Lucky Random>",
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=1))

tab_menu.add_to_sub(_("Lucky Random"), 0, gen_best_random, pass_ref=True)
extra_tab_menu.add_to_sub(_("Lucky Random"), 0, gen_best_random, pass_ref=True)


def gen_reverse(index):
    playlist = list(reversed(pctl.multi_playlist[index][2]))

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0] + " <Reversed>", 0, copy.deepcopy(playlist), 0, pctl.multi_playlist[index][4],
    #      0])

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Reversed>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=pctl.multi_playlist[index][4]))

tab_menu.add_to_sub(_("Reverse Tracks"), 0, gen_reverse, pass_ref=True)
extra_tab_menu.add_to_sub(_("Reverse Tracks"), 0, gen_reverse, pass_ref=True)

def gen_folder_reverse(index):
    folders = []
    dick = {}
    for track in pctl.multi_playlist[index][2]:
        parent = pctl.master_library[track].parent_folder_path
        if parent not in folders:
            folders.append(parent)
        if parent not in dick:
            dick[parent] = []
        dick[parent].append(track)

    folders = list(reversed(folders))
    playlist = []

    for folder in folders:
        playlist += dick[folder]

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Reversed Folders>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=0))

tab_menu.add_to_sub(_("Reverse Albums"), 0, gen_folder_reverse, pass_ref=True)
extra_tab_menu.add_to_sub(_("Reverse Albums"), 0, gen_folder_reverse, pass_ref=True)

def gen_dupe(index):
    playlist = pctl.multi_playlist[index][2]

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0], pctl.multi_playlist[index][1], copy.deepcopy(playlist),
    #      pctl.multi_playlist[index][3], pctl.multi_playlist[index][4], pctl.multi_playlist[index][5]])


    pctl.multi_playlist.append(pl_gen(title=gen_unique_pl_title(pctl.multi_playlist[index][0], "Duplicate ", 0),
                                      playing=pctl.multi_playlist[index][1],
                                      playlist=copy.deepcopy(playlist),
                                      position=pctl.multi_playlist[index][3],
                                      hide_title=pctl.multi_playlist[index][4],
                                      selected=pctl.multi_playlist[index][5]))

tab_menu.add_to_sub(_("Duplicate"), 0, gen_dupe, pass_ref=True)
extra_tab_menu.add_to_sub(_("Duplicate"), 0, gen_dupe, pass_ref=True)


def gen_sort_path(index):
    def path(index):
        return pctl.master_library[index].fullpath

    playlist = copy.deepcopy(pctl.multi_playlist[index][2])
    playlist = sorted(playlist, key=path)

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0] + " <Filepath Sorted>", 0, copy.deepcopy(playlist), 0, 0, 0])

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Filepath Sorted>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=0))

# tab_menu.add_to_sub("Filepath", 1, gen_sort_path, pass_ref=True)


def gen_sort_artist(index):

    def artist(index):
        return pctl.master_library[index].artist

    playlist = copy.deepcopy(pctl.multi_playlist[index][2])
    playlist = sorted(playlist, key=artist)

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0] + " <Artist Sorted>", 0, copy.deepcopy(playlist), 0, 0, 0])

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Artist Sorted>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=0))

# tab_menu.add_to_sub("Artist â gui.abc", 0, gen_sort_artist, pass_ref=True)


def gen_sort_album(index):
    def album(index):
        return pctl.master_library[index].album

    playlist = copy.deepcopy(pctl.multi_playlist[index][2])
    playlist = sorted(playlist, key=album)

    # pctl.multi_playlist.append(
    #     [pctl.multi_playlist[index][0] + " <Album Sorted>", 0, copy.deepcopy(playlist), 0, 0, 0])

    pctl.multi_playlist.append(pl_gen(title=pctl.multi_playlist[index][0] + " <Album Sorted>",
                                      playlist=copy.deepcopy(playlist),
                                      hide_title=0))

# tab_menu.add_to_sub("Album â gui.abc", 0, gen_sort_album, pass_ref=True)
tab_menu.add_to_sub(_("Loved"), 0, gen_love, pass_ref=True)
extra_tab_menu.add_to_sub(_("Loved"), 0, gen_love, pass_ref=True)
#tab_menu.add_to_sub("Has Comment", 0, gen_comment, pass_ref=True)
tab_menu.add_to_sub(_("Has Lyrics"), 0, gen_lyrics, pass_ref=True)
extra_tab_menu.add_to_sub(_("Has Lyrics"), 0, gen_lyrics, pass_ref=True)






def get_playing_line():
    if 3 > pctl.playing_state > 0:
        title = pctl.master_library[pctl.track_queue[pctl.queue_step]].title
        artist = pctl.master_library[pctl.track_queue[pctl.queue_step]].artist
        return artist + " - " + title
    else:
        return 'Stopped'


def get_broadcast_line():
    if pctl.broadcast_active:
        title = pctl.master_library[pctl.broadcast_index].title
        artist = pctl.master_library[pctl.broadcast_index].artist
        return artist + " - " + title
    else:
        return 'No Title'


def open_license():
    target = os.path.join(install_directory, "license.txt")
    if os.path.isfile(os.path.join(install_directory, "LICENSE")):
        target = os.path.join(install_directory, "LICENSE")
    if os.path.isfile(os.path.join(install_directory, "LICENSE.txt")):
        target = os.path.join(install_directory, "LICENSE.txt")

    if system == "windows":
        os.startfile(target)
    elif system == 'mac':
        subprocess.call(['open', target])
    else:
        subprocess.call(["xdg-open", target])
        print(target)


def reload_config_file():

    if transcode_list:
        show_message("Cannot reload while a transcode is in progress!", 'error')
        return

    load_prefs()
    gui.opened_config_file = False
    show_message(_("Configuration reloaded"), 'done')

def open_config_file():
    save_prefs()
    target = os.path.join(config_directory, "tauon.conf")
    if system == "windows":
        os.startfile(target)
    elif system == 'mac':
        subprocess.call(['open', target])
    else:
        subprocess.call(["xdg-open", target])
    show_message(_("Config file opened."), 'arrow', _('Click "Reload config file" if you made any changes'))
    gui.opened_config_file = True

def open_keymap_file():

    target = os.path.join(config_directory, "input.txt")

    if not os.path.isfile(target):
        show_message("Input file missing")
        return

    if system == "windows":
        os.startfile(target)
    elif system == 'mac':
        subprocess.call(['open', target])
    else:
        subprocess.call(["xdg-open", target])


def open_data_directory():
    target = user_directory
    if system == "windows":
        os.startfile(target)
    elif system == 'mac':
        subprocess.call(['open', target])
    else:
        subprocess.call(["xdg-open", target])

def open_encode_out():
    if system == 'windows':
        line = r'explorer ' + prefs.encoder_output.replace("/", "\\")
        subprocess.Popen(line)
    else:
        line = prefs.encoder_output
        line += "/"
        if system == 'mac':
            subprocess.Popen(['open', line])
        else:
            subprocess.Popen(['xdg-open', line])

def g_open_encode_out(a, b, c):
    open_encode_out()


def remove_folder(index):
    global default_playlist

    for b in range(len(default_playlist) - 1, -1, -1):
        r_folder = pctl.master_library[index].parent_folder_name
        if pctl.master_library[default_playlist[b]].parent_folder_name == r_folder:
            del default_playlist[b]

    reload()


def convert_folder(index):
    global default_playlist
    global transcode_list

    if system == 'windows':
        if not os.path.isfile(user_directory + '/encoder/ffmpeg.exe'):
            show_message("Error: Missing ffmpeg.exe from '/encoder' directory")
            return
            # if prefs.transcode_codec == 'opus' and not os.path.isfile(install_directory + '/encoder/opusenc.exe'):
            #     show_message("Error: Missing opusenc.exe from '/encoder' directory")
            return
        # if prefs.transcode_codec == 'mp3' and not os.path.isfile(user_directory + '/encoder/lame.exe'):
        #     show_message("Error: Missing lame.exe from '/encoder' directory")
        #     return
        # if prefs.transcode_codec == 'ogg' and not os.path.isfile(user_directory + '/encoder/oggenc2.exe'):
        #     show_message("Error: Missing oggenc2.exe from '/encoder' directory")
        #     return
    else:
        if shutil.which('ffmpeg') is None:
            show_message("Error: ffmpeg does not appear to be installed")
            return
        # if prefs.transcode_codec == 'mp3' and shutil.which('lame') is None:
        #     show_message("Error: LAME does not appear to be installed")
        #     return

    folder = []
    if key_shift_down or key_shiftr_down:
        track_object = pctl.g(index)
        if track_object.is_network:
            show_message("Transcoding tracks from network locations is not currenty supported")
            return
        folder = [index]

        if prefs.transcode_codec == 'flac' and track_object.file_ext.lower() in ('mp3', 'opus',
                                                                                 'mp4', 'ogg',
                                                                                 'aac'):
            show_message("NO! Bad user!",
                         'warning', "Im not going to let you transcode a lossy codec to a lossless one!")

            return
        folder = [index]

    else:
        r_folder = pctl.master_library[index].parent_folder_path
        for item in default_playlist:
            if r_folder == pctl.master_library[item].parent_folder_path:

                track_object = pctl.g(item)
                if track_object.is_network:
                    show_message("Transcoding tracks from network locations is not currenty supported")
                    return

                if item not in folder:
                    folder.append(item)
                print(prefs.transcode_codec)
                print(track_object.file_ext)
                if prefs.transcode_codec == 'flac' and track_object.file_ext.lower() in ('mp3', 'opus',
                                                                                                      'mp4', 'ogg',
                                                                                                      'aac'):
                    show_message("NO! Bad user!",
                                 'warning', "Im not going to let you transcode a lossy codec to a lossless one!")

                    return

    print(folder)
    transcode_list.append(folder)


def transfer(index, args):
    global cargo
    global default_playlist
    old_cargo = copy.deepcopy(cargo)

    if args[0] == 1 or args[0] == 0:  # copy
        if args[1] == 1:  # single track
            cargo.append(index)
            if args[0] == 0:  # cut
                del default_playlist[playlist_selected]

        elif args[1] == 2:  # folder
            for b in range(len(default_playlist)):
                if pctl.master_library[default_playlist[b]].parent_folder_name == pctl.master_library[
                    index].parent_folder_name:
                    cargo.append(default_playlist[b])
            if args[0] == 0:  # cut
                for b in reversed(range(len(default_playlist))):
                    if pctl.master_library[default_playlist[b]].parent_folder_name == pctl.master_library[
                        index].parent_folder_name:
                        del default_playlist[b]

        elif args[1] == 3:  # playlist
            cargo += default_playlist
            if args[0] == 0:  # cut
                default_playlist = []

    elif args[0] == 2:  # Drop
        if args[1] == 1:  # Before

            insert = playlist_selected
            while insert > 0 and pctl.master_library[default_playlist[insert]].parent_folder_name == \
                    pctl.master_library[index].parent_folder_name:
                insert -= 1
                if insert == 0:
                    break
            else:
                insert += 1

            while len(cargo) > 0:
                default_playlist.insert(insert, cargo.pop())

        elif args[1] == 2:  # After
            insert = playlist_selected

            while insert < len(default_playlist) and pctl.master_library[default_playlist[insert]].parent_folder_name == \
                    pctl.master_library[index].parent_folder_name:
                insert += 1

            while len(cargo) > 0:
                default_playlist.insert(insert, cargo.pop())
        elif args[1] == 3:  # End
            default_playlist += cargo
            # cargo = []

        cargo = old_cargo

    reload()


def temp_copy_folder(ref):
    global cargo
    cargo = []
    transfer(ref, args=[1, 2])

def activate_track_box(index):
    global track_box
    global r_menu_index
    r_menu_index = index
    track_box = True
    track_box_path_tool_timer.set()

def menu_paste(position):
    paste(None, position)

def s_copy():

    # Copy tracks to internal clipboard
    # gui.lightning_copy = False
    # if key_shift_down:
    gui.lightning_copy = True

    clip = copy_from_clipboard()
    if "file://" in clip:
        copy_to_clipboard("")

    global cargo
    cargo = []
    for item in shift_selection:
        cargo.append(default_playlist[item])

    # # Copy tracks to external clipboard
    # if 300 > len(cargo) > 0:
    #
    #     clips = []
    #     for i in range(len(cargo)):
    #         clips.append(os.path.abspath(pctl.master_library[cargo[i]].fullpath))
    #     clips = set(clips)
    #
    #     if system == 'windows':
    #         clip_files(clips)
    #     elif system == 'linux':
    #         if 'gnome' in os.environ.get('DESKTOP_SESSION'):
    #
    #             content = 'echo "copy\n'
    #             for i, item in enumerate(cargo):
    #                 content += "file://" + os.path.abspath(pctl.master_library[item].fullpath).strip("\n")
    #                 if i == len(cargo) - 1:
    #                     pass
    #                 else:
    #                     print("newline")
    #                     content += "\n"
    #
    #             #content += "\0"
    #             #content = content.encode()
    #
    #             command = content + '" | xclip -i -selection clipboard -t x-special/gnome-copied-files'
    #
    #
    #             print('hit')
    #         else:
    #             content = 'echo "'
    #             for item in cargo:
    #                 content += "file://" + os.path.abspath(pctl.master_library[item].fullpath) + "\n"
    #
    #             command = content + '" | xclip -i -selection clipboard -t text/uri-list'
    #             #command = command.encode()
    #
    #         print(command)
    #
    #         subprocess.call(command, shell=True)
    #         os.system(command)

    # print("COPY")
    # if len(cargo) > 0:
    #     if system == 'windows':
    #
    #         clips = []
    #         for i in range(len(cargo)):
    #             clips.append(os.path.abspath(pctl.master_library[cargo[i]].fullpath))
    #         clips = set(clips)
    #
    #         clip_files(clips)
    #
    #     if system == 'linux' and shutil.which('xclip'):
    #         if len(cargo) > 1000:
    #             return
    #         content = 'echo "'
    #         for item in cargo:
    #             content += "file://" + os.path.abspath(pctl.master_library[item].fullpath) + "\n"
    #
    #         command = content + '" | xclip -i -selection clipboard -t text/uri-list'
    #         print(command)
    #         subprocess.call(shlex.split(command), shell=True)
    #         os.system(command)

move_jobs = []
move_in_progress = False

def directory_size(path):
    total = 0
    for dirpath, dirname, filenames in os.walk(path):
        for file in filenames:
            path = os.path.join(dirpath, file)
            total += os.path.getsize(path)
    return total

def lightning_paste():

    move = True
    # if not key_shift_down:
    #     move = False

    move_track = pctl.g(cargo[0])
    move_path = move_track.parent_folder_path

    for item in cargo:
        if move_path != pctl.g(item).parent_folder_path:
            show_message("More than one folder is in the clipboard", 'info', 'This function can only move one folder at a time.')
            return

    match_track = pctl.g(default_playlist[shift_selection[0]])
    match_path = match_track.parent_folder_path

    if pctl.playing_state > 0 and move:
        if pctl.playing_object().parent_folder_path == move_path:
            pctl.stop(True)

    p = Path(match_path)
    s = list(p.parts)
    base = s[0]
    c = base
    del s[0]

    to_move = []
    for pl in pctl.multi_playlist:
        for i in reversed(range(len(pl[2]))):
            if pctl.g(pl[2][i]).parent_folder_path == move_track.parent_folder_path:
                to_move.append(pl[2][i])

    to_move = list(set(to_move))


    for level in s:
        upper = c
        c = os.path.join(c, level)

        t_artist = match_track.artist
        ta_artist = match_track.album_artist

        for g in r'[]/\;,><&*:%=+@!#^()|?^.':
            t_artist = t_artist.replace(c, '')

        for g in r'[]/\;,><&*:%=+@!#^()|?^.':
            ta_artist = ta_artist.replace(c, '')

        if (len(t_artist) > 0 and t_artist in level) or \
                (len(ta_artist) > 0 and ta_artist in level):

            print("found target artist level")
            print(t_artist)
            print("Upper folder is: " + upper)

            if len(move_path) < 4:
                show_message("Safety interupt! The source path seems oddly short.", 'error', move_path)
                return

            if not os.path.isdir(upper):
                show_message("The target directory is missing!", 'warning', upper)
                return

            if not os.path.isdir(move_path):
                show_message("The source directory is missing!", 'warning', move_path)
                return

            protect = ("", "Documents", "Music", "Desktop", "Downloads")
            for fo in protect:
                if move_path.strip('\\/') == os.path.join(os.path.expanduser('~'), fo).strip("\\/"):
                    show_message("Better not do anything to that folder!", 'warning', os.path.join(os.path.expanduser('~'), fo))
                    return

            if directory_size(move_path) > 1500000000:
                show_message("Folder size safety limit reached! (1.5GB)", 'warning', move_path)
                return

            if len(next(os.walk(move_path))[2]) > max(20, len(to_move) * 2):
                show_message("Safety interupt! The source folder seems to have many files.", 'warning', move_path)
                return

            artist = move_track.artist
            if move_track.album_artist != "":
                artist = move_track.album_artist

            for c in r'[]/\;,><&*:%=+@!#^()|?^.':
                artist = artist.replace(c, '')

            if artist == "":
                show_message("The track needs to have an artist name.")
                return

            artist_folder = os.path.join(upper, artist)

            print("Target will be: " + artist_folder)

            if os.path.isdir(artist_folder):
                print("The target artist folder already exists")
            else:
                print("Need to make artist folder")
                os.makedirs(artist_folder)

            print("The folder to be moved is: " + move_path)
            load_order = LoadClass()
            load_order.target = os.path.join(artist_folder, move_track.parent_folder_name)
            load_order.playlist = pctl.multi_playlist[pctl.active_playlist_viewing][6]

            insert = shift_selection[0]
            old_insert = insert
            while insert < len(default_playlist) and pctl.master_library[pctl.multi_playlist[pctl.active_playlist_viewing][2][insert]].parent_folder_name == \
                    pctl.master_library[pctl.multi_playlist[pctl.active_playlist_viewing][2][old_insert]].parent_folder_name:
                insert += 1

            load_order.playlist_position = insert

            move_jobs.append((move_path, os.path.join(artist_folder, move_track.parent_folder_name), move, move_track.parent_folder_name, load_order))

            # Remove all tracks with the old paths
            for pl in pctl.multi_playlist:
                for i in reversed(range(len(pl[2]))):
                    if pctl.g(pl[2][i]).parent_folder_path == move_track.parent_folder_path:
                        del pl[2][i]

            break
    else:
        show_message("Could not find a folder with the artist's name to match level at.")
        return

    # for file in os.listdir(artist_folder):
    #

    if album_mode:
        prep_gal()
        reload_albums(True)

    cargo.clear()
    gui.lightning_copy = False



def paste(playlist=None, position=None):

    # if key_shift_down and gui.lightning_copy:
    #
    #     try:
    #         lightning_paste()
    #     except OSError as e:
    #         show_message("An error was encountered", 'error', str(e))
    #
    #     return
    # items = None
    # if system == 'windows':
    #     clp = win32clipboard
    #     clp.OpenClipboard(None)
    #     rc = clp.EnumClipboardFormats(0)
    #     while rc:
    #         # try:
    #         #     format_name = clp.GetClipboardFormatName(rc)
    #         # except win32api.error:
    #         #     format_name = "?"
    #         # try:
    #         #     print("------")
    #         #     print("Format: " + str(rc))
    #         #     print("Name: " +  format_name)
    #         #     print("Raw: ", end="")
    #         #     print(clp.GetClipboardData(rc))
    #         #     print("Decode: " + clp.GetClipboardData(rc).decode('utf-8'))
    #         # except:
    #         #     print('error')
    #         if rc == 15:
    #             items = clp.GetClipboardData(rc)
    #
    #         rc = clp.EnumClipboardFormats(rc)
    #
    #     clp.CloseClipboard()
    #     print(items)
    #
    # elif system == 'linux' and shutil.which('xclip'):
    #
    #     #clip = SDL_GetClipboardText().decode('utf-8')
    #     command = "xclip -o -selection clipboard"
    #     p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE)
    #     clip = p.communicate()[0]
    #
    #     print(clip)
    #     clip = clip.decode().split('\n')
    #
    #     items = []
    #     for item in clip:
    #         if len(item) > 0 and (item[0] == '/' or 'file://' in item):
    #             if item[:6] == 'file:/':
    #                 item = item[6:] # = item.lstrip("file:/")
    #             if item[0] != "/":
    #                 item = "/" + item
    #             items.append(item)
    #
    #         else:
    #             items = None
    #             break
    #     print(items)
    # else:
    #     print("No CLIP")
    #     return
    #
    #
    # clips = []
    # cargs = []
    #
    # if items is not None:
    #     for i in range(len(cargo)):
    #         cargs.append(os.path.abspath(pctl.master_library[cargo[i]].fullpath))
    #     for i in range(len(items)):
    #         clips.append(os.path.abspath(items[i]))
    #
    # if (len(clips) > 0 and set(clips) == set(cargs)) or items is None:
    #     print('Matches clipboard, using internal copy')

    if playlist is None:
        if position is None:
            transfer(0, (2, 3))
        else:
            transfer(position, (2, 2))
    else:
        append_playlist(playlist)
    return

    # print('Importing from clipboard')
    # # print(clips)
    #
    # for item in clips:
    #     print("load item")
    #     print(item)
    #     load_order = LoadClass()
    #     load_order.target = item
    #     playlist_target = pctl.playlist_active
    #     if playlist is not None:
    #         playlist_target = playlist
    #     load_order.playlist = pctl.multi_playlist[playlist_target][6]
    #
    #     if position is not None:
    #         insert = pctl.multi_playlist[playlist_target][2].index(position)
    #         old_insert = insert
    #
    #         while insert < len(default_playlist) and pctl.master_library[pctl.multi_playlist[playlist_target][2][insert]].parent_folder_name == \
    #                 pctl.master_library[pctl.multi_playlist[playlist_target][2][old_insert]].parent_folder_name:
    #             insert += 1
    #
    #         load_order.playlist_position = insert
    #
    #     load_orders.append(copy.deepcopy(load_order))


def s_cut():
    s_copy()
    del_selected()

playlist_menu.add('Paste', paste, paste_deco)


def refind_playing():
    # Refind playing index
    if pctl.playing_ready():
        for i, n in enumerate(default_playlist):
            if pctl.track_queue[pctl.queue_step] == n:
                pctl.playlist_playing_position = i
                break


def del_selected(force_delete=False):
    global shift_selection
    global playlist_selected

    gui.update += 1
    gui.pl_update = 1

    if not shift_selection:
        shift_selection = [playlist_selected]

    if not default_playlist:
        return

    li = []

    for item in reversed(shift_selection):
        if item > len(default_playlist) - 1:
            return

        li.append((item, default_playlist[item]))
        del default_playlist[item]

    if force_delete:
        for item in li:

            tr = pctl.g(item[1])
            if not tr.is_network:
                try:
                    send2trash(tr.fullpath)
                    show_message("Tracks sent to trash")
                except:
                    show_message("One or more tracks could not be sent to trash")

                    if force_delete:
                        try:
                            os.remove(tr.fullpath)
                            show_message("Files deleted", 'info')
                        except:
                            show_message("Error deleting one or more files", 'error')

    else:
        undo.bk_tracks(pctl.active_playlist_viewing, li)


    reload()

    if playlist_selected > len(default_playlist) - 1:
        playlist_selected = len(default_playlist) - 1

    shift_selection = [playlist_selected]

    refind_playing()


def force_del_selected():
    del_selected(force_delete=True)



def test_show(dummy):
    return album_mode

def show_in_gal(track, silent=False):
    # goto_album(playlist_selected)
    gui.gallery_animate_highlight_on = goto_album(playlist_selected)
    if not silent:
        gallery_select_animate_timer.set()



# Create track context menu
track_menu = Menu(195, show_icons=True) #175

track_menu.add(_('Open Folder'), open_folder, pass_ref=True, icon=folder_icon)
track_menu.add(_('Track Infoâ¦'), activate_track_box, pass_ref=True, icon=info_icon)


def last_fm_test(ignore):
    if lastfm.connected:
        return True
    else:
        return False

def heart_xmenu_colour():
    global r_menu_index
    if love(False, r_menu_index):
        return [245, 60, 60, 255]
    else:
        if colours.lm:
            return [255, 200, 200, 255]
        return None



heartx_icon.colour = [55, 55, 55, 255]
heartx_icon.xoff = 1
heartx_icon.yoff = 0
heartx_icon.colour_callback = heart_xmenu_colour

def love_decox():
    global r_menu_index

    if love(False, r_menu_index):
        return [colours.menu_text, colours.menu_background, _("Un-Love Track")]
    else:
        return [colours.menu_text, colours.menu_background, _("Love Track")]


def love_index():
    global r_menu_index

    #love(True, r_menu_index)
    shoot_love = threading.Thread(target=love, args=[True, r_menu_index])
    shoot_love.daemon = True
    shoot_love.start()

# Mark track as 'liked'
track_menu.add('Love', love_index, love_decox, icon=heartx_icon)

def id_to_pl(id):

    for i, item in enumerate(pctl.multi_playlist):
        if item[6] == id:
            return i
    return None

def pl_to_id(pl):

    return pctl.multi_playlist[pl][6]


def add_to_queue(ref):

    pctl.force_queue.append(queue_item_gen(ref, r_menu_position, pl_to_id(pctl.active_playlist_viewing)))

def split_queue_album(id):

    item = pctl.force_queue[0]

    pl = id_to_pl(item[2])
    if pl is None:
        return

    playlist = pctl.multi_playlist[pl][2]

    i = pctl.playlist_playing_position + 1
    parts = []
    album_parent_path = pctl.g(item[0]).parent_folder_path

    while i < len(playlist):
        if pctl.g(playlist[i]).parent_folder_path != album_parent_path:
            break

        parts.append((playlist[i], i))
        i += 1

    del pctl.force_queue[0]

    for part in reversed(parts):
        pctl.force_queue.insert(0, queue_item_gen(part[0], part[1], item[3]))


def add_to_queue_next(ref):

    if pctl.force_queue and pctl.force_queue[0][4] == 1:
        split_queue_album(None)

    pctl.force_queue.insert(0, queue_item_gen(ref, r_menu_position, pl_to_id(pctl.active_playlist_viewing)))

# def toggle_queue(mode=0):
#     if mode == 1:
#         return prefs.show_queue
#     prefs.show_queue ^= True
#     prefs.show_queue ^= True


track_menu.add(_('Add to Queue'), add_to_queue, pass_ref=True, hint="MB3")

track_menu.add(_('â³ After Current Track'), add_to_queue_next, pass_ref=True, show_test=test_shift)

track_menu.add(_('Show in Gallery'), show_in_gal, pass_ref=True, show_test=test_show)


track_menu.add_sub(_("Metaâ¦"), 160)

track_menu.br()
#track_menu.add('Cut', s_cut, pass_ref=False)
#track_menu.add('Remove', del_selected)
track_menu.add(_('Copy'), s_copy, copy_deco, pass_ref=False)

track_menu.add(_('Transfer Folder Here'), lightning_paste, pass_ref=False, show_test=lightning_move_test)

track_menu.add(_('Paste'), menu_paste, paste_deco, pass_ref=True)


def delete_track(track_ref):

    tr = pctl.g(track_ref)
    fullpath = tr.fullpath

    if system == "windows":
        fullpath = fullpath.replace("/", "\\")

    if tr.is_network:
        show_message("Deleting a network track is not supported")
        return

    while track_ref in default_playlist:
        default_playlist.remove(track_ref)

    try:
        send2trash(fullpath)
        show_message("File moved to trash")
        return
    except:
        pass

    try:
        os.remove(fullpath)
        show_message("File deleted", 'info', fullpath)
    except:
        show_message("Error deleting file", 'error', fullpath)

    reload()
    refind_playing()
    tauon.worker_save_state = True

track_menu.add(_('Delete Track File'), delete_track, pass_ref=True, icon=delete_icon, show_test=test_shift)

track_menu.br()


def rename_tracks(index):
    global track_box
    global rename_index
    global input_text
    global renamebox

    track_box = False
    rename_index = index
    renamebox = True
    input_text = ""


# rename_tracks_icon.colour = [244, 241, 66, 255]
# rename_tracks_icon.colour = [204, 255, 66, 255]
rename_tracks_icon.colour = [204, 100, 205, 255]
rename_tracks_icon.xoff = 1
track_menu.add_to_sub(_("Rename Tracksâ¦"), 0, rename_tracks, pass_ref=True, icon=rename_tracks_icon)


def delete_folder(index, force=False):

    track = pctl.master_library[index]

    if track.is_network:
        show_message("Cannot physically delete", 'info', "One or more tracks is from a network location!")
        return

    old = track.parent_folder_path



    if len(old) < 5:
        show_message("This folder path seems short, I don't wanna try delete that", 'warning')
        return

    if not os.path.exists(old):
        show_message("Error deleting folder. The folder seems to be missing.", 'error', "It's gone! Just gone!")
        return

    protect = ("", "Documents", "Music", "Desktop", "Downloads")

    for fo in protect:
        if old.strip('\\/') == os.path.join(os.path.expanduser('~'), fo).strip("\\/"):
            show_message("Woah, careful there!", 'warning', "I don't think we should delete that folder.")
            return

    if directory_size(old) > 1500000000:
        show_message("Folder size safety limit reached! (1.5GB)", 'warning', old)
        return

    try:

        if pctl.playing_state > 0 and os.path.normpath(
                pctl.master_library[pctl.track_queue[pctl.queue_step]].parent_folder_path) == os.path.normpath(old):
            pctl.stop(True)

        if force:
            shutil.rmtree(old)
        else:
            if system == "windows":
                send2trash(old.replace("/", "\\"))
            else:
                send2trash(old)

        for i in reversed(range(len(default_playlist))):

            if old == pctl.master_library[default_playlist[i]].parent_folder_path:
                del default_playlist[i]

        if not os.path.exists(old):
            if force:
                show_message("Folder deleted.", 'done', old)
            else:
                show_message("Folder sent to trash.", 'done', old)
        else:
            show_message("Hmm, its still there", 'error', old)

        if album_mode:
            prep_gal()
            reload_albums()

    except:
        if force:
            show_message("Unable to comply.", 'error', "Could not delete folder. Try check permissions.")
        else:
            show_message("Folder could not be trashed.", 'error', "Try again while holding shift to force delete.")

    tauon.worker_save_state = True


def rename_parent(index, template):

    #template = prefs.rename_folder_template
    template = template.strip("/\\")
    track = pctl.master_library[index]

    if track.is_network:
        show_message("Cannot rename", 'info', "One or more tracks is from a network location!")
        return

    old = track.parent_folder_path
    #print(old)

    new = parse_template2(template, track)
    print(new)


    if len(new) < 1:
        show_message("Rename error.", 'warning', "The generated name is too short")
        return

    if len(old) < 5:
        show_message("Rename error.", 'warning', "This folder path seems short, I don't wanna try rename that")
        return

    if not os.path.exists(old):
        show_message("Rename Failed. The original folder is missing.", 'warning')
        return

    protect = ("", "Documents", "Music", "Desktop", "Downloads")

    for fo in protect:
        if os.path.normpath(old) == os.path.normpath(os.path.join(os.path.expanduser('~'), fo)):
            show_message("Woah, careful there!", 'warning', "I don't think we should rename that folder.")
            return

    print(track.parent_folder_path)
    re = os.path.dirname(track.parent_folder_path.rstrip("/\\"))
    print(re)
    new_parent_path = os.path.join(re, new)
    print(new_parent_path)

    pre_state = 0

    for key, object in pctl.master_library.items():

        if object.fullpath == "":
            continue


        if old == object.parent_folder_path:

            new_fullpath = os.path.join(new_parent_path, object.filename)

            if os.path.normpath(new_parent_path) == os.path.normpath(old):
                show_message("The folder already has that name.")
                return

            if os.path.exists(new_parent_path):
                show_message("Rename Failed.", 'warning', "A folder with that name already exists")
                return

            if key == pctl.track_queue[pctl.queue_step] and pctl.playing_state > 0:
                pre_state = pctl.stop(True)


            object.parent_folder_name = new
            object.parent_folder_path = new_parent_path
            object.fullpath = new_fullpath

        # Fix any other tracks paths that contain the old path
        if os.path.normpath(object.fullpath)[:len(old)] == os.path.normpath(old) \
                and os.path.normpath(object.fullpath)[len(old)] in ('/', '\\'):
            object.fullpath = os.path.join(new_parent_path, object.fullpath[len(old):].lstrip('\\/'))
            object.parent_folder_path = os.path.join(new_parent_path, object.parent_folder_path[len(old):].lstrip('\\/'))


    if new_parent_path is not None:
        try:
            os.rename(old, new_parent_path)
            print(new_parent_path)
        except:

            show_message("Rename Failed!", 'error' "Something went wrong, sorry.")
            return

    show_message("Folder renamed.", 'done', "Renamed to: " + new)

    if pre_state == 1:
        pctl.revert()

    tauon.worker_save_state = True

def rename_folders(index):
    global track_box
    global rename_index
    global input_text

    track_box = False
    rename_index = index
    gui.rename_folder_box = True
    input_text = ""
    shift_selection.clear()

    global quick_drag
    global playlist_hold
    quick_drag = False
    playlist_hold = False


mod_folder_icon.colour = [229, 98, 98, 255]
track_menu.add_to_sub(_("Modify Folderâ¦"), 0, rename_folders, pass_ref=True, icon=mod_folder_icon)


def move_folder_up(index, do=False):

    track = pctl.master_library[index]

    if track.is_network:
        show_message("Cannot move", 'info', "One or more tracks is from a network location!")
        return

    parent_folder = os.path.dirname(track.parent_folder_path)
    folder_name = track.parent_folder_name
    move_target = track.parent_folder_path
    upper_folder = os.path.dirname(parent_folder)

    if not os.path.exists(track.parent_folder_path):
        if do:
            show_message("Error shifting directory", 'warning', "The directory does not appear to exist")
        return False

    if len(os.listdir(parent_folder)) > 1:
        return False

    if do is False:
        return True


    pre_state = 0
    if pctl.playing_state > 0 and track.parent_folder_path in pctl.playing_object().parent_folder_path:
        pre_state = pctl.stop(True)

    try:

        # Rename the track folder to something temporary
        os.rename(move_target, os.path.join(parent_folder, "RMTEMP000"))

        # Move the temporary folder up 2 levels
        shutil.move(os.path.join(parent_folder, "RMTEMP000"), upper_folder)

        # Delete the old directory that contained the original folder
        shutil.rmtree(parent_folder)

        # Rename the moved folder back to its original name
        os.rename(os.path.join(upper_folder, "RMTEMP000"), os.path.join(upper_folder, folder_name))

    except Exception as e:
        show_message("System Error!", 'error', str(e))

    # Fix any other tracks paths that contain the old path
    old = track.parent_folder_path
    new_parent_path = os.path.join(upper_folder, folder_name)
    for key, object in pctl.master_library.items():

        if os.path.normpath(object.fullpath)[:len(old)] == os.path.normpath(old) \
                and os.path.normpath(object.fullpath)[len(old)] in ('/', '\\'):
            object.fullpath = os.path.join(new_parent_path, object.fullpath[len(old):].lstrip('\\/'))
            object.parent_folder_path = os.path.join(new_parent_path, object.parent_folder_path[len(old):].lstrip('\\/'))

            print(object.fullpath)
            print(object.parent_folder_path)

    if pre_state == 1:
        pctl.revert()


def clean_folder(index, do=False):

    track = pctl.master_library[index]

    if track.is_network:
        show_message("Cannot clean", 'info', "One or more tracks is from a network location!")
        return

    folder = track.parent_folder_path
    found = 0
    to_purge = []
    if not os.path.isdir(folder):
        return 0
    try:
        for item in os.listdir(folder):
            if ('AlbumArt' == item[:8] and '.jpg' in item.lower()) \
                    or 'desktop.ini' == item\
                    or 'Thumbs.db' == item\
                    or '.DS_Store' == item:

                to_purge.append(item)
                found += 1
            elif "__MACOSX" == item and os.path.isdir(os.path.join(folder, item)):
                found += 1
                found += 1
                if do:
                    print("Deleting Folder: " + os.path.join(folder, item))
                    shutil.rmtree(os.path.join(folder, item))

        if do:
            for item in to_purge:
                if os.path.isfile(os.path.join(folder, item)):
                    print('Deleting File: ' + os.path.join(folder, item))
                    os.remove(os.path.join(folder, item))
            clear_img_cache()
    except Exception as e:
        #show_message(str(e))
        show_message("Error deleting files.", 'warning', "May not have permission or file may be set to read-only")
        return 0

    return found



def reset_play_count(index):

    star_store.remove(index)


#track_menu.add_to_sub("Reset Track Play Count", 0, reset_play_count, pass_ref=True)


def vacuum_playtimes(index):

    todo = []
    for k in default_playlist:
        if pctl.master_library[index].parent_folder_name == pctl.master_library[k].parent_folder_name:
            todo.append(k)

    for track in todo:

        tr = pctl.g(track)

        total_playtime = 0
        flags = ""

        to_del = []

        for key, value in star_store.db.items():
            if key[0].lower() == tr.artist.lower() and tr.artist and key[1].lower().replace(" ", "") == tr.title.lower().replace(" ", "") and tr.title:
                to_del.append(key)
                total_playtime += value[0]
                flags = "".join(set(flags + value[1]))

        for key in to_del:
            del star_store.db[key]

        key = star_store.object_key(tr)
        value = [total_playtime, flags]
        if key not in star_store.db:
            print("Saving value")
            star_store.db[key] = value
        else:
            print("ERROR KEY ALREADY HERE?")




def reload_metadata(input, keep_star=True):
    global todo

    # vacuum_playtimes(index)
    # return
    todo = []

    if isinstance(input, list):
        todo = input

    else:
        for k in default_playlist:
            if pctl.master_library[input].parent_folder_name == pctl.master_library[k].parent_folder_name:
                #if pctl.master_library[k].is_cue == False:
                    todo.append(pctl.master_library[k])

    for i in reversed(range(len(todo))):
        if todo[i].is_cue:
            del todo[i]

    for track in todo:

        print('Reloading Metadata for ' + track.filename)

        if keep_star:
            star = star_store.full_get(track.index)
            star_store.remove(track.index)

        pctl.master_library[track.index] = tag_scan(track)

        if keep_star:
            if star is not None and (star[0] > 0 or star[1]):
                star_store.insert(track.index, star)

            tauon.worker_save_state = True


def reload_metadata_selection():

    cargo = []
    for item in shift_selection:
        cargo.append(default_playlist[item])

    todo = []

    for k in cargo:
        if pctl.master_library[k].is_cue == False:
            todo.append(k)

    for track in todo:

        print('Reloading Metadate for ' + pctl.master_library[track].filename)

        star = star_store.full_get(track)
        star_store.remove(track)
        pctl.master_library[track] = tag_scan(pctl.master_library[track])

        if star is not None and (star[0] > 0 or star[1]):
            star_store.insert(track, star)



def editor(index):
    todo = []
    obs = []

    if key_shift_down and index is not None:
        todo = [index]
        obs = [pctl.master_library[index]]
    else:
        if index is None:
            for item in shift_selection:
                todo.append(default_playlist[item])
                obs.append(pctl.master_library[default_playlist[item]])
            if len(todo) > 0:
                index = todo[0]
        else:
            for k in default_playlist:
                if pctl.master_library[index].parent_folder_path == pctl.master_library[k].parent_folder_path:
                    if pctl.master_library[k].is_cue == False:
                        todo.append(k)
                        obs.append(pctl.master_library[k])

    # Keep copy of play times
    old_stars = []
    for track in todo:
        item = []
        item.append(pctl.g(track))
        item.append(star_store.key(track))
        item.append(star_store.full_get(track))
        old_stars.append(item)


    file_line = ""
    for track in todo:
        file_line += ' "'
        file_line += pctl.master_library[track].fullpath
        file_line += '"'

    if system == "windows":
        file_line = file_line.replace("/", "\\")

    prefix = ""
    app = prefs.tag_editor_target

    if system == "windows" and app:
        if app[0] != '"':
            app = '"' + app
        if app[-1] != '"':
            app = app + '"'

    app_switch = ""

    ok = False


    prefix = launch_prefix

    if system == "linux":
        ok = whicher(prefs.tag_editor_target)
    else:

        if not os.path.isfile(prefs.tag_editor_target.strip('"')):
            print(prefs.tag_editor_target)
            show_message("Application not found", "info", prefs.tag_editor_target)
            return

        ok = True

    # if flatpak_mode:
    #     print("Finding app from within Flatpak...")
    #     complete = subprocess.run(shlex.split("flatpak-spawn --host which " + prefs.tag_editor_target), stdout=subprocess.PIPE,
    #                               stderr=subprocess.PIPE)
    #
    #     print("Host which is:")
    #     r = complete.stdout.decode()
    #
    #     if "bin/" + prefs.tag_editor_target in r:
    #         ok = True
    #         prefix = "flatpak-spawn --host "
    #         print("Found app on host")
    #
    # elif shutil.which(prefs.tag_editor_target):
    #         ok = True

    if not ok:
        show_message(_("Tag editior app does not appear to be installed."), 'warning')

        if flatpak_mode:
            show_message(_("App not found on host OR insufficient Flatpak permissions."), 'bubble', 'See https://github.com/Taiko2k/TauonMusicBox/wiki/Flatpak-Permissions for details.')

        return

    if 'picard' in prefs.tag_editor_target:
        app_switch = " --d "

    line = prefix + app + app_switch + file_line

    show_message(prefs.tag_editor_name + " launched.", 'arrow', "Fields will be updated once application is closed.")
    gui.update = 1

    complete = subprocess.run(shlex.split(line), stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    if 'picard' in prefs.tag_editor_target:
        r = complete.stderr.decode()
        for line in r.split("\n"):
            if 'file._rename' in line and ' Moving file ' in line:
                a, b = line.split(" Moving file ")[1].split(" => ")
                a = a.strip("'").strip('"')
                b = b.strip("'").strip('"')

                for track in todo:
                    if pctl.master_library[track].fullpath == a:
                        pctl.master_library[track].fullpath = b
                        pctl.master_library[track].filename = os.path.basename(b)
                        print("External Edit: File rename detected.")
                        print("    Renaming: " + a)
                        print("          To: " + b)
                        break
                else:
                    print("External Edit: A file rename was detected but track was not found.")

    gui.message_box = False
    reload_metadata(obs, keep_star=False)

    # Re apply playtime data in case file names change
    for item in old_stars:

        old_key = item[1]
        old_value = item[2]

        if not old_value:  # ignore if there was no old playcount metadata
            continue

        new_key = star_store.object_key(item[0])
        new_value = star_store.full_get(item[0].index)

        if old_key == new_key:
            continue

        if new_value is None:
            new_value = [0, ""]

        new_value[0] += old_value[0]
        new_value[1] = "".join(set(new_value[1] + old_value[1]))

        if old_key in star_store.db:
            del star_store.db[old_key]

        star_store.db[new_key] = new_value


    gui.pl_update = 1
    gui.update = 1
    tauon.worker_save_state = True


def launch_editor(index):
    mini_t = threading.Thread(target=editor, args=[index])
    mini_t.daemon = True
    mini_t.start()

def launch_editor_selection(index):
    mini_t = threading.Thread(target=editor, args=[None])
    mini_t.daemon = True
    mini_t.start()

# track_menu.add('Reload Metadata', reload_metadata, pass_ref=True)
track_menu.add_to_sub(_("Reload Metadata"), 0, reload_metadata, pass_ref=True)


mbp_icon = MenuIcon(asset_loader('mbp-g.png'))
mbp_icon.base_asset = asset_loader('mbp-gs.png')

mbp_icon.xoff = 2
mbp_icon.yoff = -1

if gui.scale == 1.25:
    mbp_icon.yoff = 0

edit_icon = None
if prefs.tag_editor_name == "Picard":
    edit_icon = mbp_icon

def edit_deco():

    if key_shift_down or key_shiftr_down:
        return [colours.menu_text, colours.menu_background, prefs.tag_editor_name + " (Single track)"]
    else:
        return [colours.menu_text, colours.menu_background, _("Edit with ") + prefs.tag_editor_name]

track_menu.add_to_sub("Edit with", 0, launch_editor, pass_ref=True, icon=edit_icon, render_func=edit_deco)



def show_lyrics_menu(index):
    global track_box
    track_box = False
    switch_showcase(r_menu_index)
    input.mouse_click = False

track_menu.add_to_sub(_("Lyrics..."), 0, show_lyrics_menu, pass_ref=True)

def recode(text, enc):
    return text.encode("Latin-1", 'ignore').decode(enc, 'ignore')

j_chars = "ããããããããã¾ãã¯ãªãããã¿ãã²ã«ã¡ãããããã¬ã¤ããããã¸ã­ã¦ãããããã»ã®ã¨ããã¢ã¤ã¦ã¨ãªã³ã²ã©ãããã¿ãµã«ããããã·ã­ã«ã¦ã ãããã¹ã¯ã¬ã¡ãããã»ã±ã­ã¨ã¢ãããã½ã³"

def intel_moji(index):

    gui.pl_update += 1
    gui.update += 1

    track = pctl.master_library[index]

    lot = []

    for item in default_playlist:

        if track.album == pctl.master_library[item].album and \
            track.parent_folder_name == pctl.master_library[item].parent_folder_name:
            lot.append(item)

    lot = set(lot)


    l_artist = track.artist.encode("Latin-1", 'ignore')
    l_album = track.album.encode("Latin-1", 'ignore')
    detect = None

    if track.artist not in track.parent_folder_path:
        for enc in encodings:
            try:
                q_artist = l_artist.decode(enc,)
                if q_artist.strip(" ") in track.parent_folder_path.strip(" "):
                    detect = enc
                    break
            except:
                continue


    if detect is None and track.album not in track.parent_folder_path:
        for enc in encodings:
            try:
                q_album = l_album.decode(enc,)
                if q_album in track.parent_folder_path:
                    detect = enc
                    break
            except:
                continue

    for item in lot:
        t_track = pctl.master_library[item]

        if detect is None:
            for enc in encodings:
                test = recode(t_track.artist, enc)
                for cha in test:
                    if cha in j_chars:
                        detect = enc
                        print("This looks like Japanese: " + test)
                        break
                    if detect is not None:
                        break

        if detect is None:
            for enc in encodings:
                test = recode(t_track.title, enc)
                for cha in test:
                    if cha in j_chars:
                        detect = enc
                        print("This looks like Japanese: " + test)
                        break
                    if detect is not None:
                        break
        if detect is not None:
            break

    if detect is not None:
        print("Fix Mojibake: Detected encoding as: " + detect)
        for item in lot:
            track = pctl.master_library[item]
            #key = pctl.master_library[item].title + pctl.master_library[item].filename
            key = star_store.full_get(item)
            star_store.remove(item)

            track.title = recode(track.title, detect)
            track.album = recode(track.album, detect)
            track.artist = recode(track.artist, detect)
            track.album_artist = recode(track.album_artist, detect)
            track.genre = recode(track.genre, detect)
            track.comment = recode(track.comment, detect)
            track.lyrics = recode(track.lyrics, detect)

            if key != None:
                star_store.insert(item, key)

    else:
        show_message("Autodetect failed")


track_menu.add_to_sub(_("Fix Mojibake"), 0, intel_moji, pass_ref=True)

def sel_to_car():

    global default_playlist
    cargo = []

    for item in shift_selection:
        cargo.append(default_playlist[item])


# track_menu.add_to_sub("Copy Playlist", 1, transfer, pass_ref=True, args=[1, 3])
def cut_selection():
    sel_to_car()
    del_selected()

def clip_ar_al(index):
    line = pctl.master_library[index].artist + " - " + \
           pctl.master_library[index].album
    SDL_SetClipboardText(line.encode('utf-8'))

def clip_ar(index):
    if pctl.master_library[index].album_artist != "":
        line = pctl.master_library[index].album_artist
    else:
        line = pctl.master_library[index].artist
    SDL_SetClipboardText(line.encode('utf-8'))

def clip_title(index):

    n_track = pctl.master_library[index]

    if not prefs.use_title and n_track.album_artist != "" and n_track.album != "":
        line = n_track.album_artist + " - " + n_track.album
    else:
        line = n_track.parent_folder_name

    SDL_SetClipboardText(line.encode('utf-8'))

selection_menu = Menu(190, show_icons=False)
folder_menu = Menu(190, show_icons=True)

folder_menu.add(_('Open Folder'), open_folder, pass_ref=True, icon=folder_icon)

folder_menu.add(_("Modify Folderâ¦"), rename_folders, pass_ref=True, icon=mod_folder_icon)
# folder_menu.add(_("Add Album to Queue"), add_album_to_queue, pass_ref=True)
folder_menu.add(_("Add Album to Queue"), add_album_to_queue, pass_ref=True)
folder_menu.add(_("â³ After Current Album"), add_album_to_queue_fc, pass_ref=True)

gallery_menu.add(_("Modify Folderâ¦"), rename_folders, pass_ref=True, icon=mod_folder_icon)

folder_menu.add(_("Rename Tracksâ¦"), rename_tracks, pass_ref=True, icon=rename_tracks_icon)

folder_menu.add("Edit with", launch_editor_selection, pass_ref=True,
                   icon=edit_icon, render_func=edit_deco)

def lightning_copy():
    s_copy()
    gui.lightning_copy = True

#selection_menu.br()

def toggle_transcode(mode=0):
    if mode == 1:
        return prefs.enable_transcode
    prefs.enable_transcode ^= True

def toggle_transfer(mode=0):
    if mode == 1:
        return prefs.show_transfer
    prefs.show_transfer ^= True

    if prefs.show_transfer:

        show_message("Warning! Using this function moves physical folders.", 'info', "This menu entry appears after selecting 'copy'. See manual (github wiki) for more info.")


transcode_icon.colour = [239, 74, 157, 255]

def transcode_deco():

    if key_shift_down or key_shiftr_down:
        return [colours.menu_text, colours.menu_background, _("Transcode Single")]
    else:
        return [colours.menu_text, colours.menu_background, _('Transcode Folder')]


folder_menu.add(_('Reload Metadata'), reload_metadata, pass_ref=True)
folder_menu.add(_('Vacuum Playtimes'), vacuum_playtimes, pass_ref=True, show_test=test_shift)
folder_menu.add(_('Transcode Folder'), convert_folder, transcode_deco, pass_ref=True, icon=transcode_icon, show_test=toggle_transcode)
gallery_menu.add(_('Transcode Folder'), convert_folder, transcode_deco, pass_ref=True, icon=transcode_icon, show_test=toggle_transcode)
folder_menu.br()

# Copy album title text to clipboard
folder_menu.add(_('Copy "Album Title"'), clip_title, pass_ref=True)
# Copy artist name text to clipboard
folder_menu.add(_('Copy "Artist"'), clip_ar, pass_ref=True)

selection_menu.add(_('Reload Metadata'), reload_metadata_selection)

selection_menu.add("Edit with ", launch_editor_selection, pass_ref=True, icon=edit_icon, render_func=edit_deco)

selection_menu.br()
folder_menu.br()

# It's complicated
# folder_menu.add(_('Copy Folder From Library'), lightning_copy)

selection_menu.add(_('Copy'), s_copy)
selection_menu.add(_('Cut'), s_cut)
selection_menu.add(_('Remove'), del_selected)
selection_menu.add(_('Delete Files'), force_del_selected, show_test=test_shift, icon=delete_icon)

folder_menu.add(_('Copy'), s_copy)
gallery_menu.add(_('Copy'), s_copy)
# folder_menu.add(_('Cut'), s_cut)
folder_menu.add(_('Transfer Folder Here'), lightning_paste, pass_ref=False, show_test=lightning_move_test)
gallery_menu.add(_('Transfer Folder Here'), lightning_paste, pass_ref=False, show_test=lightning_move_test)
folder_menu.add(_('Remove'), del_selected)
gallery_menu.add(_('Remove'), del_selected)

def toggle_rym(mode=0):
    if mode == 1:
        return prefs.show_rym
    prefs.show_rym ^= True

def toggle_wiki(mode=0):
    if mode == 1:
        return prefs.show_wiki
    prefs.show_wiki ^= True


def toggle_show_discord(mode=0):
    if mode == 1:
        return prefs.discord_show
    prefs.discord_show ^= True

def toggle_gen(mode=0):
    if mode == 1:
        return prefs.show_gen
    prefs.show_gen ^= True


def ser_rym(index):
    if len(pctl.master_library[index].artist) < 2:
        return
    line = "http://rateyourmusic.com/search?searchtype=a&searchterm=" + urllib.parse.quote(pctl.master_library[index].artist)
    webbrowser.open(line, new=2, autoraise=True)


def copy_to_clipboard(text):
    SDL_SetClipboardText(text.encode())

def copy_from_clipboard():
    return SDL_GetClipboardText().decode()


def clip_aar_al(index):
    if pctl.master_library[index].album_artist == "":
        line = pctl.master_library[index].artist + " - " + \
               pctl.master_library[index].album
    else:
        line = pctl.master_library[index].album_artist + " - " + \
               pctl.master_library[index].album
    SDL_SetClipboardText(line.encode('utf-8'))


def ser_gen(index):
    if len(pctl.master_library[index].title) < 1:
        return

    line = "https://genius.com/search?q=" + \
           urllib.parse.quote(pctl.master_library[index].artist + " " + pctl.master_library[index].title)
    webbrowser.open(line, new=2, autoraise=True)

def ser_wiki(index):
    if len(pctl.master_library[index].artist) < 2:
        return
    line = "http://en.wikipedia.org/wiki/Special:Search?search=" + \
           urllib.parse.quote(pctl.master_library[index].artist)
    webbrowser.open(line, new=2, autoraise=True)


track_menu.add(_('Search Artist on Wikipedia'), ser_wiki, pass_ref=True, show_test=toggle_wiki)

track_menu.add(_('Search Track on Genius'), ser_gen, pass_ref=True, show_test=toggle_gen)

son_icon = MenuIcon(asset_loader('sonemic-g.png'))
son_icon.base_asset = asset_loader('sonemic-gs.png')

son_icon.xoff = 1
track_menu.add(_('Search Artist on Sonemic'), ser_rym, pass_ref=True, icon=son_icon, show_test=toggle_rym)


def clip_ar_tr(index):
    line = pctl.master_library[index].artist + " - " + \
           pctl.master_library[index].title

    SDL_SetClipboardText(line.encode('utf-8'))

# Copy metadata to clipboard
track_menu.add(_('Copy "Artist - Album"'), clip_aar_al, pass_ref=True)
# Copy metadata to clipboard
track_menu.add(_('Copy "Artist - Track"'), clip_ar_tr, pass_ref=True)


def drop_tracks_to_new_playlist(track_list):
    pl = new_playlist(False)
    albums = []
    artists = []
    for item in track_list:
        albums.append(pctl.g(default_playlist[item]).album)
        artists.append(pctl.g(default_playlist[item]).artist)
        pctl.multi_playlist[pl][2].append(default_playlist[item])


    if len(track_list) > 1:
        if len(albums) > 0 and albums.count(albums[0]) == len(albums):
            track = pctl.g(default_playlist[track_list[0]])
            artist = track.artist
            if track.album_artist != "":
                artist = track.album_artist
            pctl.multi_playlist[pl][0] = artist + " - " + albums[0][:50]

    elif len(track_list) == 1 and artists:
        pctl.multi_playlist[pl][0] = artists[0]

    tauon.worker_save_state = True



def queue_deco():
    if len(pctl.force_queue) > 0:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled

    return [line_colour, colours.menu_background, None]


def broadcast_feature_deco():
    return menu_standard_or_grey(pctl.broadcast_active)


def broadcast_select_track(index):
    if pctl.broadcast_active:
        pctl.broadcast_index = index
        pctl.broadcast_playlist = copy.deepcopy(pctl.multi_playlist[pctl.active_playlist_viewing][6])

        pctl.broadcast_position = default_playlist.index(pctl.broadcast_index)
        pctl.broadcast_time = 0
        pctl.target_open = pctl.master_library[pctl.broadcast_index].fullpath
        pctl.b_start_time = pctl.master_library[pctl.broadcast_index].start_time
        pctl.playerCommand = "cast-next"
        pctl.playerCommandReady = True
        pctl.broadcast_line = pctl.master_library[pctl.broadcast_index].artist + " - " + \
                              pctl.master_library[pctl.broadcast_index].title

if prefs.enable_transcode or prefs.backend == 1:
    track_menu.br()


track_menu.add(_('Transcode Folder'), convert_folder, transcode_deco, pass_ref=True, icon=transcode_icon, show_test=toggle_transcode)

if prefs.backend == 1:
    track_menu.add(_('Broadcast This'), broadcast_select_track, broadcast_feature_deco, pass_ref=True)

# Create top menu
x_menu = Menu(190, show_icons=True)
view_menu = Menu(170)
set_menu = Menu(150)
set_menu_hidden = Menu(100)
vis_menu = Menu(140)
field_menu = Menu(140)
dl_menu = Menu(90)

def field_copy(text_field):
    text_field.copy()



def field_paste(text_field):
    text_field.paste()

def field_clear(text_field):
    text_field.clear()

# Copy text
field_menu.add(_("Copy"), field_copy, pass_ref=True)
# Paste text
field_menu.add(_("Paste"), field_paste, pass_ref=True)
# Clear text
field_menu.add(_("Clear"), field_clear, pass_ref=True)


def vis_off():
    gui.vis_want = 0
    gui.update_layout()
    # gui.turbo = False

vis_menu.add(_("Off"), vis_off)

def level_on():
    if gui.vis_want == 1 and gui.turbo is True:
        gui.level_meter_colour_mode += 1
        if gui.level_meter_colour_mode > 4:
            gui.level_meter_colour_mode = 0

    gui.vis_want = 1
    gui.update_layout()
    #gui.turbo = True
vis_menu.add(_("Level Meter"), level_on)

def spec_on():
    gui.vis_want = 2
    gui.update_layout()
vis_menu.add(_("Spectrum Visualizer"), spec_on)

def spec2_def():

    if gui.vis_want == 3:
        prefs.spec2_colour_mode += 1
        if prefs.spec2_colour_mode > 1:
            prefs.spec2_colour_mode = 0

    gui.vis_want = 3
    #gui.turbo = True
    prefs.spec2_colour_setting = 'custom'
    gui.update_layout()

vis_menu.add(_("Spectrogram"), spec2_def)

def sa_remove(h):
    if len(gui.pl_st) > 1:
        del gui.pl_st[h]
        gui.update_layout()
    else:
        show_message("Cannot remove the only column.")

def sa_artist():
    gui.pl_st.append(["Artist", 220, False])
    gui.update_layout()
def sa_album_artist():
    gui.pl_st.append(["Album Artist", 220, False])
    gui.update_layout()
def sa_composer():
    gui.pl_st.append(["Composer", 220, False])
    gui.update_layout()
def sa_title():
    gui.pl_st.append(["Title", 220, False])
    gui.update_layout()
def sa_album():
    gui.pl_st.append(["Album", 220, False])
    gui.update_layout()
def sa_comment():
    gui.pl_st.append(["Comment", 300, False])
    gui.update_layout()
def sa_track():
    gui.pl_st.append(["T", 25, True])
    gui.update_layout()
def sa_count():
    gui.pl_st.append(["P", 25, True])
    gui.update_layout()
def sa_time():
    gui.pl_st.append(["Time", 55, True])
    gui.update_layout()
def sa_date():
    gui.pl_st.append(["Date", 55, True])
    gui.update_layout()
def sa_genre():
    gui.pl_st.append(["Genre", 150, False])
    gui.update_layout()
def sa_file():
    gui.pl_st.append(["Filepath", 350, False])
    gui.update_layout()
def sa_codec():
    gui.pl_st.append(["Codec", 65, True])
    gui.update_layout()
def sa_bitrate():
    gui.pl_st.append(["Bitrate", 65, True])
    gui.update_layout()
def sa_lyrics():
    gui.pl_st.append(["Lyrics", 50, True])
    gui.update_layout()
def sa_star():
    gui.pl_st.append(["Starline", 80, True])
    gui.update_layout()
def sa_love():
    gui.pl_st.append(["â¤", 25, True])
    gui.update_layout()

def key_love(index):
    return get_love_index(index)

def key_artist(index):
    return pctl.master_library[index].artist

def key_album_artist(index):
    return pctl.master_library[index].album_artist

def key_composer(index):
    return pctl.master_library[index].composer

def key_comment(index):
    return pctl.master_library[index].comment

def key_title(index):
    return pctl.master_library[index].title

def key_album(index):
    return pctl.master_library[index].album

def key_duration(index):
    return pctl.master_library[index].length

def key_date(index):
    return pctl.master_library[index].date

def key_genre(index):
    return pctl.master_library[index].genre

def key_t(index):
    #return str(pctl.master_library[index].track_number)
    return index_key(index)

def key_codec(index):
    return pctl.master_library[index].file_ext

def key_bitrate(index):
    return pctl.master_library[index].bitrate

def key_p(index):
    return pctl.master_library[index].bitrate

def key_hl(index):
    if len(pctl.master_library[index].lyrics) > 5:
        return 0
    else:
        return 1

def sort_ass(h, invert=False):
    global default_playlist

    if pl_is_locked(pctl.active_playlist_viewing):
        show_message("Playlist is locked")
        return

    name = gui.pl_st[h][0]
    key = None

    if name == "Artist":
        key = key_artist
    if name == "Album Artist":
        key = key_album_artist
    if name == "Title":
        key = key_title
    if name == "Album":
        key = key_album
    if name == "Composer":
        key = key_composer
    if name == "Time":
        key = key_duration
    if name == "Date":
        key = key_date
    if name == "Genre":
        key = key_genre
    if name == "T":
        key = key_t
    if name == "P":
        key = key_playcount
    if name == 'Starline':
        key = best
    if name == 'Comment':
        key = key_comment
    if name == "Codec":
        key = key_codec
    if name == "Bitrate":
        key = key_bitrate
    if name == "Lyrics":
        key = key_hl
    if name == "â¤":
        key = key_love

    if key is not None:
        playlist = pctl.multi_playlist[pctl.active_playlist_viewing][2]
        playlist.sort(key=key)

        if invert:
            playlist = list(reversed(playlist))

        pctl.multi_playlist[pctl.active_playlist_viewing][2] = playlist
        default_playlist = pctl.multi_playlist[pctl.active_playlist_viewing][2]

    pctl.playlist_view_position = 0
    gui.pl_update = 1


def sort_dec(h):
    sort_ass(h, True)


def hide_set_bar():
    gui.set_bar = False
    gui.update_layout()
    gui.pl_update = 1

def show_set_bar():
    gui.set_bar = True
    gui.update_layout()
    gui.pl_update = 1

set_menu.add("Sort Ascending", sort_ass, pass_ref=True, disable_test=view_pl_is_locked, pass_ref_deco=True)
set_menu.add("Sort Decending", sort_dec, pass_ref=True, disable_test=view_pl_is_locked, pass_ref_deco=True)
set_menu.br()
set_menu.add("Hide bar", hide_set_bar)
set_menu_hidden.add("Show bar", show_set_bar)
set_menu.br()
set_menu.add("+ Artist", sa_artist)
set_menu.add("+ Title", sa_title)
set_menu.add("+ Album", sa_album)
set_menu.add("+ Album Artist", sa_album_artist)
set_menu.add("+ Composer", sa_composer)
set_menu.add("+ Duration", sa_time)
set_menu.add("+ Date", sa_date)
set_menu.add("+ Genre", sa_genre)
set_menu.add("+ Track Number", sa_track)
set_menu.add("+ Play Count", sa_count)
set_menu.add("+ Codec", sa_codec)
set_menu.add("+ Bitrate", sa_bitrate)
set_menu.add("+ Has Lyrics", sa_lyrics)
set_menu.add("+ Comment", sa_comment)
set_menu.add("+ Filepath", sa_file)
set_menu.add("+ Starline", sa_star)
set_menu.add("+ Loved", sa_love)
set_menu.br()
set_menu.add("- Remove This", sa_remove, pass_ref=True)


def bass_features_deco():
    line_colour = colours.menu_text
    if prefs.backend != 1:
        line_colour = colours.menu_text_disabled
    return [line_colour, colours.menu_background, None]


def toggle_dim_albums(mode=0):
    if mode == 1:
        return prefs.dim_art

    prefs.dim_art ^= True
    gui.pl_update = 1
    gui.update += 1


def toggle_gallery_click(mode=0):
    if mode == 1:
        return prefs.gallery_single_click

    prefs.gallery_single_click ^= True


def toggle_galler_text(mode=0):
    if mode == 1:
        return gui.gallery_show_text

    gui.gallery_show_text ^= True
    gui.update += 1
    update_layout_do()

    # Jump to playing album
    if album_mode and gui.first_in_grid is not None:

        if gui.first_in_grid < len(default_playlist):
            goto_album(gui.first_in_grid, force=True)

def toggle_card_style(mode=0):
    if mode == 1:
        return prefs.use_card_style

    prefs.use_card_style ^= True
    gui.update += 1


def toggle_side_panel(mode=0):
    global update_layout
    global album_mode

    if mode == 1:
        return prefs.prefer_side

    prefs.prefer_side ^= True
    update_layout = True

    if album_mode:
        gui.rsp = True
    elif prefs.prefer_side is True:
        gui.rsp = True
    else:
        gui.rsp = False

    if prefs.prefer_side:
        gui.rspw = gui.pref_rspw


def toggle_combo_view(mode=0, showcase=False, off=False):
    global update_layout
    global old_side_pos

    if mode == 1:
        return gui.combo_mode

    if not off:
        if showcase:
            gui.showcase_mode = True
        else:
            if gui.combo_mode and gui.showcase_mode:
                gui.showcase_mode = False
                return
            gui.showcase_mode = False

    if gui.combo_mode is False:
        if not album_mode:
            old_side_pos = gui.rspw
        gui.combo_mode = True
        reload_albums()

        if album_mode:
            toggle_album_mode()
        if gui.rsp:
            gui.rsp = False
    else:
        gui.combo_mode = False

        gall_ren.size = album_mode_art_size
        if prefs.prefer_side:
            gui.rsp = True
        gui.rspw = old_side_pos
    update_layout = True


def standard_size():
    global album_mode
    global window_size
    global update_layout

    global album_mode_art_size

    album_mode = False
    gui.rsp = True
    window_size = window_default_size
    SDL_SetWindowSize(t_window, window_size[0], window_size[1])

    gui.rspw = 80 + int(window_size[0] * 0.18)
    update_layout = True
    album_mode_art_size = 130
    clear_img_cache()


def goto_album(playlist_no, down=False, force=False):

    # (down flag not curretly used)
    global album_pos_px
    global album_dex

    px = 0
    row = 0
    re = 0

    for i in range(len(album_dex)):
        if i == len(album_dex) - 1:
            re = i
            break
        if album_dex[i + 1] - 1 > playlist_no - 1:
            re = i
            break
        row += 1
        if row > row_len - 1:
            row = 0
            px += album_mode_art_size + album_v_gap


    # If the album is within the view port already, dont jump to it
    # (unless we really want to with force)
    if not force and album_pos_px - 20 < px < album_pos_px + window_size[1]:

        # Dont chance the view since its alread in the view port
        # But if the album is just out of view on the bottom, bring it into view on to bottom row
        if down or True and window_size[1] > (album_mode_art_size + album_v_gap) * 2:
            while not album_pos_px - 20 < px + (album_mode_art_size + album_v_gap + 3) < album_pos_px + window_size[
                1] - 40:
                album_pos_px += 1

    else:
        # Set the view to the calculated position
        album_pos_px = px - 60
        album_pos_px += 10

        if album_pos_px < 0 - 55:
            album_pos_px = 0 - 55



    if len(album_dex) > 0:
        return album_dex[re]
    else:
        return 0

def toggle_album_mode(force_on=False):
    global album_mode
    global window_size
    global update_layout
    global old_side_pos
    global album_playlist_width
    global old_album_pos
    global album_pos_px
    global themeChange

    gui.gall_tab_enter = False

    # if prefs.colour_from_image:
    #     #prefs.colour_from_image = False
    #     themeChange = True

    # if gui.show_playlist is False:
    #     gui.show_playlist = True
    #     #gui.playlist_width = album_playlist_width  # int(window_size[0] * 0.25)
    #     #gui.rspw = window_size[0] - gui.plw
    #     if force_on:
    #         return

    if album_mode is True:

        album_mode = False
        #album_playlist_width = gui.playlist_width
        #old_album_pos = album_pos_px
        gui.rspw = gui.pref_rspw
        gui.rsp = prefs.prefer_side
        #gui.rspw = old_side_pos
        gui.album_tab_mode = False
    else:
        if gui.combo_mode:
            toggle_combo_view(off=True)
        album_mode = True
        gui.rsp = True

        #old_side_pos = gui.rspw
        gui.rspw = gui.pref_gallery_w


    if album_mode and gui.set_mode and len(gui.pl_st) > 7:
        gui.set_mode = False
        #gui.set_bar = False
        gui.pl_update = True
        gui.update_layout()

    reload_albums()

    goto_album(pctl.playlist_playing_position)


def activate_info_box():
    fader.rise()
    pref_box.enabled = True


def activate_radio_box():
    global radiobox
    radiobox = True


add_icon.xoff = 3
add_icon.yoff = 0
add_icon.colour = [237, 80 ,221, 255] #[230, 118, 195, 225]#[237, 75, 218, 255]

x_menu.add(_("New Playlist"), new_playlist, icon=add_icon)

def bass_test(_):
    return prefs.backend == 1

x_menu.add(_("Open Streamâ¦"), activate_radio_box, show_test=bass_test)


def show_import_music(_):
    return gui.add_music_folder_ready

def import_music():

    pl = pl_gen("Music")
    pl[7] = music_folder
    pctl.multi_playlist.append(pl)
    load_order = LoadClass()
    load_order.target = music_folder
    load_order.playlist = pl[6]
    load_orders.append(load_order)
    switch_playlist(len(pctl.multi_playlist) - 1)
    gui.add_music_folder_ready = False


x_menu.add(_("Import  ~/Music"), import_music, show_test=show_import_music)

x_menu.br()

settings_icon.xoff = 0
settings_icon.yoff = 2
settings_icon.colour = [232, 200, 96, 255]#[230, 152, 118, 255]#[173, 255, 47, 255] #[198, 237, 56, 255]
#settings_icon.colour = [180, 140, 255, 255]
x_menu.add(_("Settings"), activate_info_box, icon=settings_icon)
x_menu.add_sub(_("Databaseâ¦"), 190)
x_menu.br()

# x_menu.add('Toggle Side panel', toggle_combo_view, combo_deco)

def stt2(sec):
    days, rem = divmod(sec, 86400)
    hours, rem = divmod(rem, 3600)
    min, sec = divmod(rem, 60)

    s_day = str(days) + 'd'
    if s_day == '0d':
        s_day = "  "

    s_hours = str(hours) + 'h'
    if s_hours == '0h' and s_day == '  ':
        s_hours = "  "

    s_min = str(min) + 'm'

    return s_day.rjust(3) + ' ' + s_hours.rjust(3) + ' ' + s_min.rjust(3)

def export_database():
    xport = open(user_directory + '/DatabaseExport.csv', 'wb')
    for index, track in pctl.master_library.items():

        line = []
        line.append(str(track.artist))
        line.append(str(track.title))
        line.append(str(track.album))
        line.append(str(track.album_artist))
        line.append(str(track.track_number))
        if track.is_cue is False:
            line.append('FILE')
        else:
            line.append('CUE')
        line.append(str(track.length))
        line.append(str(track.date))
        line.append(track.genre)
        line.append(str(int(star_store.get_by_object(track))))
        line.append(track.fullpath)

        for g in range(len(line)):
            line[g] = line[g].encode('utf-8')

        # exporter.writerow(line)
        outline = b""
        for item in line:
            outline += '"'.encode('utf-8')
            outline += item
            outline += '",'.encode('utf-8')
        outline += '\r\n'.encode('utf-8')
        xport.write(outline)

    xport.close()
    show_message("Export complete.", 'done',  "Saved as 'DatabaseExport.csv'.")


def q_to_playlist():

    pctl.multi_playlist.append(pl_gen(title="Play History",
                                      playing=0,
                                      playlist=list(reversed(copy.deepcopy(pctl.track_queue))),
                                      position=0,
                                      hide_title=1,
                                      selected=0))



x_menu.add_to_sub(_("Export as CSV"), 0, export_database)
x_menu.add_to_sub(_("Play History to Playlist"), 0, q_to_playlist)
x_menu.add_to_sub(_("Reset Image Cache"), 0, clear_img_cache)


def reset_missing_flags():
    for index in default_playlist:
        pctl.master_library[index].found = True


cm_clean_db = False


def clean_db():
    global cm_clean_db
    cm_clean_db = True


x_menu.add_to_sub(_("Remove Missing Tracks"), 0, clean_db)

x_menu.add_to_sub(_("Mark Missing as Found"), 0, reset_missing_flags)


def toggle_broadcast():

    if pctl.broadcast_active is not True:
        if len(default_playlist) == 0:
            show_message("There are no tracks in this playlist to broadcast.", 'error')
            return 0
        pctl.broadcast_playlist = copy.deepcopy(pctl.multi_playlist[pctl.active_playlist_viewing][6])
        pctl.broadcast_position = 0

        pctl.broadcast_index = pctl.multi_playlist[pctl.active_playlist_viewing][2][pctl.broadcast_position]
        pctl.target_open = pctl.master_library[pctl.broadcast_index].fullpath
        pctl.broadcast_line = pctl.master_library[pctl.broadcast_index].artist + " - " + \
                              pctl.master_library[pctl.broadcast_index].title

        pctl.playerCommand = "encstart"
        pctl.playerCommandReady = True
    else:
        pctl.playerCommand = "encstop"
        pctl.playerCommandReady = True


def broadcast_deco():
    line_colour = colours.menu_text
    if prefs.backend != 1:
        line_colour = colours.grey(20)
        return [line_colour, colours.menu_background, None]
    if pctl.broadcast_active:
        return [line_colour, colours.menu_background, "Stop Broadcast"] # [24, 25, 60, 255]

    return [line_colour, colours.menu_background, None]

def broadcast_colour():
    if pctl.broadcast_active:
        return [56, 189, 237, 255]
    else:
        if colours.lm:
            return [171, 102, 249, 255]
        return None #[171, 102, 249, 255]



broadcast_icon = MenuIcon(asset_loader('broadcast.png', True))
broadcast_icon.colour = [171, 102, 249, 255]
broadcast_icon.colour_callback = broadcast_colour
x_menu.add(_("Start Broadcast"), toggle_broadcast, broadcast_deco, icon=broadcast_icon, show_test=bass_test)


def clear_queue():
    pctl.force_queue = []
    gui.pl_update = 1
    pctl.pause_queue = False


#x_menu.add('Clear Queue', clear_queue, queue_deco)

mode_menu = Menu(175)

def set_mini_mode_A1():
    prefs.mini_mode_mode = 0
    set_mini_mode()

def set_mini_mode_B1():
    prefs.mini_mode_mode = 1
    set_mini_mode()

def set_mini_mode_A2():
    prefs.mini_mode_mode = 2
    set_mini_mode()

def set_mini_mode_B2():
    prefs.mini_mode_mode = 3
    set_mini_mode()

def set_mini_mode_D():
    prefs.mini_mode_mode = 4
    set_mini_mode()

mode_menu.add(_('Mini Mode'), set_mini_mode_A1)
mode_menu.add(_('Mini Mode Large'), set_mini_mode_A2)
mode_menu.add(_('Mini Mode Square'), set_mini_mode_B1)
mode_menu.add(_('Mini Mode Square Large'), set_mini_mode_B2)
mode_menu.add(_('Mini Mode Micro'), set_mini_mode_D)
# x_menu.add_sub("Playback...", 120)
extra_menu = Menu(175, show_icons=True)



def stop():
    pctl.stop()


# x_menu.add_to_sub('Stop/Eject', 1, stop)
# extra_menu.add('Stop/Eject', stop)

# x_menu.add_to_sub('Advance', 1, pctl.advance)
# x_menu.add_to_sub('Back', 1, pctl.back)

def random_track():
    old = pctl.random_mode
    pctl.random_mode = True
    pctl.advance()
    pctl.random_mode = old


extra_menu.add(_('Random Track'), random_track, hint='COLON')


def radio_random():
    pctl.advance(rr=True)


radiorandom_icon = MenuIcon(asset_loader('radiorandom.png', True))
revert_icon = MenuIcon(asset_loader('revert.png', True))

radiorandom_icon.xoff = 1
radiorandom_icon.yoff = 0
radiorandom_icon.colour = [153, 229, 133, 255]
extra_menu.add(_('Radio Random'), radio_random, hint='/', icon=radiorandom_icon)


revert_icon.xoff = 1
revert_icon.yoff = 0
revert_icon.colour = [229, 102, 59, 255]
extra_menu.add(_('Revert'), pctl.revert, hint='SHIFT + /', icon=revert_icon)


def toggle_repeat():
    pctl.repeat_mode ^= True


# extra_menu.add('Toggle Repeat', toggle_repeat, hint='COMMA')


def toggle_random():
    pctl.random_mode ^= True


# extra_menu.add('Toggle Random', toggle_random, hint='PERIOD')
extra_menu.add(_('Clear Queue'), clear_queue, queue_deco)




def heart_menu_colour():
    if not (pctl.playing_state == 1 or pctl.playing_state == 2):
        if colours.lm:
            return [255, 200, 200, 255]
        return [50, 50, 50, 255]
    if love(False):
        return [245, 60, 60, 255]
    else:
        if colours.lm:
            return [255, 200, 200, 255]
        return None


heart_icon = MenuIcon(asset_loader('heart-menu.png', True))
heart_row_icon = asset_loader('heart-track.png', True)

heart_colours = ColourGenCache(0.7, 0.7)

heart_icon.colour = [245, 60, 60, 255]
heart_icon.xoff = 3
heart_icon.yoff = 0

if gui.scale == 1.25:
    heart_icon.yoff = 1

heart_icon.colour_callback = heart_menu_colour
def love_deco():

    if love(False):
        return [colours.menu_text, colours.menu_background, _("Un-Love Track")]
    else:
        if pctl.playing_state == 1 or pctl.playing_state == 2:
            return [colours.menu_text, colours.menu_background, _("Love Track")]
        else:
            return [colours.menu_text_disabled, colours.menu_background, _("Love Track")]

def bar_love():
    shoot_love = threading.Thread(target=love)
    shoot_love.daemon = True
    shoot_love.start()

extra_menu.add('Love', bar_love, love_deco, icon=heart_icon)

def toggle_search():
    search_over.active = True

extra_menu.add(_('Global Search'), toggle_search, hint="CTRL + G")

def goto_playing_extra():
    pctl.show_current(highlight=True)

extra_menu.add(_("Go To Playing"), goto_playing_extra, hint="QUOTE")


def toggle_auto_theme(mode=0):

    if mode == 1:
        return prefs.colour_from_image

    prefs.colour_from_image ^= True
    gui.theme_temp_current = -1
    global themeChange
    themeChange = True

    if prefs.colour_from_image and prefs.art_bg and not key_shift_down:
        toggle_auto_bg()

def toggle_auto_bg(mode=0):

    if mode == 1:
        return prefs.art_bg
    prefs.art_bg ^= True
    if prefs.art_bg:
        gui.update = 60

    if prefs.colour_from_image and prefs.art_bg and not key_shift_down:
        toggle_auto_theme()

def toggle_auto_bg_strong(mode=0):

    if mode == 1:
        return prefs.art_bg_stronger == 2

    if prefs.art_bg_stronger == 2:
        prefs.art_bg_stronger = 1
    else:
        prefs.art_bg_stronger = 2
    gui.update_layout()

def toggle_auto_bg_strong1(mode=0):

    if mode == 1:
        return prefs.art_bg_stronger == 1
    prefs.art_bg_stronger = 1
    gui.update_layout()

def toggle_auto_bg_strong2(mode=0):

    if mode == 1:
        return prefs.art_bg_stronger == 2
    prefs.art_bg_stronger = 2
    gui.update_layout()

def toggle_auto_bg_strong3(mode=0):

    if mode == 1:
        return prefs.art_bg_stronger == 3
    prefs.art_bg_stronger = 3
    gui.update_layout()

def toggle_auto_bg_blur(mode=0):

    if mode == 1:
        return prefs.art_bg_always_blur
    prefs.art_bg_always_blur ^= True
    style_overlay.flush()

def toggle_auto_bg_showcase(mode=0):

    if mode == 1:
        return prefs.bg_showcase_only
    prefs.bg_showcase_only ^= True
    gui.update_layout()


def toggle_notifications(mode=0):

    if mode == 1:
        return prefs.show_notifications

    prefs.show_notifications ^= True

    if prefs.show_notifications:
        if not de_nofity_support:
            show_message("I'm not sure notifications are supported by this DE", 'warning', 'You should probably leave this disabled.')

# def toggle_al_pref_album_artist(mode=0):
#
#     if mode == 1:
#         return prefs.artist_list_prefer_album_artist
#
#     prefs.artist_list_prefer_album_artist ^= True
#     artist_list_box.saves.clear()


def toggle_mini_lyrics(mode=0):

    if mode == 1:
        return prefs.show_lyrics_side

    prefs.show_lyrics_side ^= True


def toggle_showcase_vis(mode=0):

    if mode == 1:
        return prefs.showcase_vis

    prefs.showcase_vis ^= True
    gui.update_layout()


def toggle_level_meter(mode=0):

    if mode == 1:
        return gui.vis_want != 0

    if gui.vis_want == 0:
        gui.vis_want = 2
    else:
        gui.vis_want = 0

    gui.update_layout()


def level_meter_special_2():

    gui.level_meter_colour_mode = 2


theme_files = os.listdir(install_directory + '/theme')
theme_files.sort()

def advance_theme():
    global theme
    global themeChange
    theme += 1
    themeChange = True


def set_theme_vape():
    global theme
    global themeChange
    for i, theme in enumerate(theme_files):
        if 'vape.ttheme' == theme:
            theme = i + 1
            themeChange = True
            break


def last_fm_menu_deco():
    # if lastfm.connected:
    #     line = 'Stop Last.fm Scrobbling'
    #     bg = colours.menu_background
    # else:
    #     line = 'Start Last.fm Scrobbling'
    #     bg = colours.menu_background
    if lastfm.hold:

        if not prefs.auto_lfm and lb.enable:
            line = _("ListenBrainz is Paused")
        else:
            line = _("Scrobbling is Paused")
        bg = colours.menu_background
    else:
        if not prefs.auto_lfm and lb.enable:
            line = _("ListenBrainz is Active")
        else:
            line = _("Scrobbling is Active")
        bg = colours.menu_background

    return [colours.menu_text, bg, line]


def lastfm_colour():
    if not lastfm.hold:
        return [250, 50, 50, 255]
    else:
        return None


lastfm_icon = MenuIcon(asset_loader('as.png', True))

if gui.scale == 2:
    lastfm_icon.xoff = 0
elif gui.scale == 1.25:
    lastfm_icon.xoff = 0
else:
    lastfm_icon.xoff = -1

lastfm_icon.yoff = 1

lastfm_icon.colour = [249, 70, 70, 255]
lastfm_icon.colour_callback = lastfm_colour

def lastfm_menu_test(a):

    if prefs.last_fm_token is not None or prefs.enable_lb:
        return True
    return False


lb_icon = MenuIcon(asset_loader('lb-g.png'))
lb_icon.base_asset = asset_loader('lb-gs.png')

def lb_mode():
    return prefs.enable_lb


lb_icon.mode_callback = lb_mode

lb_icon.xoff = 3
lb_icon.yoff = -1

if gui.scale == 1.25:
    lb_icon.yoff = 0

listen_icon = lastfm_icon

if not prefs.auto_lfm and lb.enable:
    listen_icon = lb_icon

x_menu.add("LFM", lastfm.toggle, last_fm_menu_deco, icon=listen_icon, show_test=lastfm_menu_test)


def discord_loop():

    prefs.discord_active = True

    if not pctl.playing_ready():
        show_message("Please start playing a track first")
        return

    asyncio.set_event_loop(asyncio.new_event_loop())

    # if system == 'linux' and not flatpak_mode:
    #     try:
    #         print("Try to create link for Flatpak Discord RP")
    #         xdg_run = os.environ.get('XDG_RUNTIME_DIR')
    #         if xdg_run:
    #             discord_link_command = "ln -sf {app/com.discordapp.Discord,$XDG_RUNTIME_DIR}/discord-ipc-0"
    #             print("Link command: " + discord_link_command)
    #             os.system(discord_link_command)
    #             print("Symlink command run")
    #     except:
    #         print("Discord flatpak link failed (may already exist)")

    try:

        print("Attempting to connect to Discord...")

        client_id = '434627346574606351'
        RPC = Presence(client_id)
        RPC.connect()

        print("Discord RPC connection successful.")

        time.sleep(8)
        start_time = time.time()
        idle_time = Timer()

        state = 0
        index = -1
        br = False

        current_state = 0

        while True:
            while True:


                current_index = pctl.playing_object().index

                if current_state == 0 and pctl.playing_state == 1:
                    current_state = 1
                elif current_state == 1 and pctl.playing_state != 1:
                    current_state = 0
                    idle_time.set()

                if state != current_state or index != current_index:
                    if pctl.playing_time > 4 or current_state != 1:
                        state = current_state
                        index = current_index
                        start_time = time.time() - pctl.playing_time

                        break

                if current_state == 0 and idle_time.get() > 13:
                    print("Pause discord RPC...")
                    RPC.clear(pid)
                    #RPC.close()

                    while True:
                        if prefs.disconnect_discord:
                            break
                        if pctl.playing_state == 1:
                            print("Reconnect discord...")
                            RPC.connect()
                            break
                        time.sleep(2)

                    if not prefs.disconnect_discord:
                        continue

                time.sleep(2)

                if prefs.disconnect_discord:
                    RPC.clear(pid)
                    RPC.close()
                    prefs.disconnect_discord = False
                    br = True
                    break

            if br:
                break

            title = "Unknown Track"
            tr = pctl.playing_object()
            if tr.artist != "" and tr.title != "":
                title = tr.artist + " - " + tr.title
                if len(title) > 150:
                    title = "Unknown Track"

            if tr.album:
                album = tr.album
            else:
                album = "Unknown Album"

            if state == 1:
                print("PLAYING: " + title)

                print(start_time)

                RPC.update(pid=pid,
                           state=album,
                           details=title,
                           start=int(start_time),
                           large_image="tauon-large",)

            else:
                print("STOPPED")

                RPC.update(pid=pid,
                           state="Idle",
                           large_image="tauon-large",)

            time.sleep(15)

            if prefs.disconnect_discord:
                RPC.clear(pid)
                RPC.close()
                prefs.disconnect_discord = False
                break

    except:
        show_message("Error connecting to Discord", 'error')
        prefs.disconnect_discord = False
        #raise

    prefs.discord_active = False




def activate_discord():

    if not prefs.discord_active:
        discord_t = threading.Thread(target=discord_loop)
        discord_t.daemon = True
        discord_t.start()

    elif not prefs.disconnect_discord:
        prefs.disconnect_discord = True


def discord_deco():
    tc = colours.menu_text

    if prefs.disconnect_discord:
        tc = colours.menu_text_disabled
        return [tc, colours.menu_background, "Disconnecting..."]
    if prefs.discord_active:
        return [tc, colours.menu_background, "Disconnect Discord"]
    else:
        return [tc, colours.menu_background, 'Show playing in Discord']



def discord_show_test(_):
    return prefs.discord_show

x_menu.add("Show playing in Discord", activate_discord, discord_deco, show_test=discord_show_test)

def exit_func():
    pctl.running = False


x_menu.add(_("Exit"), exit_func, hint="Alt+F4")


def switch_playlist(number, cycle=False):
    global default_playlist

    global playlist_selected
    global search_index
    global shift_selection
    global album_pos_px

    # Close any active menus
    for instance in Menu.instances:
        instance.active = False

    gui.previous_playlist_id = pctl.multi_playlist[pctl.active_playlist_viewing][6]

    gui.pl_update = 1
    search_index = 0
    gui.search_error = False
    if quick_search_mode:
        gui.force_search = True

    # if pl_follow:
    #     pctl.multi_playlist[pctl.playlist_active][1] = copy.deepcopy(pctl.playlist_playing)

    if gui.showcase_mode and gui.combo_mode:
        view_standard()

    pctl.multi_playlist[pctl.active_playlist_viewing][2] = default_playlist
    pctl.multi_playlist[pctl.active_playlist_viewing][3] = pctl.playlist_view_position
    pctl.multi_playlist[pctl.active_playlist_viewing][5] = playlist_selected

    if gall_pl_switch_timer.get() > 240:
        gui.gallery_positions.clear()
    gall_pl_switch_timer.set()


    gui.gallery_positions[gui.previous_playlist_id] = album_pos_px


    if cycle:
        pctl.active_playlist_viewing += number
    else:
        pctl.active_playlist_viewing = number

    while pctl.active_playlist_viewing > len(pctl.multi_playlist) - 1:
        pctl.active_playlist_viewing -= len(pctl.multi_playlist)
    while pctl.active_playlist_viewing < 0:
        pctl.active_playlist_viewing += len(pctl.multi_playlist)

    default_playlist = pctl.multi_playlist[pctl.active_playlist_viewing][2]
    pctl.playlist_view_position = pctl.multi_playlist[pctl.active_playlist_viewing][3]
    playlist_selected = pctl.multi_playlist[pctl.active_playlist_viewing][5]

    shift_selection = [playlist_selected]

    if album_mode:
        reload_albums(True)

        id = pctl.multi_playlist[pctl.active_playlist_viewing][6]
        if id in gui.gallery_positions:
            album_pos_px = gui.gallery_positions[id]
        else:
            goto_album(pctl.playlist_view_position)


def view_tracks():
    # if gui.show_playlist is False:
    #     gui.show_playlist = True
    if album_mode:
        toggle_album_mode()
    if gui.combo_mode:
        toggle_combo_view(off=True)
    if gui.rsp:
        toggle_side_panel()

#
# def view_standard_full():
#     # if gui.show_playlist is False:
#     #     gui.show_playlist = True
#
#     if album_mode:
#         toggle_album_mode()
#     if gui.combo_mode:
#         toggle_combo_view(off=True)
#     if not gui.rsp:
#         toggle_side_panel()
#     global update_layout
#     update_layout = True
#     gui.rspw = window_size[0]


def view_standard_meta():
    # if gui.show_playlist is False:
    #     gui.show_playlist = True
    if album_mode:
        toggle_album_mode()

    if gui.combo_mode:
        toggle_combo_view(off=True)

    if not gui.rsp:
        toggle_side_panel()

    global update_layout
    update_layout = True
    #gui.rspw = 80 + int(window_size[0] * 0.18)


def view_standard():
    # if gui.show_playlist is False:
    #     gui.show_playlist = True
    if album_mode:
        toggle_album_mode()
    if gui.combo_mode:
        toggle_combo_view(off=True)
    if not gui.rsp:
        toggle_side_panel()


def standard_view_deco():
    if album_mode or gui.combo_mode or not gui.rsp:
        line_colour = colours.menu_text
    else:
        line_colour = colours.menu_text_disabled
    return [line_colour, colours.menu_background, None]


# def gallery_only_view():
#     if gui.show_playlist is False:
#         return
#     if not album_mode:
#         toggle_album_mode()
#     gui.show_playlist = False
#     global album_playlist_width
#     global update_layout
#     update_layout = True
#     gui.rspw = window_size[0]
#     album_playlist_width = gui.playlist_width
#     #gui.playlist_width = -19


def force_album_view():
    toggle_album_mode(True)

def switch_showcase(index=-1):

    if not gui.combo_mode:
        gui.lyrics_was_album = album_mode
    else:
        if gui.lyrics_was_album:
            force_album_view()

    if pctl.playing_object() is None or pctl.playing_object().index == index:
        pass
    else:
        gui.force_showcase_index = index
    if gui.combo_mode:
        toggle_combo_view()
    toggle_combo_view(showcase=True)

def toggle_library_mode():
    if gui.set_mode:
        gui.set_mode = False
        #gui.set_bar = False
    else:
        gui.set_mode = True
        #gui.set_bar = True
    gui.update_layout()

def library_deco():
    tc = colours.menu_text
    if gui.combo_mode or (gui.show_playlist is False and album_mode):
        tc = colours.menu_text_disabled

    if gui.set_mode:
        return [tc, colours.menu_background, "Disable Columns"]
    else:
        return [tc, colours.menu_background, 'Enable Columns']

def break_deco():
    tex = colours.menu_text
    if gui.combo_mode or (gui.show_playlist is False and album_mode):
        tex = colours.menu_text_disabled
    if not break_enable:
        tex = colours.menu_text_disabled


    if pctl.multi_playlist[pctl.active_playlist_viewing][4] == 0:
        return [tex, colours.menu_background, "Disable Title Breaks"]
    else:
        return [tex, colours.menu_background, 'Enable Title Breaks']

def toggle_playlist_break():
    pctl.multi_playlist[pctl.active_playlist_viewing][4] ^= 1
    gui.pl_update = 1

# ---------------------------------------------------------------------------------------


def transcode_single(item, manual_directroy=None, manual_name=None):
    global core_use

    if manual_directroy != None:
        codec = "opus"
        output = manual_directroy
        track = item
        core_use += 1
        bitrate = 48
    else:
        track = item[0]
        codec = prefs.transcode_codec
        output = prefs.encoder_output + item[1] + "/"
        bitrate = prefs.transcode_bitrate

    if not os.path.isfile(pctl.master_library[track].fullpath):
        show_message("Encoding warning: Missing one or more files")
        core_use -= 1
        return

    t = pctl.master_library[track]
    if t.is_cue:
        out_line = str(t.track_number) + ". "
        out_line += t.artist + " - " + t.title
        for c in r'[]/\;,><&*:%=+@!#^()|?^.':
            out_line = out_line.replace(c, '')

    else:
        out_line = os.path.splitext(pctl.master_library[track].filename)[0]

    target_out = output + 'output' + str(track) + "." + codec

    command = user_directory + "/encoder/ffmpeg "


    if system != 'windows':
        command = "ffmpeg "
    else:
        command = command.replace("/", "\\")

    if not pctl.master_library[track].is_cue:
        command += '-i "'
    else:
        command += '-ss ' + str(pctl.master_library[track].start_time)
        command += ' -t ' + str(pctl.master_library[track].length)

        command += ' -i "'

    command += pctl.master_library[track].fullpath.replace('"', '\\"')

    command += '" '

    if pctl.master_library[track].is_cue:
        if t.title != "":
            command += '-metadata title="' + t.title.replace('"', "").replace("'", "") + '" '
        if t.artist != "":
            command += '-metadata artist="' + t.artist.replace('"', "").replace("'", "") + '" '
        if t.album != "":
            command += '-metadata album="' + t.album.replace('"', "").replace("'", "") + '" '
        if t.track_number != "":
            command += '-metadata track="' + str(t.track_number).replace('"', "").replace("'", "") + '" '
        if t.date != "":
            command += '-metadata year="' + str(t.date).replace('"', "").replace("'", "") + '" '

    if codec != 'flac':
        command += " -b:a " + str(bitrate) + "k -vn "

    command += '"' + target_out.replace('"', '\\"') + '"'

    print(shlex.split(command))
    startupinfo = None
    if system == 'windows':
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW

    if system == "linux":
        command = shlex.split(command)

    subprocess.call(command, stdout=subprocess.PIPE, shell=False,
                    startupinfo=startupinfo)

    print("ffmpeg finished")
    if codec == "opus" and prefs.transcode_opus_as:
        codec = 'opus.ogg'

    print(target_out)

    if manual_name is None:
        final_out = output + out_line + "." + codec
        final_name = out_line + "." + codec
        os.rename(target_out, final_out)
    else:
        final_out = output + manual_name + "." + codec
        final_name = manual_name + "." + codec
        os.rename(target_out, final_out)

    if prefs.transcode_inplace:
        print("MOVE AND REPLACE!")
        if os.path.isfile(final_out) and os.path.getsize(final_out) > 1000:
            new_name = os.path.join(pctl.master_library[track].parent_folder_path, final_name)
            print(new_name)
            shutil.move(final_out, new_name)

            old_key = star_store.key(track)
            old_star = star_store.full_get(track)

            try:
                send2trash(pctl.master_library[track].fullpath)
            except:
                print("File trash error")
               
            if os.path.isfile(pctl.master_library[track].fullpath):
                try:
                    os.remove(pctl.master_library[track].fullpath)
                except:
                    print("File detete error")

            pctl.master_library[track].fullpath = new_name
            pctl.master_library[track].file_ext = codec.upper()

            # Update and merge playtimes
            new_key = star_store.key(track)
            if old_star and (new_key != old_key):

                new_star = star_store.full_get(track)
                if new_star is None:
                    new_star = [0, ""]

                new_star[0] += old_star[0]
                new_star[1] = "".join(set(new_star[1] + old_star[1]))

                if old_key in star_store.db:
                    del star_store.db[old_key]

                star_store.db[new_key] = new_star



    gui.transcoding_bach_done += 1
    core_use -= 1
    gui.update += 1


# ---------------------
added = []

def cue_scan(content, tn):
    # Get length from backend

    lasttime = tn.length

    content = content.replace("\r", "")
    content = content.split("\n")

    #print(content)

    global master_count
    global added

    cued = []

    LENGTH = 0
    PERFORMER = ""
    TITLE = ""
    START = 0
    DATE = ""
    ALBUM = ""
    GENRE = ""
    MAIN_PERFORMER = ""

    for LINE in content:
        if 'TITLE "' in LINE:
            ALBUM = LINE[7:len(LINE) - 2]

        if 'PERFORMER "' in LINE:
            while LINE[0] != "P":
                LINE = LINE[1:]

            MAIN_PERFORMER = LINE[11:len(LINE) - 2]

        if 'REM DATE' in LINE:
            DATE = LINE[9:len(LINE) - 1]

        if 'REM GENRE' in LINE:
            GENRE = LINE[10:len(LINE) - 1]

        if 'TRACK ' in LINE:
            break

    for LINE in reversed(content):
        if len(LINE) > 100:
            return 1
        if "INDEX 01 " in LINE:
            temp = ""
            pos = len(LINE)
            pos -= 1
            while LINE[pos] != ":":
                pos -= 1
                if pos < 8:
                    break

            START = int(LINE[pos - 2:pos]) + (int(LINE[pos - 5:pos - 3]) * 60)
            LENGTH = int(lasttime) - START
            lasttime = START

        elif 'PERFORMER "' in LINE:
            switch = 0
            for i in range(len(LINE)):
                if switch == 1 and LINE[i] == '"':
                    break
                if switch == 1:
                    PERFORMER += LINE[i]
                if LINE[i] == '"':
                    switch = 1

        elif 'TITLE "' in LINE:

            switch = 0
            for i in range(len(LINE)):
                if switch == 1 and LINE[i] == '"':
                    break
                if switch == 1:
                    TITLE += LINE[i]
                if LINE[i] == '"':
                    switch = 1

        elif 'TRACK ' in LINE:

            pos = 0
            while LINE[pos] != 'K':
                pos += 1
                if pos > 15:
                    return 1
            TN = LINE[pos + 2:pos + 4]

            TN = int(TN)

            # try:
            #     bitrate = audio.info.bitrate
            # except:
            #     bitrate = 0

            if PERFORMER == "":
                PERFORMER = MAIN_PERFORMER

            nt = copy.deepcopy(tn) #TrackClass()

            nt.cue_sheet = ""
            nt.is_embed_cue = True

            nt.index = master_count
            # nt.fullpath = filepath.replace('\\', '/')
            # nt.filename = filename
            # nt.parent_folder_path = os.path.dirname(filepath.replace('\\', '/'))
            # nt.parent_folder_name = os.path.splitext(os.path.basename(filepath))[0]
            # nt.file_ext = os.path.splitext(os.path.basename(filepath))[1][1:].upper()

            nt.album_artist = MAIN_PERFORMER
            nt.artist = PERFORMER
            nt.genre = GENRE
            nt.title = TITLE
            nt.length = LENGTH
            # nt.bitrate = source_track.bitrate
            nt.album = ALBUM
            nt.date = DATE.replace('"', '')
            nt.track_number = TN
            nt.start_time = START
            nt.is_cue = True
            nt.size = 0  # source_track.size
            # nt.samplerate = source_track.samplerate
            if TN == 1:
                nt.size = os.path.getsize(nt.fullpath)

            pctl.master_library[master_count] = nt

            cued.append(master_count)
            # loaded_pathes_cache[filepath.replace('\\', '/')] = master_count
            #added.append(master_count)

            master_count += 1
            LENGTH = 0
            PERFORMER = ""
            TITLE = ""
            START = 0
            TN = 0

    added += reversed(cued)

    # cue_list.append(filepath)


class SearchOverlay:

    def __init__(self):

        self.active = False
        self.search_text = TextBox()

        self.results = []
        self.searched_text = ""
        self.on = 0
        self.force_select = -1
        self.old_mouse = [0,0]
        self.sip = False
        self.delay_enter = False

    def click_artist(self, name):

        playlist = []
        for pl in pctl.multi_playlist:
            for item in pl[2]:
                if pctl.master_library[item].artist.lower() == name.lower() or pctl.master_library[item].album_artist.lower() == name.lower():
                    if item not in playlist:
                        playlist.append(item)

        pctl.multi_playlist.append(pl_gen(title="Artist: " + name,
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=0))

        switch_playlist(len(pctl.multi_playlist) - 1)


        input.key_return_press = False

    def click_composer(self, name):

        playlist = []
        for pl in pctl.multi_playlist:
            for item in pl[2]:
                if pctl.master_library[item].composer.lower() == name.lower():
                    if item not in playlist:
                        playlist.append(item)

        pctl.multi_playlist.append(pl_gen(title="Composer: " + name,
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=0))

        switch_playlist(len(pctl.multi_playlist) - 1)


        input.key_return_press = False

    def click_meta(self, name):

        playlist = []
        for pl in pctl.multi_playlist:
            for item in pl[2]:
                if name in pctl.master_library[item].parent_folder_path:
                    if item not in playlist:
                        playlist.append(item)

        pctl.multi_playlist.append(pl_gen(title=os.path.basename(name).upper(),
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=0))

        switch_playlist(len(pctl.multi_playlist) - 1)

        input.key_return_press = False

    def click_genre(self, name):

        playlist = []
        for pl in pctl.multi_playlist:
            for item in pl[2]:
                if pctl.master_library[item].genre.lower().replace("-", "") == name.lower().replace("-", ""):
                    if item not in playlist:
                        playlist.append(item)

        pctl.multi_playlist.append(pl_gen(title="Genre: " + name,
                                          playlist=copy.deepcopy(playlist),
                                          hide_title=0))

        switch_playlist(len(pctl.multi_playlist) - 1)


        input.key_return_press = False

    def click_album(self, index):

        pctl.jump(index)
        pctl.show_current()

        input.key_return_press = False

    def render(self):

        if self.active is False:

            if input_text != "" and gui.layer_focus == 0 and \
                    not key_ctrl_down and not radiobox and not renamebox and \
                    not quick_search_mode and not pref_box.enabled and not gui.rename_playlist_box \
                    and not gui.rename_folder_box and input_text.isalnum():

                if gui.lsp and prefs.artist_list and 2 < mouse_position[0] < gui.lspw \
                        and gui.panelY < mouse_position[1] < window_size[1] - gui.panelBY:

                    artist_list_box.locate_artist_letter(input_text)
                    return

                self.active = True
                self.old_mouse = copy.deepcopy(mouse_position)


        if self.active:

            x = 0
            y = 0
            w = window_size[0]
            h = window_size[1]

            if key_backspace_press:
                self.searched_text = ""
                self.results.clear()

                if len(self.search_text.text) <= 1:
                    self.active = False
                    self.search_text.text = ""
                    return

            if key_esc_press:
                self.active = False
                self.search_text.text = ""
                return

            if gui.level_2_click and mouse_position[0] > 350 * gui.scale:
                self.active = False
                self.search_text.text = ""

            mouse_change = False
            if not point_proximity_test(self.old_mouse, mouse_position, 25):
                mouse_change = True
            # mouse_change = True

            ddt.rect_r((x, y, w, h), [3,3,3,235], True)
            ddt.text_background_colour = [12, 12, 12, 255]

            if self.sip:

                si = 7 * gui.scale
                gap = 5 * gui.scale
                left = 15 * gui.scale

                ddt.rect_r((left, left, si, si), [100,80,240,255], True)
                ddt.rect_r((left + gap + si, left, si, si), [100,80,240,255], True)
                ddt.rect_r((left + (gap + si) * 2, left, si, si), [100,80,240,255], True)

            elif not self.results and len(self.search_text.text) > 2:
                ddt.draw_text((130 * gui.scale, 200 * gui.scale), "No results found", [250, 250, 250, 255], 216, bg=[12, 12, 12, 255])

            self.search_text.draw(80 * gui.scale, 60 * gui.scale, [230, 230, 230, 255], True, False, 30, window_size[0] - 100, big=True, click=gui.level_2_click, selection_height=30)

            yy = 110 * gui.scale

            if key_down_press:

                if self.force_select > -1:
                    self.on = self.force_select
                    self.force_select = -1
                self.on += 1
                self.old_mouse = copy.deepcopy(mouse_position)

            if key_up_press:

                if self.force_select > -1:
                    self.on = self.force_select
                    self.force_select = -1
                self.on -= 1
                self.old_mouse = copy.deepcopy(mouse_position)

            if mouse_wheel == -1:
                self.on += 1
                self.force_select += 1
            if mouse_wheel == 1 and self.on > -1:
                self.on -= 1
                self.force_select -= 1

            enter = False

            if self.delay_enter and not self.sip:
                enter = True
                self.delay_enter = False
            elif input.key_return_press:
                if self.sip:
                    self.delay_enter = True
                else:
                    enter = True
                    self.delay_enter = False

            input.key_return_press = False

            bar_colour = [140, 80, 240, 255]

            self.on = max(self.on, 0)
            self.on = min(len(self.results) - 1, self.on)

            full_count = 0

            sec = False

            p = -1

            if self.on > 4:
                p += self.on - 4

            for i, item in enumerate(self.results):

                p += 1

                if p > len(self.results) - 1:
                    break

                item = self.results[p]

                fade = 1
                selected = self.on
                if self.force_select > -1:
                    selected = self.force_select

                # print(selected)

                if selected != p:
                    fade = 0.85

                # Block separating lower search results
                if item[4] < 4 and not sec:
                    if i != 0:
                        ddt.rect_r((50 * gui.scale, yy + 5 * gui.scale, 400 * gui.scale, 4 * gui.scale), [255, 255, 255, 40], True)
                        yy += 20 * gui.scale

                    sec = True

                full = False

                start = yy

                if item[0] == 0:
                    cl = [250, 140, 190, int(255 * fade)]
                    text = "Artist"
                    yy += 3 * gui.scale
                    xx = ddt.draw_text((120 * gui.scale, yy), item[1], [255, 255, 255, int(255 * fade)], 215, bg=[12, 12, 12, 255])

                    ddt.draw_text((65 * gui.scale, yy), text, cl, 214, bg=[12, 12, 12, 255])

                    if fade == 1:
                        ddt.rect_r((30 * gui.scale, yy - 3 * gui.scale, 4 * gui.scale, 23 * gui.scale), bar_colour, True)

                    rect = (30 * gui.scale, yy, 600 * gui.scale, 20 * gui.scale)
                    fields.add(rect)
                    if coll(rect) and mouse_change:
                        if self.force_select != p:
                            self.force_select = p
                            gui.update = 2

                        if gui.level_2_click:
                            self.click_artist(item[1])
                            self.active = False
                            self.search_text.text = ""

                        if level_2_right_click:

                            pctl.show_current(index=item[2], playing=False)
                            self.active = False
                            self.search_text.text = ""

                    if enter and fade == 1:
                        self.click_artist(item[1])
                        self.active = False
                        self.search_text.text = ""

                    yy += 6 * gui.scale

                if item[0] == 1:

                    yy += 5 * gui.scale
                    xx = ddt.draw_text((120 * gui.scale, yy), item[1], [255, 255, 255, int(255 * fade)], 214, bg=[12, 12, 12, 255])

                    artist = pctl.master_library[item[2]].album_artist
                    if artist == "":
                        artist = pctl.master_library[item[2]].artist

                    if full_count < 7:

                        ddt.draw_text((125 * gui.scale, yy + 25 * gui.scale), "BY", [250, 240, 110, int(255 * fade)], 212, bg=[12, 12, 12, 255])
                        xx += 8 * gui.scale

                        xx += ddt.draw_text((150 * gui.scale, yy + 25 * gui.scale), artist, [250, 250, 250, int(255 * fade)], 15, bg=[12, 12, 12, 255])

                        ddt.rect_r((50 * gui.scale, yy + 5, 50 * gui.scale, 50 * gui.scale), [50,50,50,150], True)
                        gall_ren.render(item[2], (50 * gui.scale, yy + 5), 50 * gui.scale)
                        if fade != 1:
                            ddt.rect_r((50 * gui.scale, yy + 5, 50 * gui.scale, 50 * gui.scale), [0, 0, 0, 70], True)
                        full = True
                        full_count += 1

                        if fade == 1:
                            ddt.rect_r((30 * gui.scale, yy + 5, 4 * gui.scale, 50 * gui.scale), bar_colour, True)

                        rect = (30 * gui.scale, yy, 600 * gui.scale, 55 * gui.scale)
                        fields.add(rect)
                    else:

                        ddt.draw_text((120 + xx + 11 * gui.scale, yy), "BY", [250, 240, 110, int(255 * fade)], 212, bg=[12, 12, 12, 255])
                        xx += 8 * gui.scale

                        xx += ddt.draw_text((120 + xx + 30 * gui.scale, yy), artist, [255, 255, 255, int(255 * fade)], 15, bg=[12, 12, 12, 255])

                        rect = (30 * gui.scale, yy, 600 * gui.scale, 20 * gui.scale)
                        fields.add(rect)

                    if coll(rect) and mouse_change:
                        if self.force_select != p:
                            self.force_select = p
                            gui.update = 2
                        if gui.level_2_click:
                            self.click_album(item[2])
                            pctl.playlist_view_position = playlist_selected
                            self.active = False
                            self.search_text.text = ""

                        if level_2_right_click:
                            pctl.show_current(index=item[2], playing=False)
                            pctl.playlist_view_position = playlist_selected
                            self.active = False
                            self.search_text.text = ""

                    if enter and fade == 1:
                        self.click_album(item[2])
                        pctl.show_current(index=item[2])
                        pctl.playlist_view_position = playlist_selected
                        self.active = False
                        self.search_text.text = ""

                    if full:
                        yy += 50 * gui.scale

                if item[0] == 2:
                    cl = [250, 220, 190, int(255 * fade)]
                    text = "Track"
                    track = pctl.master_library[item[2]]

                    if track.artist == track.title == "":
                        ddt.draw_text((120 * gui.scale, yy), os.path.splitext(track.filename)[0], [255, 255, 255, int(255 * fade)], 15,
                                      bg=[12, 12, 12, 255])
                    else:
                        xx = ddt.draw_text((120 * gui.scale, yy), item[1], [255, 255, 255, int(255 * fade)], 15, bg=[12, 12, 12, 255])

                        ddt.draw_text((xx + (120 + 11) * gui.scale, yy), "BY", [250, 160, 110, int(255 * fade)], 212, bg=[12, 12, 12, 255])
                        xx += 8 * gui.scale
                        artist = track.artist
                        xx += ddt.draw_text((xx + (120 + 30) * gui.scale, yy), artist, [255, 255, 255, int(255 * fade)], 214, bg=[12, 12, 12, 255])

                    ddt.draw_text((65 * gui.scale, yy), text, cl, 314, bg=[12, 12, 12, 255])
                    if fade == 1:
                        ddt.rect_r((30 * gui.scale, yy, 4 * gui.scale, 17 * gui.scale), bar_colour, True)

                    rect = (30 * gui.scale, yy, 600 * gui.scale, 20 * gui.scale)
                    fields.add(rect)
                    if coll(rect) and mouse_change:
                        if self.force_select != p:
                            self.force_select = p
                            gui.update = 2
                        if gui.level_2_click:
                            self.click_album(item[2])
                            self.active = False
                            self.search_text.text = ""
                        if level_2_right_click:
                            pctl.show_current(index=item[2], playing=False)
                            self.active = False
                            self.search_text.text = ""
                    if enter and fade == 1:
                        self.click_album(item[2])
                        self.active = False
                        self.search_text.text = ""

                if item[0] == 3:
                    cl = [240, 240, 160, int(255 * fade)]
                    text = "Genre"
                    xx = ddt.draw_text((120 * gui.scale, yy), item[1], [255, 255, 255, int(255 * fade)], 215, bg=[12, 12, 12, 255])

                    ddt.draw_text((65 * gui.scale, yy), text, cl, 214, bg=[12, 12, 12, 255])
                    if fade == 1:
                        ddt.rect_r((30 * gui.scale, yy - 3 * gui.scale, 4 * gui.scale, 20 * gui.scale), bar_colour, True)

                    rect = (30 * gui.scale, yy, 600 * gui.scale, 20 * gui.scale)
                    fields.add(rect)
                    if coll(rect) and mouse_change:
                        if self.force_select != p:
                            self.force_select = p
                            gui.update = 2
                        if gui.level_2_click:
                            self.click_genre(item[1])
                            self.active = False
                            self.search_text.text = ""
                        if level_2_right_click:
                            pctl.show_current(index=item[2], playing=False)
                            self.active = False
                            self.search_text.text = ""
                    if enter and fade == 1:
                        self.click_genre(item[1])
                        self.active = False
                        self.search_text.text = ""

                if item[0] == 5:
                    cl = [250, 100, 50, int(255 * fade)]
                    text = "META"
                    xx = ddt.draw_text((120 * gui.scale, yy), item[1], [255, 255, 255, int(255 * fade)], 214, bg=[12, 12, 12, 255])

                    ddt.draw_text((65 * gui.scale, yy), text, cl, 214, bg=[12, 12, 12, 255])
                    if fade == 1:
                        ddt.rect_r((30 * gui.scale, yy - 3 * gui.scale, 4 * gui.scale, 20 * gui.scale), bar_colour, True)

                    rect = (30 * gui.scale, yy, 600 * gui.scale, 20 * gui.scale)
                    fields.add(rect)
                    if coll(rect) and mouse_change:
                        if self.force_select != p:
                            self.force_select = p
                            gui.update = 2
                        if gui.level_2_click:
                            self.click_meta(item[1])
                            self.active = False
                            self.search_text.text = ""
                        if level_2_right_click:
                            pctl.show_current(index=item[2], playing=False)
                            self.active = False
                            self.search_text.text = ""
                    if enter and fade == 1:
                        self.click_meta(item[1])
                        self.active = False
                        self.search_text.text = ""

                if item[0] == 6:
                    cl = [180, 250, 190, int(255 * fade)]
                    text = "Composer"
                    yy += 3 * gui.scale
                    xx = ddt.draw_text((124 * gui.scale, yy), item[1], [255, 255, 255, int(255 * fade)], 215, bg=[12, 12, 12, 255])

                    ddt.draw_text((40 * gui.scale, yy), text, cl, 214, bg=[12, 12, 12, 255])

                    if fade == 1:
                        ddt.rect_r((30 * gui.scale, yy - 3 * gui.scale, 4 * gui.scale, 23 * gui.scale), bar_colour, True)

                    rect = (30 * gui.scale, yy, 600 * gui.scale, 20 * gui.scale)
                    fields.add(rect)
                    if coll(rect) and mouse_change:
                        if self.force_select != p:
                            self.force_select = p
                            gui.update = 2

                        if gui.level_2_click:
                            self.click_composer(item[1])
                            self.active = False
                            self.search_text.text = ""

                        if level_2_right_click:

                            pctl.show_current(index=item[2], playing=False)
                            self.active = False
                            self.search_text.text = ""

                    if enter and fade == 1:
                        self.click_composer(item[1])
                        self.active = False
                        self.search_text.text = ""

                    yy += 6 * gui.scale

                if i > 40:
                    break

                if yy > window_size[1] - (100 * gui.scale):
                    break

                yy += 22 * gui.scale


search_over = SearchOverlay()

# LOADER----------------------------------------------------------------------

def worker2():

    while True:

        time.sleep(0.07)

        gall_ren.worker_render()

        if prefs.art_bg:
            style_overlay.worker()

        #if core_timer.get() > 2:

        if len(search_over.search_text.text) > 1:
            if search_over.search_text.text != search_over.searched_text:

                temp_results = []

                search_over.searched_text = search_over.search_text.text

                artists = {}
                albums = {}
                genres = {}
                metas = {}
                composers = {}

                tracks = set()

                br = 0

                if search_over.searched_text in ('the', 'and'):
                    continue

                search_over.sip = True
                gui.update += 1

                s_text = search_over.search_text.text.lower()

                for playlist in pctl.multi_playlist:

                    if "<" in playlist[0]:
                        print("Skipping search on derivative playlist: " + playlist[0])
                        continue

                    for track in playlist[2]:

                        # if input_text != "":
                        #     time.sleep(0.001)

                        t = pctl.master_library[track]

                        title = t.title.lower()
                        artist = t.artist.lower()
                        album_artist = t.album_artist.lower()
                        composer = t.composer.lower()
                        album = t.album.lower()
                        genre = t.genre.lower()
                        filename = t.filename.lower()

                        stem = os.path.dirname(t.parent_folder_path)


                        if len(s_text) > 2 and s_text.replace('-', "") in stem.replace("-", "").lower() and artist not in stem.lower() and album not in stem.lower():

                            if stem in metas:
                                metas[stem] += 2
                            else:
                                temp_results.append([5, stem, track, playlist[6], 0])
                                metas[stem] = 2

                        if s_text in genre:

                            if t.genre in genres:
                                genres[t.genre] += 1
                            else:
                                temp_results.append([3, t.genre, track, playlist[6], 0])
                                genres[t.genre] = 1

                        if s_text in composer:

                            if t.composer in composers:
                                composers[t.composer] += 2
                            else:
                                temp_results.append([6, t.composer, track, playlist[6], 0])
                                composers[t.composer] = 2

                        if search_magic(s_text, title + artist + filename + album + album_artist):

                            if s_text in artist:

                                value = 1
                                if s_text == artist:
                                    value = 3

                                # Add artist
                                if t.artist in artists:
                                    artists[t.artist] += value
                                else:
                                    temp_results.append([0, t.artist, track, playlist[6], 0])
                                    artists[t.artist] = value


                                if t.album in albums:
                                    albums[t.album] += 1
                                else:
                                    temp_results.append([1, t.album, track, playlist[6], 0])
                                    albums[t.album] = 1

                            elif s_text in album_artist:

                                # Add album artist
                                if t.album_artist in artists:
                                    artists[t.album_artist] += value
                                else:
                                    temp_results.append([0, t.album_artist, track, playlist[6], 0])
                                    artists[t.album_artist] = value


                                if t.album in albums:
                                    albums[t.album] += 1
                                else:
                                    temp_results.append([1, t.album, track, playlist[6], 0])
                                    albums[t.album] = 1



                            if s_text in album:

                                value = 1
                                if s_text == album:
                                    value = 3

                                if t.album in albums:
                                    albums[t.album] += value
                                else:
                                    temp_results.append([1, t.album, track, playlist[6], 0])
                                    albums[t.album] = value

                            if search_magic(s_text, artist) or search_magic(s_text, album):

                                if t.album in albums:
                                    albums[t.album] += 3
                                else:
                                    temp_results.append([1, t.album, track, playlist[6], 0])
                                    albums[t.album] = 3

                            elif search_magic_any(s_text, artist) and search_magic_any(s_text, album):

                                if t.album in albums:
                                    albums[t.album] += 3
                                else:
                                    temp_results.append([1, t.album, track, playlist[6], 0])
                                    albums[t.album] = 3

                            if s_text in title:

                                if t not in tracks:

                                    value = 50
                                    if s_text == title:
                                        value = 2000

                                    temp_results.append([2, t.title, track, playlist[6], value])

                                    tracks.add(t)


                            else:
                                if t not in tracks:
                                    temp_results.append([2, t.title, track, playlist[6], 1])

                                    tracks.add(t)


                        br += 1
                        if br > 100:
                            time.sleep(0.0002)
                            br = 0
                            if search_over.searched_text != search_over.search_text.text:
                                break

                search_over.sip = False
                search_over.on = 0
                gui.update += 1

                for i, item in enumerate(temp_results):
                    if item[0] == 0:
                        temp_results[i][4] = artists[item[1]]
                    if item[0] == 1:
                        temp_results[i][4] = albums[item[1]]
                    if item[0] == 3:
                        temp_results[i][4] = genres[item[1]]
                    if item[0] == 5:
                        temp_results[i][4] = metas[item[1]]
                        if metas[item[1]] < 42:
                            temp_results[i] = None
                    if item[0] == 6:
                        temp_results[i][4] = composers[item[1]]

                temp_results[:] = [item for item in temp_results if item is not None]

                search_over.results = sorted(temp_results, key=lambda x: x[4], reverse=True)

                search_over.on = 0
                search_over.force_select = 0

def encode_folder_name(track_object):

    folder_name = track_object.artist + " - " + track_object.album

    if folder_name == " - ":
        folder_name = track_object.filename

    "".join([c for c in folder_name if c.isalpha() or c.isdigit() or c == ' ']).rstrip()

    if folder_name[-1:] == ' ':
        folder_name = track_object.filename

    for c in r'[]/\;,><&*:%=+@!#^()|?^.':
        folder_name = folder_name.replace(c, '')

    return folder_name


def worker1():
    global cue_list
    global loaderCommand
    global loaderCommandReady
    global DA_Formats
    global master_count
    global home
    global loading_in_progress
    global added
    global to_get
    global to_got

    loaded_pathes_cache = {}
    added = []

    def get_end_folder(direc):

        for w in range(len(direc)):
            if direc[-w - 1] == '\\' or direc[-w - 1] == '/':
                direc = direc[-w:]
                return direc
        return None

    def add_from_cue(path):

        global added
        global master_count

        cued = []

        try:
            print("Reading CUE file: " + path)
        except:
            print("Error reading path")

        try:

            try:

                with open(path, encoding="utf_8") as f:
                    content = f.readlines()
            except:
                try:
                    with open(path, encoding="utf_16") as f:
                        content = f.readlines()
                        print("CUE: Detected encoding as UTF-16")
                except:
                    try:
                        with open(path, encoding='shiftjis') as f:
                            content = f.readlines()
                        print("CUE: Detected encoding as SHIFT-JIS")

                    except:
                        print("WARNING: Can't detect encoding of CUE file")
                        return 1

            f.close()

            # GET "FILE" LINE
            count = 0
            fileline = -1

            # print(content)

            for i in range(len(content)):
                if 'FILE "' in content[i]:
                    count += 1
                    fileline = i
                    if count > 1:
                        return 1

            if fileline == -1:
                return 1

            FILE = content[fileline]
            # print("FILELINE IS :" + FILE)

            filename = ""
            switch = 0
            for i in range(len(FILE)):
                if switch == 1 and FILE[i] == '"':
                    break

                if switch == 1:
                    filename += FILE[i]

                if FILE[i] == '"':
                    switch = 1

            filepath = os.path.dirname(path.replace('\\', '/')) + "/" + filename

            try:
                # print(filepath)
                if os.path.isfile(filepath) is True:

                    source_track = TrackClass()
                    source_track.fullpath = filepath
                    source_track = tag_scan(source_track)
                    lasttime = source_track.length

                else:
                    print("CUE: The referenced source file wasn't found. Searching for matching file name...")

                    for item in os.listdir(os.path.dirname(filepath)):
                        if os.path.splitext(item)[0] == os.path.splitext(os.path.basename(path))[
                                0] and "cue" not in item.lower():
                            filepath = os.path.dirname(filepath) + "/" + item
                            print("CUE: Source found")
                            break
                    else:
                        print("CUE: Source file not found")
                        return 1

                    source_track = TrackClass()
                    source_track.fullpath = filepath
                    source_track = tag_scan(source_track)
                    lasttime = source_track.length

            except:
                print("CUE Error: Unable to read file length")
                return 1

            # Get length from backend
            if lasttime == 0 and prefs.backend == 1:
                lasttime = get_backend_time(filepath)

            LENGTH = 0
            PERFORMER = ""
            TITLE = ""
            START = 0
            DATE = ""
            ALBUM = ""
            GENRE = ""
            MAIN_PERFORMER = ""

            for LINE in content:
                if 'TITLE "' in LINE:
                    ALBUM = LINE[7:len(LINE) - 2]

                if 'PERFORMER "' in LINE:
                    while LINE[0] != "P":
                        LINE = LINE[1:]

                    MAIN_PERFORMER = LINE[11:len(LINE) - 2]

                if 'REM DATE' in LINE:
                    DATE = LINE[9:len(LINE) - 1]

                if 'REM GENRE' in LINE:
                    GENRE = LINE[10:len(LINE) - 1]

                if 'TRACK ' in LINE:
                    break

            for LINE in reversed(content):
                if len(LINE) > 100:
                    return 1
                if "INDEX 01 " in LINE:
                    temp = ""
                    pos = len(LINE)
                    pos -= 1
                    while LINE[pos] != ":":
                        pos -= 1
                        if pos < 8:
                            break

                    START = int(LINE[pos - 2:pos]) + (int(LINE[pos - 5:pos - 3]) * 60)
                    LENGTH = int(lasttime) - START
                    lasttime = START

                elif 'PERFORMER "' in LINE:
                    switch = 0
                    for i in range(len(LINE)):
                        if switch == 1 and LINE[i] == '"':
                            break
                        if switch == 1:
                            PERFORMER += LINE[i]
                        if LINE[i] == '"':
                            switch = 1

                elif 'TITLE "' in LINE:

                    switch = 0
                    for i in range(len(LINE)):
                        if switch == 1 and LINE[i] == '"':
                            break
                        if switch == 1:
                            TITLE += LINE[i]
                        if LINE[i] == '"':
                            switch = 1

                elif 'TRACK ' in LINE:
                    pos = 0
                    while LINE[pos] != 'K':
                        pos += 1
                        if pos > 15:
                            return 1
                    TN = LINE[pos + 2:pos + 4]

                    TN = int(TN)

                    # try:
                    #     bitrate = audio.info.bitrate
                    # except:
                    #     bitrate = 0

                    if PERFORMER == "":
                        PERFORMER = MAIN_PERFORMER

                    nt = TrackClass()
                    nt.index = master_count
                    nt.fullpath = filepath.replace('\\', '/')
                    nt.filename = filename
                    nt.parent_folder_path = os.path.dirname(filepath.replace('\\', '/'))
                    nt.parent_folder_name = os.path.splitext(os.path.basename(filepath))[0]
                    nt.file_ext = os.path.splitext(os.path.basename(filepath))[1][1:].upper()

                    nt.album_artist = MAIN_PERFORMER
                    nt.artist = PERFORMER
                    nt.title = TITLE
                    nt.length = LENGTH
                    nt.genre = GENRE
                    nt.bitrate = source_track.bitrate
                    nt.album = ALBUM
                    nt.date = DATE.replace('"', '')
                    nt.track_number = TN
                    nt.start_time = START
                    nt.is_cue = True
                    nt.size = 0 #source_track.size
                    nt.samplerate = source_track.samplerate
                    if TN == 1:
                        nt.size = os.path.getsize(nt.fullpath)

                    pctl.master_library[master_count] = nt

                    cued.append(master_count)
                    loaded_pathes_cache[filepath.replace('\\', '/')] = master_count
                    # added.append(master_count)

                    master_count += 1
                    LENGTH = 0
                    PERFORMER = ""
                    TITLE = ""
                    START = 0
                    TN = 0

            added += reversed(cued)
            cue_list.append(filepath)

        except:
            print("Error in processing CUE file")
            # raise

    def add_file(path):
        # bm.get("add file start")
        global master_count
        global DA_Formats
        global to_got

        if not os.path.isfile(path):
            print("file to import missing")
            return 0

        if os.path.splitext(path)[1][1:] in {"CUE", 'cue'}:
            add_from_cue(path)
            return 0

        if len(path) > 4 and os.path.split(path)[1][-5:].lower() == '.xspf':
            print('found XSPF file at: ' + path)
            load_xspf(path)
            return 0

        if os.path.splitext(path)[1][1:].lower() not in DA_Formats:
            if os.path.splitext(path)[1][1:].lower() in Archive_Formats:
                if not prefs.auto_extract:
                    show_message("You attempted to drop an archive.", 'info', 'However the "extract archive" function is not enabled.')
                else:
                    type = os.path.splitext(path)[1][1:].lower()
                    split = os.path.splitext(path)
                    target_dir = split[0]
                    if prefs.extract_to_music and music_folder is not None:
                        target_dir = os.path.join(music_folder, os.path.basename(target_dir))
                    # print(os.path.getsize(path))
                    if os.path.getsize(path) > 2e+9:
                        print("Archive file is large!")
                        show_message("Skipping oversize zip file (>2GB)")
                        return 1
                    if not os.path.isdir(target_dir) and not os.path.isfile(target_dir):
                        if type == "zip":
                            try:
                                b = to_got
                                to_got = "ex"
                                gui.update += 1
                                zip_ref = zipfile.ZipFile(path, 'r')

                                zip_ref.extractall(target_dir)
                                zip_ref.close()
                            except RuntimeError as e:
                                to_got = b
                                print("Zip error")
                                if 'encrypted' in e:
                                    show_message("Failed to extract zip archive.", 'warning',
                                                 "The archive is encrypted. You'll need to extract it manually with the password.")
                                else:
                                    show_message("Failed to extract zip archive.", 'warning',
                                                 "Maybe archive is corrupted? Does disk have enough space and have write permission?")
                                return 1
                            except:
                                print("Zip error 2")
                                to_got = b
                                show_message("Failed to extract zip archive.", 'warning',  "Maybe archive is corrupted? Does disk have enough space and have write permission?")
                                return 1

                        elif type == 'rar':
                            b = to_got
                            try:
                                to_got = "ex"
                                gui.update += 1
                                line = launch_prefix + "unrar x -y -p- " + shlex.quote(path) + " " + shlex.quote(target_dir) + os.sep
                                result = subprocess.run(shlex.split(line))
                                print(result)
                            except:
                                to_got = b
                                show_message("Failed to extract rar archive.", 'warning')

                                return 1

                        elif type == '7z':
                            b = to_got
                            try:
                                to_got = "ex"
                                gui.update += 1
                                line = launch_prefix + "7z x -y " + shlex.quote(path) + " -o" + shlex.quote(target_dir) + os.sep
                                result = subprocess.run(shlex.split(line))
                                print(result)
                            except:
                                to_got = b
                                show_message("Failed to extract 7z archive.", 'warning')

                                return 1

                        upper = os.path.dirname(target_dir)
                        cont = os.listdir(target_dir)
                        new = upper + "/temporaryfolderd"
                        error = False
                        if len(cont) == 1 and os.path.isdir(split[0] + "/" + cont[0]):
                            print("one thing")
                            os.rename(target_dir, new)
                            try:
                                shutil.move(new + "/" + cont[0], upper)
                            except:
                                error = True
                            shutil.rmtree(new)
                            print(new)
                            target_dir = upper + "/" + cont[0]
                            if not os.path.isdir(target_dir):
                                print("Extract error, expected directory not found")

                        if True and not error and prefs.auto_del_zip:
                            print("Moving archive file to trash: " + path)
                            try:
                                send2trash(path)
                            except:
                                show_message("Could not move archive to trash", 'info', path)


                        to_got = b
                        gets(target_dir)
                        quick_import_done.append(target_dir)
                    # gets(target_dir)

            return 1

        to_got += 1
        gui.update = 1

        path = path.replace('\\', '/')

        if path in loaded_pathes_cache:
            de = loaded_pathes_cache[path]
            if pctl.master_library[de].fullpath in cue_list:
                # bm.get("File has an associated .cue file... Skipping")
                return
            added.append(de)
            # if gui.auto_play_import:
            #     pctl.jump(copy.deepcopy(de))
            #
            #     gui.auto_play_import = False
            # bm.get("dupe track")
            return

        time.sleep(0.002)

        # audio = auto.File(path)

        nt = TrackClass()

        nt.index = master_count
        nt.fullpath = path.replace('\\', '/')
        nt.filename = os.path.basename(path)
        nt.parent_folder_path = os.path.dirname(path.replace('\\', '/'))
        nt.parent_folder_name = get_end_folder(os.path.dirname(path))
        nt.file_ext = os.path.splitext(os.path.basename(path))[1][1:].upper()

        nt = tag_scan(nt)

        if nt.cue_sheet != "":
            cue_scan(nt.cue_sheet, nt)
            del nt

        else:

            pctl.master_library[master_count] = nt
            added.append(master_count)
            master_count += 1

        # bm.get("fill entry")
        if gui.auto_play_import:
            pctl.jump(master_count - 1)
            gui.auto_play_import = False

    # Count the approx number of files to be imported, recursively
    def pre_get(direc):
        global DA_Formats
        global to_get

        items_in_dir = os.listdir(direc)
        for q in range(len(items_in_dir)):
            if os.path.isdir(os.path.join(direc, items_in_dir[q])):
                pre_get(os.path.join(direc, items_in_dir[q]))
            else:
                to_get += 1
                gui.update += 1
            if gui.im_cancel:
                return

        # for q in range(len(items_in_dir)):
        #     if os.path.isdir(os.path.join(direc, items_in_dir[q])) is False:
        #         if os.path.splitext(items_in_dir[q])[1][1:].lower() in DA_Formats:
        #             to_get += 1
        #             gui.update += 1
        #     if gui.im_cancel:
        #         return


    def gets(direc):

        global DA_Formats
        global master_count

        if os.path.basename(direc) == "__MACOSX":
            return

        items_in_dir = os.listdir(direc)
        for q in range(len(items_in_dir)):
            if os.path.isdir(os.path.join(direc, items_in_dir[q])):
                gets(os.path.join(direc, items_in_dir[q]))
            if gui.im_cancel:
                return
        for q in range(len(items_in_dir)):
            if os.path.isdir(os.path.join(direc, items_in_dir[q])) is False:

                if os.path.splitext(items_in_dir[q])[1][1:].lower() in DA_Formats:

                    if len(items_in_dir[q]) > 2 and items_in_dir[q][0:2] == "._":
                        continue

                    add_file(os.path.join(direc, items_in_dir[q]).replace('\\', '/'))

                elif os.path.splitext(items_in_dir[q])[1][1:] in {"CUE", 'cue'}:
                    add_from_cue(os.path.join(direc, items_in_dir[q]).replace('\\', '/'))
            if gui.im_cancel:
                return

    def cache_paths():
        dic = {}
        for key, value in pctl.master_library.items():
            dic[value.fullpath.replace('\\', '/')] = key
        return dic

    # print(pctl.master_library)

    global transcode_list
    global transcode_state
    global album_art_gen
    global cm_clean_db
    global to_got
    global to_get
    global move_in_progress

    while True:
        time.sleep(0.15)

        artist_list_box.worker()

        if prefs.auto_extract and prefs.monitor_downloads:
            dl_mon.scan()

        if tauon.worker_save_state and \
                not gui.pl_pulse and \
                not loading_in_progress and \
                not to_scan and \
                not plex.scanning and \
                not cm_clean_db and \
                not lastfm.scanning_friends and \
                not move_in_progress and \
                gui.update == 0:
            save_state()
            cue_list.clear()
            tauon.worker_save_state = False

        # Folder moving
        if len(move_jobs) > 0:
            gui.update += 1
            move_in_progress = True
            job = move_jobs[0]
            del move_jobs[0]

            if job[0].strip("\\/") == job[1].strip("\\/"):
                show_message("Folder copy error.", "info", "The target and source are the same.")
                gui.update += 1
                move_in_progress = False
                continue

            try:
                shutil.copytree(job[0], job[1])
            except:
                move_in_progress = False
                gui.update += 1
                show_message("The folder copy has failed!", 'warning', 'Some files may have been written.')
                continue

            if job[2] == True:
                try:
                    shutil.rmtree(job[0])

                except:
                    show_message("Something has gone horribly wrong!.", 'error', "Could not delete " + job[0])
                    gui.update += 1
                    move_in_progress = False
                    return


                show_message("Folder move complete.", 'done', "Folder name: " + job[3])
            else:
                show_message("Folder copy complete.", 'done', "Folder name: " + job[3])



            move_in_progress = False
            load_orders.append(job[4])
            gui.update += 1


        # Clean database
        if cm_clean_db is True:
            items_removed = 0

            #old_db = copy.deepcopy(pctl.master_library)
            to_got = 0
            to_get = len(pctl.master_library)

            keys = set(pctl.master_library.keys())
            for index in keys:
                time.sleep(0.0001)
                track = pctl.master_library[index]
                to_got += 1
                if to_got % 100 == 0:
                    gui.update = 1
                if not os.path.isfile(track.fullpath):

                    # Remove from all playlists
                    for playlist in pctl.multi_playlist:
                        while index in playlist[2]:
                            album_dex.clear()
                            playlist[2].remove(index)

                    # Remove from playback history
                    while index in pctl.track_queue:
                        pctl.track_queue.remove(index)
                        pctl.queue_step -= 1

                    # Remove track from force queue
                    for i in reversed(range(len(pctl.force_queue))):
                        if pctl.force_queue[i][0] == index:
                            del pctl.force_queue[i]

                    del pctl.master_library[index]
                    items_removed += 1

            cm_clean_db = False
            show_message("Cleaning complete.", 'done', str(items_removed) + " items were removed from the database.")
            if album_mode:
                reload_albums(True)
            if gui.combo_mode:
                reload_albums()
                # combo_pl_render.pl_pos_px = 0
                # combo_pl_render.prep(True)
            gui.update = 1
            gui.pl_update = 1
            tauon.worker_save_state = True

        # FOLDER ENC
        if transcode_list:

            try:
                transcode_state = ""
                gui.update += 1

                folder_items = transcode_list[0]

                ref_track_object = pctl.master_library[folder_items[0]]
                ref_album = ref_track_object.album

                # Generate a folder name based on artist and album of first track in batch
                folder_name = encode_folder_name(ref_track_object)

                # If folder contains tracks from multiple albums, use original folder name instead
                for item in folder_items:
                    test_object = pctl.master_library[item]
                    if test_object.album != ref_album:
                        folder_name = ref_track_object.parent_folder_name
                        break

                print("Transcoding folder: " + folder_name)

                # Remove any existing matching folder
                if os.path.isdir(prefs.encoder_output + folder_name):
                    shutil.rmtree(prefs.encoder_output + folder_name)

                # Create new empty folder to output tracks to
                os.makedirs(prefs.encoder_output + folder_name)

                working_folder = prefs.encoder_output + folder_name

                full_wav_out = '"' + prefs.encoder_output + 'output.wav"'
                full_wav_out_p = prefs.encoder_output + 'output.wav'
                full_target_out_p = prefs.encoder_output + 'output.' + prefs.transcode_codec
                full_target_out = '"' + prefs.encoder_output + 'output.' + prefs.transcode_codec + '"'

                if os.path.isfile(full_wav_out_p):
                    os.remove(full_wav_out_p)
                if os.path.isfile(full_target_out_p):
                    os.remove(full_target_out_p)


                if prefs.transcode_codec in ('opus', 'ogg', 'flac', 'mp3'):
                    global core_use
                    cores = os.cpu_count()

                    total = len(folder_items)
                    gui.transcoding_batch_total = total
                    gui.transcoding_bach_done = 0

                    q = 0
                    while True:

                        if core_use < cores and q < len(folder_items):
                            core_use += 1
                            agg = [[folder_items[q], folder_name]]
                            loaderThread = threading.Thread(target=transcode_single, args=agg)
                            loaderThread.daemon = True
                            loaderThread.start()
                            q += 1
                            gui.update += 1
                        time.sleep(0.05)
                        if gui.tc_cancel:
                            while core_use > 0:
                                time.sleep(1)
                            break
                        if q == len(folder_items) and core_use == 0:
                            gui.update += 1
                            break

                else:
                    print("Codec error")

                output_dir = prefs.encoder_output + folder_name + "/"
                if prefs.transcode_inplace:
                    remove_target = output_dir.rstrip("/")
                    try:
                        os.remove(remove_target)
                    except:
                        print("Encode folder not removed")
                    reload_metadata(folder_items[0])
                else:
                    album_art_gen.save_thumb(folder_items[0], (1080, 1080), output_dir + "cover")

                print(transcode_list[0])

                del transcode_list[0]
                transcode_state = ""
                gui.update += 1

            except:
                transcode_state = "Transcode Error"
                time.sleep(0.2)
                show_message("Transcode failed.", 'error', "An error was encountered.")
                gui.update += 1
                time.sleep(0.1)
                del transcode_list[0]

            if len(transcode_list) == 0:
                if gui.tc_cancel:
                    gui.tc_cancel = False
                    show_message("The transcode was canceled before completion.", 'warning', "Incomplete files will remain.")
                else:
                    line = "Press F9 to show output."
                    if prefs.transcode_codec == 'flac':
                        line = "Note that any associated output picture is a thumbnail and not an exact copy."
                    if not gui.message_box:
                        show_message("Encoding complete.", 'done', line)
                    if system == 'linux' and not window_is_focused() and de_nofity_support:
                        g_tc_notify.show()

        while len(to_scan) > 0:
            track = to_scan[0]
            pctl.master_library[track] = tag_scan(pctl.master_library[track])
            del to_scan[0]
            gui.update += 1

        if loaderCommandReady is True:


            for order in load_orders:
                if order.stage == 1:
                    if loaderCommand == LC_Folder:
                        to_get = 0
                        to_got = 0
                        loaded_pathes_cache = cache_paths()
                        pre_get(order.target)
                        gets(order.target)
                    elif loaderCommand == LC_File:
                        loaded_pathes_cache = cache_paths()
                        add_file(order.target)

                    if gui.im_cancel:
                        gui.im_cancel = False
                        to_get = 0
                        to_got = 0
                        load_orders.clear()
                        added = []
                        loaderCommand = LC_Done
                        loaderCommandReady = False
                        break

                    loaderCommand = LC_Done
                    order.tracks = added

                    # Double check for cue dupes
                    for i in reversed(range(len(order.tracks))):
                        if pctl.master_library[order.tracks[i]].fullpath in cue_list:
                            if pctl.master_library[order.tracks[i]].is_cue is False:
                                del order.tracks[i]

                    added = []
                    order.stage = 2
                    loaderCommandReady = False
                    break



def get_album_info(position):

    if position > len(default_playlist) - 1:
        position = len(default_playlist) - 1
    current = position

    while position > 0 and current > 0:

        if pctl.master_library[default_playlist[position]].parent_folder_name == pctl.master_library[
                default_playlist[current - 1]].parent_folder_name:
            current -= 1
            continue
        else:
            break

    album = []
    playing = 0
    select = False
    while current < len(default_playlist):
        album.append(current)
        if len(pctl.track_queue) > 0 and default_playlist[current] == pctl.track_queue[pctl.queue_step]:
            playing = 1
        if current == playlist_selected:
            select = True
        if current < len(default_playlist) - 1 and pctl.master_library[default_playlist[current]].parent_folder_name != pctl.master_library[
                default_playlist[current + 1]].parent_folder_name:
            break
        else:
            current += 1
    if not album:
        #album = [default_playlist[len(default_playlist) - 1]]
        album = [len(default_playlist) - 1]

    return playing, album, select


def get_folder_list(index):
    playlist = []

    for item in default_playlist:
        if pctl.master_library[item].parent_folder_name == pctl.master_library[index].parent_folder_name and \
                        pctl.master_library[item].album == pctl.master_library[index].album:
            playlist.append(item)
    return list(set(playlist))




def gal_jump_select(up=False, num=1):
    global playlist_selected
    old_selected = playlist_selected
    old_num = num

    if not default_playlist:
        return

    on = playlist_selected
    if on > len(default_playlist) - 1:
        on = 0
        playlist_selected = 0

    if up is False:


        while num > 0:
            while pctl.master_library[
                default_playlist[on]].parent_folder_name == pctl.master_library[
                    default_playlist[playlist_selected]].parent_folder_name:
                on += 1

                if on > len(default_playlist) - 1:
                    playlist_selected = old_selected
                    return

            playlist_selected = on
            num -= 1
    else:



        if num > 1:

            if playlist_selected > len(default_playlist) - 1    :
                playlist_selected = old_selected
                return

            alb = get_album_info(playlist_selected)
            if alb[1][0] in album_dex[:num]:
                playlist_selected = old_selected
                return

        while num > 0:

            alb = get_album_info(playlist_selected)

            # if len(alb[1]) == 0:
            #     playlist_selected = len(default_playlist) - 1
            #     return
            if alb[1][0] > -1:
                on = alb[1][0] - 1

            playlist_selected = max(get_album_info(on)[1][0], 0)
            num -= 1



power_tag_colours = ColourGenCache(0.5, 0.8)

class PowerTag:

    def __init__(self):

        self.name = "BLANK"
        self.position = 0
        self.colour = None

        self.peak_x = 0
        self.ani_timer = Timer()
        self.ani_timer.force_set(10)

gui.pt_on = Timer()
gui.pt_off = Timer()
gui.pt = 0


def gen_power2():

    tags = {}  # [tag name]: (first position, number of times we saw it)
    tag_list = []

    last = 'a'
    noise = 0

    def key(tag):
        return tags[tag][1]

    for position in album_dex:

        index = default_playlist[position]
        track = pctl.g(index)

        crumbs = track.parent_folder_path.split("/")

        for i, b in enumerate(crumbs):

            if i > 0 and (track.artist in b and track.artist):
                tag = crumbs[i - 1]

                if tag != last:
                    noise += 1
                last = tag

                if tag in tags:
                    tags[tag][1] += 1
                else:
                    tags[tag] = [position, 1]
                    tag_list.append(tag)
                break

    if noise > len(album_dex) / 2:
        print("Playlist is too noisy for power bar.")
        return []

    tag_list_sort = sorted(tag_list, key=key, reverse=True)

    max_tags = round((window_size[1] - gui.panelY - gui.panelBY - 10) // 30 * gui.scale)

    tag_list_sort = tag_list_sort[:max_tags]

    for i in reversed(range(len(tag_list))):
        if tag_list[i] not in tag_list_sort:
            del tag_list[i]

    h = []

    for tag in tag_list:

        if tags[tag][1] > 2:

            t = PowerTag()
            t.name = tag.upper()
            t.position = tags[tag][0]
            h.append(t)

    cc = random.random()
    cj = 0.03
    if len(h) < 5:
        cj = 0.11

    cj = 0.5 / max(len(h), 2)

    for item in h:
        item.colour = hsl_to_rgb(cc, 0.8, 0.7)
        cc += cj

    return h


def reload_albums(quiet=False):
    global album_dex
    global update_layout
    global album_pos_px
    global old_album_pos

    if cm_clean_db:
        # Doing reload while things are being removed may cause crash
        return

    if not quiet:
        album_pos_px = old_album_pos

    current_folder = ""
    album_dex = []

    for i in range(len(default_playlist)):
        if i == 0:
            album_dex.append(i)
            current_folder = pctl.master_library[default_playlist[i]].parent_folder_name
        else:
            if pctl.master_library[default_playlist[i]].parent_folder_name != current_folder:
                current_folder = pctl.master_library[default_playlist[i]].parent_folder_name
                album_dex.append(i)

    gui.update += 2
    gui.pl_update = 1
    update_layout = True

    if not quiet:
        goto_album(pctl.playlist_playing_position)


    # Generate POWER BAR
    gui.power_bar = gen_power2()
    gui.pt = 0

# ------------------------------------------------------------------------------------
# WEBSERVER

from t_modules.t_webserve import webserve

if prefs.enable_web is True:
    webThread = threading.Thread(target=webserve, args=[pctl, prefs, gui, album_art_gen, install_directory])
    webThread.daemon = True
    webThread.start()

# --------------------------------------------------------------

def star_line_toggle(mode=0):

    if mode == 1:
        return gui.star_mode == 'line'

    if gui.star_mode == 'line':
        gui.star_mode = 'none'
    else:
        gui.star_mode = 'line'

    gui.update += 1
    gui.pl_update = 1

def star_toggle(mode=0):

    if mode == 1:
        return gui.star_mode == 'star'

    if gui.star_mode == 'star':
        gui.star_mode = 'none'
    else:
        gui.star_mode = 'star'

    gui.update += 1
    gui.pl_update = 1

def heart_toggle(mode=0):

    if mode == 1:
        return gui.show_hearts

    gui.show_hearts ^= True

    gui.update += 1
    gui.pl_update = 1

def toggle_titlebar_line(mode=0):
    global update_title
    if mode == 1:
        return update_title

    line = window_title
    SDL_SetWindowTitle(t_window, line)
    update_title ^= True
    if update_title:
        update_title_do()


def scale1(mode=0):

    if mode == 1:
        if prefs.ui_scale == 1:
            return True
        else:
            return False

    prefs.ui_scale = 1
    pref_box.small_preset()

    if prefs.ui_scale != gui.scale:
        show_message(_("Change will be applied on restart."))


def scale125(mode=0):
    if mode == 1:
        if prefs.ui_scale == 1.25:
            return True
        else:
            return False

    prefs.ui_scale = 1.25
    pref_box.small_preset()

    if prefs.ui_scale != gui.scale:
        show_message(_("Change will be applied on restart."))

def toggle_min_tray(mode=0):
    if mode == 1:
        return prefs.min_to_tray
    prefs.min_to_tray ^= True

def scale2(mode=0):
    if mode == 1:
        if prefs.ui_scale == 2:
            return True
        else:
            return False

    prefs.ui_scale = 2
    pref_box.small_preset()

    if prefs.ui_scale != gui.scale:
        show_message(_("Change will be applied on restart."))



def toggle_borderless(mode=0):
    global draw_border
    global update_layout


    if mode == 1:
        return draw_border

    update_layout = True
    draw_border ^= True

    if draw_border:
        SDL_SetWindowBordered(t_window, False)
    else:
        SDL_SetWindowBordered(t_window, True)


config_items = [
    [_('Show playtime lines'), star_line_toggle],
    [_('Show playtime stars'), star_toggle],
    #None,
    [_('Show love hearts'), heart_toggle],
    None
]


def toggle_break(mode=0):
    global break_enable
    if mode == 1:
        return break_enable ^ True
    else:
        break_enable ^= True
        gui.pl_update = 1


# def toggle_dd(mode=0):
#     global dd_index
#
#     if mode == 1:
#         return dd_index
#     else:
#         dd_index ^= True
#         gui.pl_update = 1


def toggle_scroll(mode=0):
    global scroll_enable
    global update_layout

    if mode == 1:
        if scroll_enable:
            return False
        else:
            return True

    else:
        scroll_enable ^= True
        gui.pl_update = 1
        update_layout = True


# def toggle_follow(mode=0):
#     global pl_follow
#
#     if mode == 1:
#         return pl_follow
#     else:
#         pl_follow ^= True
#     if pl_follow is True:
#         if prefs.end_setting == 'advance' or prefs.end_setting == 'cycle':
#             prefs.end_setting = 'stop'


def toggle_playback_follow(mode=0):
    if mode == 1:
        return prefs.playback_follow_cursor
    prefs.playback_follow_cursor ^= True


def toggle_hide_bar(mode=0):
    if mode == 1:
        return gui.set_bar ^ True
    gui.set_bar ^= True
    show_message("Tip: You can also toggle this from a right-click context menu")


def toggle_auto_import_sort(mode=0):
    if mode == 1:
        return prefs.auto_sort
    prefs.auto_sort ^= True
    if prefs.auto_sort:
        show_message("This will automatically apply 'Filepath' and 'Year per Artist' sorting functions to playlist when importing.")


def toggle_append_total_time(mode=0):
    if mode == 1:
        return prefs.append_total_time
    prefs.append_total_time ^= True
    gui.pl_update = 1
    gui.update += 1

def toggle_append_date(mode=0):
    if mode == 1:
        return prefs.append_date
    prefs.append_date ^= True
    gui.pl_update = 1
    gui.update += 1

def toggle_true_shuffle(mode=0):
    if mode == 1:
        return prefs.true_shuffle
    prefs.true_shuffle ^= True


def toggle_enable_web(mode=0):
    if mode == 1:
        return prefs.enable_web

    prefs.enable_web ^= True

    if prefs.enable_web and not gui.web_running:
        webThread = threading.Thread(target=webserve, args=[pctl, prefs, gui, album_art_gen, install_directory])
        webThread.daemon = True
        webThread.start()
        show_message("Web server starting", 'done', "External connections will be accepted.")

    elif prefs.enable_web is False:
        requests.post("http://localhost:7590/shutdown")
        time.sleep(0.25)


def toggle_scrobble_mark(mode=0):
    if mode == 1:
        return prefs.scrobble_mark
    prefs.scrobble_mark ^= True


def toggle_lfm_auto(mode=0):
    if mode == 1:
        return prefs.auto_lfm
    prefs.auto_lfm ^= True
    if prefs.auto_lfm:
        lastfm.hold = False
    else:
        lastfm.hold = True

def toggle_lb(mode=0):
    if mode == 1:
        return lb.enable
    if not lb.enable and not prefs.lb_token:
        show_message("Can't enable this if there's no token.", 'warning')
        return
    lb.enable ^= True
    if lb.enable:
        lb.hold = False
    else:
        lb.hold = True


# def toggle_resume_state(mode=0):
#     if mode == 1:
#         return prefs.reload_play_state
#     prefs.reload_play_state ^= True

def toggle_ex_del(mode=0):
    if mode == 1:
        return prefs.auto_del_zip
    prefs.auto_del_zip ^= True
    # if prefs.auto_del_zip is True:
    #     show_message("Caution! This function deletes things!", 'info', "This could result in data loss if the process were to malfunction.")

def toggle_dl_mon(mode=0):
    if mode == 1:
        return prefs.monitor_downloads

    prefs.monitor_downloads ^= True

def toggle_music_ex(mode=0):
    if mode == 1:
        return prefs.extract_to_music

    prefs.extract_to_music ^= True


def toggle_extract(mode=0):
    if mode == 1:
        return prefs.auto_extract
    prefs.auto_extract ^= True
    if prefs.auto_extract is False:
        prefs.auto_del_zip = False

def toggle_top_tabs(mode=0):
    if mode == 1:
        return prefs.tabs_on_top
    prefs.tabs_on_top ^= True


def toggle_guitar_chords(mode=0):
    if mode == 1:
        return prefs.guitar_chords
    prefs.guitar_chords ^= True


def toggle_auto_lyrics(mode=0):
    if mode == 1:
        return prefs.auto_lyrics
    prefs.auto_lyrics ^= True


def toggle_lyricwiki(mode=0):
    if mode == 1:
        return 'lyricwiki' in prefs.lyrics_enables

    if 'lyricwiki' in prefs.lyrics_enables:
        prefs.lyrics_enables.clear()
    else:
        prefs.lyrics_enables.append("lyricwiki")


def toggle_apiseeds(mode=0):
    if mode == 1:
        return 'apiseeds' in prefs.lyrics_enables

    if 'apiseeds' in prefs.lyrics_enables:
        prefs.lyrics_enables.clear()
    else:
        prefs.lyrics_enables.append("apiseeds")


def switch_single(mode=0):
    if mode == 1:
        if prefs.transcode_mode == 'single':
            return True
        else:
            return False
    prefs.transcode_mode = 'single'


def switch_mp3(mode=0):
    if mode == 1:
        if prefs.transcode_codec == 'mp3':
            return True
        else:
            return False
    prefs.transcode_codec = 'mp3'


def switch_ogg(mode=0):
    if mode == 1:
        if prefs.transcode_codec == 'ogg':
            return True
        else:
            return False
    prefs.transcode_codec = 'ogg'


def switch_opus(mode=0):
    if mode == 1:
        if prefs.transcode_codec == 'opus':
            return True
        else:
            return False
    prefs.transcode_codec = 'opus'

def switch_opus_ogg(mode=0):
    if mode == 1:
        if prefs.transcode_opus_as:
            return True
        else:
            return False
    prefs.transcode_opus_as ^= True


def toggle_transcode_output(mode=0):
    if mode == 1:
        if prefs.transcode_inplace:
            return False
        else:
            return True
    prefs.transcode_inplace ^= True
    if prefs.transcode_inplace:
        transcode_icon.colour = [250, 20, 20, 255]
        show_message("DANGER! This will delete the original files. You may want to have backups in case of malfunction.",
                     'warning', "For safety, this setting will reset on restart. Embedded thumbnails are not kept so you may want to extract them first.")
    else:
        transcode_icon.colour = [239, 74, 157, 255]

def toggle_transcode_inplace(mode=0):
    if mode == 1:
        if prefs.transcode_inplace:
            return True
        else:
            return False
    prefs.transcode_inplace ^= True
    if prefs.transcode_inplace:
        transcode_icon.colour = [250, 20, 20, 255]
        show_message("DANGER! This will delete the original files. You may want to have backups in case of malfunction.",
                     'warning', "For safety, this setting will reset on restart. Embedded thumbnails are not kept so you may want to extract them first.")
    else:
        transcode_icon.colour = [239, 74, 157, 255]

def switch_flac(mode=0):
    if mode == 1:
        if prefs.transcode_codec == 'flac':
            return True
        else:
            return False
    prefs.transcode_codec = 'flac'


def toggle_sbt(mode=0):
    if mode == 1:
        return prefs.prefer_bottom_title
    prefs.prefer_bottom_title ^= True

def toggle_bba(mode=0):
    if mode == 1:
        return gui.bb_show_art
    gui.bb_show_art ^= True
    gui.update_layout()

def toggle_use_title(mode=0):
    if mode == 1:
        return prefs.use_title
    prefs.use_title ^= True

def switch_rg_off(mode=0):
    if mode == 1:
        return True if prefs.replay_gain == 0 else False
    prefs.replay_gain = 0

def switch_rg_track(mode=0):
    if mode == 1:
        return True if prefs.replay_gain == 1 else False
    prefs.replay_gain = 0 if prefs.replay_gain == 1 else 1
    #prefs.replay_gain = 1

def switch_rg_album(mode=0):
    if mode == 1:
        return True if prefs.replay_gain == 2 else False
    prefs.replay_gain = 0 if prefs.replay_gain == 2 else 2

def toggle_jump_crossfade(mode=0):
    if mode == 1:
        return True if prefs.use_jump_crossfade else False
    prefs.use_jump_crossfade ^= True

def toggle_pause_fade(mode=0):
    if mode == 1:
        return True if prefs.use_pause_fade else False
    prefs.use_pause_fade ^= True

def toggle_transition_crossfade(mode=0):
    if mode == 1:
        return True if prefs.use_transition_crossfade else False
    prefs.use_transition_crossfade ^= True

def toggle_transition_gapless(mode=0):
    if mode == 1:
        return False if prefs.use_transition_crossfade else True
    prefs.use_transition_crossfade ^= True

def toggle_eq(mode=0):
    if mode == 1:
        return prefs.use_eq
    prefs.use_eq ^= True
    pctl.playerCommand = 'reload'
    pctl.playerCommandReady = True


# config_items.append(['Hide scroll bar', toggle_scroll])

# config_items.append(['Turn off playlist title breaks', toggle_break])

# config_items.append([_('Use double digit track indices'), toggle_dd])

# config_items.append(['Use custom line format [broken]', toggle_custom_line])

# config_items.append(['Always use folder name as title', toggle_use_title])

config_items.append([_('Add release year to folder title'), toggle_append_date])
config_items.append([_('Add total duration to folder title'), toggle_append_total_time])

config_items.append(None)

config_items.append([_('Playback follows selected'), toggle_playback_follow])

config_items.append([_('Auto sort on import'), toggle_auto_import_sort])

config_items.append([_('Hide column bar'), toggle_hide_bar])

# config_items.append([_('Shuffle avoids repeats'), toggle_true_shuffle])

# config_items.append([_('Show finish current when queuing album option'), toggle_finish_current])

# config_items.append(['Playback advances to open playlist', toggle_follow])

key_shiftr_down = False
key_ctrl_down = False
key_rctrl_down = False
key_meta = False
key_ralt = False
key_lalt = False


def reload_backend():

    wait = 0
    pre_state = pctl.stop(True)

    while pctl.playerCommandReady:
        time.sleep(0.01)
        wait += 1
        if wait > 400:
            return

    pctl.playerCommand = "unload"
    pctl.playerCommandReady = True


    while pctl.playerCommand != 'done':
        time.sleep(0.01)
        print(pctl.playerCommand)
        wait += 1
        if wait > 400:
            return

    if prefs.backend == 1:
        from t_modules.t_bass import player
        playerThread = threading.Thread(target=bass_player_thread, args=[player])
        playerThread.daemon = True
        playerThread.start()

    elif prefs.backend == 2:
        from t_modules.t_gstreamer import player3
        playerThread = threading.Thread(target=player3, args=[tauon])
        playerThread.daemon = True
        playerThread.start()

    if pre_state == 1:
        pctl.revert()


def set_player_bass(mode=0):

    if mode == 1:
        return True if prefs.backend == 1 else False

    if not os.path.isfile(install_directory + '/lib/libbass.so'):
        show_message("Error: Could not find libbass.so", 'error')
        return

    if prefs.backend != 1:
        prefs.backend = 1
        reload_backend()



def set_player_gstreamer(mode=0):

    if mode == 1:
        return True if prefs.backend == 2 else False

    if prefs.backend != 2:
        show_message("Note: GStreamer support incomplete.", 'info', 'Some functions will be unavailable.')
        prefs.backend = 2
        reload_backend()
        gui.spec = None
        pctl.bass_devices.clear()




class Over:
    def __init__(self):

        global window_size

        self.init2done = False

        self.about_image = asset_loader('v4-a.png')
        self.about_image2 = asset_loader('v4-b.png')
        self.about_image3 = asset_loader('v4-c.png')
        self.about_image4 = asset_loader('v4-d.png')

        self.w = 660 * gui.scale
        self.h = 275 * gui.scale
        self.box_x = int(window_size[0] / 2) - int(self.w / 2)
        self.box_y = int(window_size[1] / 2) - int(self.h / 2)
        self.item_x_offset = 140 * gui.scale

        self.current_path = os.path.expanduser('~')
        self.ext_colours = {}
        self.view_offset = 0
        self.ext_ratio = {}
        self.last_db_size = -1

        self.enabled = False
        self.click = False
        self.right_click = False
        self.scroll = 0
        self.lock = False

        self.drives = []

        self.temp_lastfm_user = ""
        self.temp_lastfm_pass = ""
        self.lastfm_input_box = 0

        self.tab_active = 0
        self.tabs = [
            #["Folder Import", self.files],
            [_("Function"), self.funcs],
            [_("Audio"), self.audio],
            [_("EQ"), self.eq],
            [_("Playlist"), self.config_v],
            [_("View"), self.config_b],
            [_("Transcode"), self.codec_config],
            [_("Accounts"), self.last_fm_box],
            [_("Stats"), self.stats],
            [_("About"), self.about]
        ]

        self.stats_timer = Timer()
        self.stats_timer.force_set(1000)
        self.stats_pl_timer = Timer()
        self.stats_pl_timer.force_set(1000)
        self.total_albums = 0
        self.stats_pl = 0
        self.stats_pl_albums = 0
        self.stats_pl_length = 0

        self.ani_cred = 0
        self.cred_page = 0
        self.ani_fade_on_timer = Timer(force=10)
        self.ani_fade_off_timer = Timer(force=10)

        self.device_scroll_bar_position = 0

        self.lyrics_panel = False
        self.account_view = 0



    def eq(self):

        if prefs.backend != 1:
            return

        y = self.box_y + 55 * gui.scale
        x = self.box_x + 250 * gui.scale

        base_dis = 160 * gui.scale
        center = base_dis // 2
        width = 25 * gui.scale

        range = 12

        self.toggle_square(x - 90 * gui.scale, y - 35 * gui.scale, toggle_eq, "Enable")

        ddt.draw_text((x - 17 * gui.scale, y + 2 * gui.scale), "+", colours.grey(130), 16)
        ddt.draw_text((x - 17 * gui.scale, y + base_dis - 15 * gui.scale), "-", colours.grey(130), 16)

        for i, q in enumerate(prefs.eq):

            bar = [x, y, width, base_dis]

            ddt.rect_r(bar, [40, 40, 40, 255], True)

            bar[0] -= 2 * gui.scale
            bar[1] -= 10 * gui.scale
            bar[2] += 4 * gui.scale
            bar[3] += 20 * gui.scale

            if coll(bar):

                if mouse_down:
                    target = mouse_position[1] - y - center
                    target = (target / center) * range
                    if target > range:
                        target = range
                    if target < range * -1:
                        target = range * -1
                    if -0.1 < target < 0.1:
                        target = 0

                    prefs.eq[i] = target

                    pctl.playerCommand = 'seteq'
                    pctl.playerCommandReady = True

                if self.right_click:
                    prefs.eq[i] = 0
                    pctl.playerCommand = 'seteq'
                    pctl.playerCommandReady = True


            start = (q / range) * center

            bar = [x, y + center, width, start]

            ddt.rect_r(bar, [100, 200, 100, 255], True)

            x += round(29 * gui.scale)

    def audio(self):

        y = self.box_y + 40 * gui.scale
        x = self.box_x + 150 * gui.scale

        # ddt.draw_text((x, y - 22), "Backend", [130, 130, 130, 255], 12)
        # ddt.draw_text((x + 65, y - 22), "Bass Audio Library", [160, 160, 156, 255], 12)

        ddt.draw_text((x, y - 2 * gui.scale), "BASS Audio Library", [220, 220, 220, 255], 213)
        self.toggle_square(x - 20 * gui.scale, y, set_player_bass, "                          ")

        if system == "linux":
            ddt.draw_text((x, y - 25 * gui.scale), "GStreamer", [220, 220, 220, 255], 213)
            self.toggle_square(x - 20 * gui.scale, y - 24 * gui.scale, set_player_gstreamer, "                          ")


        if prefs.backend == 1:

            y = self.box_y + 92 * gui.scale
            x = self.box_x + 130 * gui.scale

            x += 8 * gui.scale
            ddt.draw_text((x, y - 22 * gui.scale), _("ReplayGain"), colours.grey_blend_bg(90), 12)

            y += 4 * gui.scale

            # self.toggle_square(x, y, switch_rg_off, "Off")
            # y += 23 * gui.scale

            self.toggle_square(x, y, switch_rg_album, _("Album gain"))
            x += 105 * gui.scale
            self.toggle_square(x, y, switch_rg_track, _("Track gain"))
            x -= 105 * gui.scale

            y += 46 * gui.scale

            ddt.draw_text((x, y - 20 * gui.scale), _("Transitions"), colours.grey_blend_bg(90), 12)

            y += 5 * gui.scale

            self.toggle_square(x, y, toggle_transition_crossfade, _("Use crossfade"))

            y += 23 * gui.scale

            self.toggle_square(x, y, toggle_transition_gapless, _("Use gapless playback"))

            y += 29 * gui.scale

            self.toggle_square(x, y, toggle_jump_crossfade, _("Use fade on track jump"))
            y += 23 * gui.scale
            self.toggle_square(x, y, toggle_pause_fade, _("Use fade on pause/stop"))

            y = self.box_y + 37 * gui.scale
            x = self.box_x + 385 * gui.scale

            ddt.draw_text((x, y - 22 * gui.scale), _("Set audio output device"), [185, 185, 185, 255], 212)
            # ddt.draw_text((x + 60, y - 20), "Takes effect on text change", [140, 140, 140, 255], 11)

            if len(pctl.bass_devices) > 13:
                self.device_scroll_bar_position = device_scroll.draw(x + 250 * gui.scale, y, 11, 180, self.device_scroll_bar_position, len(pctl.bass_devices) - 11, click=self.click)

            for i, item in enumerate(pctl.bass_devices):

                if i < self.device_scroll_bar_position:
                    continue
                if y > self.box_y + self.h - 40 * gui.scale:
                    break

                rect = (x, y + 4 * gui.scale, 245 * gui.scale, 13)
                #ddt.rect_r(rect, [0, 255, 0, 50])

                if self.click and coll(rect):
                    pctl.set_device = item[4]
                    prefs.last_device = item[0]
                    pctl.playerCommandReady = True
                    pctl.playerCommand = "setdev"

                line = trunc_line(item[0], 10, 245 * gui.scale)

                fields.add(rect)

                if pctl.set_device == item[4]: #item[3] > 0:
                    ddt.draw_text((x, y), line, [150, 150, 150, 255], 10)
                    ddt.draw_text((x - 12 * gui.scale, y + 1 * gui.scale), ">", [140, 140, 140, 255], 213)
                else:
                    if coll(rect):
                        ddt.draw_text((x, y), line, [150, 150, 150, 255], 10)
                    else:
                        ddt.draw_text((x, y), line, [100, 100, 100, 255], 10)
                y += 14 * gui.scale

            y = self.box_y + 240 * gui.scale
            x += 40 * gui.scale
            # ddt.draw_text((x + 75 * gui.scale, y - 2 * gui.scale), _("Settings apply after track change"), colours.grey(100), 11)
            prefs.device_buffer = self.slide_control(x, y, "Device buffer length", 'ms', prefs.device_buffer, 10, 500, 10, self.reload_device)

    def reload_device(self, _):

        pctl.playerCommand = 'reload'
        pctl.playerCommandReady = True

    def toggle_lyrics_view(self):
        self.lyrics_panel ^= True


    def funcs(self):

        x = self.box_x + self.item_x_offset
        y = self.box_y - 10 * gui.scale

        if self.lyrics_panel:

            y += 30 * gui.scale

            self.toggle_square(x, y, toggle_auto_lyrics, _("Auto search lyrics"))
            y += 23 * gui.scale
            self.toggle_square(x, y, toggle_guitar_chords, _("Enable chord lyrics"))

            y += 40 * gui.scale
            ddt.draw_text((x, y), _("Sources:"), colours.grey(100), 11)
            y += 23 * gui.scale
            self.toggle_square(x, y, toggle_apiseeds, _("Apiseeds"))
            y += 23 * gui.scale
            self.toggle_square(x, y, toggle_lyricwiki, _("LyricWiki*"))

            y += 30 * gui.scale
            ddt.draw_text((x + 12 * gui.scale, y), _("*Uses scraping. Enable at your own discretion."),
                          colours.grey_blend_bg(90), 11)
            y += 20 * gui.scale
            ddt.draw_text((x + 12 * gui.scale, y), _("Tip: The order enabled will be the order searched."),
                          colours.grey_blend_bg(90), 11)
            y += 20 * gui.scale

            y += 34 * gui.scale

            self.button(x, y, "Back", self.toggle_lyrics_view, width=65*gui.scale)

        else:

            y += 35 * gui.scale
            self.toggle_square(x, y, toggle_enable_web,
                               _("Serve webpage for broadcast metadata"))

            y += 30 * gui.scale
            self.toggle_square(x, y, toggle_top_tabs, _("Use tabs on top panel"))
            #y += 30 * gui.scale
            # self.toggle_square(x + 10 * gui.scale, y, toggle_expose_web, _("Allow external connections"))
            # y += 23 * gui.scale
            # self.toggle_square(x + 10 * gui.scale, y, toggle_allow_remote, _("Allow remote control"))
            # y += 23 * gui.scale

            # self.toggle_square(x, y, toggle_resume_state, _("Resume playback on launch"))
            #
            # y += 30 * gui.scale


            y += 30 * gui.scale
            self.toggle_square(x, y, toggle_extract, _("Extract archives on import"))
            y += 23 * gui.scale
            self.toggle_square(x + 10 * gui.scale, y, toggle_ex_del, _("Trash archive after extraction"))
            y += 23 * gui.scale
            self.toggle_square(x + 10 * gui.scale, y, toggle_dl_mon, _("Monitor download folders"))
            y += 23 * gui.scale
            self.toggle_square(x + 10 * gui.scale, y, toggle_music_ex, _("Always extract to ~/Music"))


            y += 35 * gui.scale

            self.button(x, y, "Lyrics settings...", self.toggle_lyrics_view)

            # self.toggle_square(x, y, toggle_auto_lyrics, _("Auto search lyrics"))
            # y += 23 * gui.scale
            # self.toggle_square(x, y, toggle_guitar_chords, _("Enable chord lyrics"))


            x = self.box_x + self.item_x_offset
            y = self.box_y - 10 * gui.scale

            y += 30 * gui.scale

            if toggle_enable_web(1):

                # link_pa = draw_linked_text((x + 280 * gui.scale, y), "http://localhost:" + str(prefs.server_port) + "/remote", colours.grey_blend_bg3(190), 12)
                # link_rect = [x + 280, y, link_pa[1], 18 * gui.scale]
                # fields.add(link_rect)

                link_pa2 = draw_linked_text((x + 280 * gui.scale, y + 2 * gui.scale), "http://localhost:" + str(prefs.server_port) + "/radio", colours.grey_blend_bg3(190), 12)
                link_rect2 = [x + 280 * gui.scale, y + 2 * gui.scale, link_pa2[1], 20 * gui.scale]
                fields.add(link_rect2)

                # if coll(link_rect):
                #     if not self.click:
                #         gui.cursor_want = 3
                #
                #     if self.click:
                #         webbrowser.open(link_pa[2], new=2, autoraise=True)

                if coll(link_rect2):
                    if not self.click:
                        gui.cursor_want = 3

                    if self.click:
                        webbrowser.open(link_pa2[2], new=2, autoraise=True)

            y += 30 * gui.scale
            x += 280 * gui.scale

            ddt.draw_text((x, y), _("Show in context menus:"), colours.grey(100), 11)
            y += 23 * gui.scale

            self.toggle_square(x, y, toggle_wiki, _("Search artist on Wikipedia"))
            y += 23 * gui.scale
            self.toggle_square(x, y, toggle_rym, _("Search artist on Sonemic"))
            y += 23 * gui.scale
            self.toggle_square(x, y, toggle_gimage, _("Search images on Google"))
            y += 23 * gui.scale
            self.toggle_square(x, y, toggle_gen, _("Search track on Genius"))
            if discord_allow:
                y += 23 * gui.scale
                self.toggle_square(x, y, toggle_show_discord, _("Show playing in Discord"))

            y = self.box_y + 220 * gui.scale


            # if key_shift_down:
            #     self.button(x + 120 * gui.scale, y - 4 * gui.scale, _("Reset config"), reset_config_file,
            #                 105 * gui.scale)
            # else:

            self.button(x + 10 * gui.scale, y - 4 * gui.scale, _("Open config file"), open_config_file, 105 * gui.scale)
            if not gui.opened_config_file:
                self.button(x + 120 * gui.scale, y - 4 * gui.scale, _("Reload config file"), reload_config_file,
                            105 * gui.scale)
            else:
                self.button(x + 120 * gui.scale, y - 4 * gui.scale, _("Reload config file"), reload_config_file,
                            105 * gui.scale, bg=[90, 50, 130, 255])

            y += 26 * gui.scale

            self.button(x + 120 * gui.scale, y - 4 * gui.scale, _("Open keymap file"), open_keymap_file,
                        105 * gui.scale)

            #y += 26 * gui.scale

            self.button(x + 10 * gui.scale, y - 4 * gui.scale, _("Open data folder"), open_data_directory, 105 * gui.scale)



            #x = self.box_x + self.item_x_offset

    def button(self, x, y, text, plug, width=0, bg=None):

        w = width
        if w == 0:
            w = ddt.get_text_w(text, 211) + 10 * gui.scale
        rect = (x, y, w, 20 * gui.scale)

        if bg is None:
            bg = colours.alpha_grey(11)

        bg_colour = alpha_blend(bg, colours.sys_background)
        real_bg = bg_colour

        ddt.rect_r(rect, bg_colour, True)
        fields.add(rect)
        if coll(rect):
            ddt.rect_r(rect, [255, 255, 255, 15], True)
            real_bg = alpha_blend([255, 255, 255, 15], bg_colour)
            ddt.draw_text((x + int(w / 2), rect[1] + 1 * gui.scale, 2), text, colours.grey_blend_bg(235), 211, bg=real_bg)
            if self.click:
                plug()
        else:
            ddt.draw_text((x + int(w / 2), rect[1] + 1 * gui.scale, 2), text, colours.grey_blend_bg(210), 211, bg=real_bg)

    def button2(self, x, y, text, width=0):
        w = width
        if w == 0:
            w = ddt.get_text_w(text, 211) + 10 * gui.scale
        rect = (x, y, w, 20 * gui.scale)


        bg_colour = alpha_blend(colours.alpha_grey(11), colours.sys_background)
        real_bg = bg_colour

        ddt.rect_r(rect, bg_colour, True)
        fields.add(rect)
        hit = False
        if coll(rect):
            ddt.rect_r(rect, [255, 255, 255, 15], True)
            real_bg = alpha_blend([255, 255, 255, 15], bg_colour)
            ddt.draw_text((x + int(w / 2), rect[1] + 1 * gui.scale, 2), text, colours.grey_blend_bg(235), 211, bg=real_bg)
            if self.click:
                hit = True
        else:
            ddt.draw_text((x + int(w / 2), rect[1] + 1 * gui.scale, 2), text, colours.grey_blend_bg(210), 211, bg=real_bg)
        return hit

    def toggle_square(self, x, y, function, text):

        x = round(x)
        y = round(y)

        space = round(3 * gui.scale)
        inner = space * 2
        outer = inner * 2

        le = ddt.draw_text((x + 20 * gui.scale, y - 3 * gui.scale), text, colours.grey_blend_bg(220), 12)

        ddt.rect_a((x, y), (outer, outer), [255, 255, 255, 13], True)
        ddt.rect_a((x, y), (outer, outer), [255, 255, 255, 16])

        if self.click and coll((x - 10 * gui.scale, y - 3 * gui.scale, le + 30 * gui.scale, 22 * gui.scale)):
            function()
        if function(1):
            ddt.rect_a((x + space, y + space), (inner, inner), colours.toggle_box_on, True)

    def last_fm_box(self):

        x = self.box_x + self.item_x_offset
        y = self.box_y + 20 * gui.scale


        if self.button2(x, y, "Last.fm"):
            self.account_view = 1
        self.toggle_square(x + 110 * gui.scale, y + 1 * gui.scale, toggle_lfm_auto, _("Enable"))
        y += 30

        if self.button2(x, y, "ListenBrainz"):
            self.account_view = 2
        self.toggle_square(x + 110 * gui.scale, y + 1 * gui.scale, toggle_lb, _("Enable"))

        y += 30

        if self.button2(x, y, "Discogs"):
            self.account_view = 3


        y += 150
        self.button(x, y, _("Import PLEX music"), plex_get_album_thread)

        x = self.box_x + self.item_x_offset + 230 * gui.scale
        y = self.box_y + 20 * gui.scale

        if self.account_view == 3:

            ddt.draw_text((x, y), 'Discogs', colours.grey_blend_bg(220), 213)

            y += 25 * gui.scale
            ddt.draw_text((x + 0 * gui.scale, y), _("Discogs can be used for sourcing artist images."),
                          colours.grey_blend_bg(90), 11)
            y += 22 * gui.scale
            ddt.draw_text((x + 0 * gui.scale, y), _("For this you will need a \"Personal Access Token\""),
                          colours.grey_blend_bg(90), 11)

            y += 14 * gui.scale
            ddt.draw_text((x + 0 * gui.scale, y), _("You can generate one with a Discogs account here:"),
                          colours.grey_blend_bg(90), 11)

            y += 20 * gui.scale
            link_pa2 = draw_linked_text((x + 0 * gui.scale, y), "https://www.discogs.com/settings/developers", colours.grey_blend_bg3(190), 12)
            link_rect2 = [x + 0 * gui.scale, y, link_pa2[1], 20 * gui.scale]
            fields.add(link_rect2)
            if coll(link_rect2):
                if not self.click:
                    gui.cursor_want = 3
                if self.click:
                    webbrowser.open(link_pa2[2], new=2, autoraise=True)

            y += 40 * gui.scale
            if self.button2(x, y, "Paste Token"):

                text = copy_from_clipboard()
                if text == "":
                    show_message("There is no text in the clipboard", "error")
                elif len(text) == 40:
                    prefs.discogs_pat = text

                    # Reset caches -------------------
                    prefs.failed_artists.clear()
                    artist_list_box.to_fetch = ""
                    for key, value in artist_list_box.thumb_cache.items():
                        if value:
                            SDL_DestroyTexture(value[0])
                    artist_list_box.thumb_cache.clear()
                    artist_list_box.to_fetch = ""

                    direc = os.path.join(cache_directory)
                    if os.path.isdir(direc):
                        for item in os.listdir(direc):
                            if "-lfm.txt" in item:
                                os.remove(os.path.join(direc, item))
                    # -----------------------------------

                else:
                    show_message("That is not a valid token", "error")
            y += 30 * gui.scale
            if self.button2(x, y, "Clear"):
                if not prefs.discogs_pat:
                    show_message("There wasn't any token saved.")
                prefs.discogs_pat = ""
                save_prefs()

            y += 30 * gui.scale
            if prefs.discogs_pat:
                ddt.draw_text((x + 0 * gui.scale, y - 0 * gui.scale), prefs.discogs_pat, colours.grey_blend_bg(180), 211)



        if self.account_view == 1:

            ddt.draw_text((x, y), 'Last.fm', colours.grey_blend_bg(220), 213)

            ddt.draw_text((x + 100 * gui.scale, y - 0 * gui.scale, 2), _("Username:") + " ", colours.grey_blend_bg(60), 212)
            ddt.draw_text((x + 165 * gui.scale, y - 0 * gui.scale, 2), prefs.last_fm_username, colours.grey_blend_bg(180), 213)

            y += 30 * gui.scale

            if prefs.last_fm_token is None:
                self.button(x, y, _("Login"), lastfm.auth1, 65 * gui.scale)
                self.button(x + 80 * gui.scale, y, _("Done"), lastfm.auth2, 65 * gui.scale)

                y += 30 * gui.scale
                ddt.draw_text((x + 2 * gui.scale, y), _("Click login to open the last.fm web"),
                              colours.grey_blend_bg(90), 11)
                y += 14 * gui.scale
                ddt.draw_text((x + 2 * gui.scale, y), _("authorisation page and follow prompt."),
                              colours.grey_blend_bg(90), 11)
                y += 14 * gui.scale
                ddt.draw_text((x + 2 * gui.scale, y), _('Then return here and click "Done".'),
                              colours.grey_blend_bg(90), 11)
            else:
                self.button(x, y, _("Forget account"), lastfm.auth3)


            x = self.box_x + self.item_x_offset + 230 * gui.scale
            y = self.box_y + 160 * gui.scale


            # y += 26 * gui.scale
            #
            # self.toggle_square(x, y, toggle_scrobble_mark, "Show scrobble marker")

            self.button(x, y, _("Get user loves"), lastfm.dl_love, width=110 * gui.scale)

            y += 26 * gui.scale
            self.button(x, y, _("Clear local loves"), self.clear_local_loves, width=110 * gui.scale)

            y = self.box_y + 160 * gui.scale
            x = self.box_x + self.item_x_offset + 365 * gui.scale

            self.button(x, y, _("Get friend loves"), self.get_friend_love, width=110 * gui.scale)
            # if lastfm.scanning_friends:
            #     ddt.draw_text((x + 120 * gui.scale, y), "scanning...",
            #               colours.grey_blend_bg(111), 11)

            y += 26 * gui.scale
            self.button(x, y, _("Clear friend loves"), lastfm.clear_friends_love, width=110 * gui.scale)


            y = self.box_y + 230 * gui.scale
            x = self.box_x + self.item_x_offset + 230 * gui.scale
            self.toggle_square(x, y, toggle_scrobble_mark, _("Show threshold marker"))

        if self.account_view == 2:

            ddt.draw_text((x, y), 'ListenBrainz', colours.grey_blend_bg(220), 213)

            y += 30 * gui.scale
            self.button(x, y, _("Paste Token"), lb.paste_key)
            self.button(x + 85 * gui.scale, y, _("Clear"), lb.clear_key)

            y += 35 * gui.scale

            if prefs.lb_token:
                line = prefs.lb_token
                ddt.draw_text((x + 0 * gui.scale, y - 0 * gui.scale), line, colours.grey_blend_bg(180), 212)

            y += 25 * gui.scale
            link_pa2 = draw_linked_text((x + 0 * gui.scale, y), "https://listenbrainz.org/profile/", colours.grey_blend_bg3(190), 12)
            link_rect2 = [x + 0 * gui.scale, y, link_pa2[1], 20 * gui.scale]
            fields.add(link_rect2)

            if coll(link_rect2):
                if not self.click:
                    gui.cursor_want = 3

                if self.click:
                    webbrowser.open(link_pa2[2], new=2, autoraise=True)

            y = self.box_y + 230 * gui.scale
            x = self.box_x + self.item_x_offset + 230 * gui.scale
            self.toggle_square(x, y, toggle_scrobble_mark, _("Show threshold marker"))


    def clear_local_loves(self):

        if not key_shift_down:
            show_message("This will mark all tracks in local database as unloved!", 'warning', "Press button again while holding shift key if you're sure you want to do that.")
            return

        for key, star in star_store.db.items():
            star = [star[0], star[1].strip("L")]
            star_store.db[key] = star

    def get_friend_love(self):

        if not lastfm.scanning_friends:
            shoot_dl = threading.Thread(target=lastfm.get_friends_love)
            shoot_dl.daemon = True
            shoot_dl.start()
        else:
            show_message("This process is already running. Wait for it to finish.")


    def codec_config(self):

        x = self.box_x + self.item_x_offset
        y = self.box_y - 5 * gui.scale

        y += 30 * gui.scale
        #self.toggle_square(x, y, toggle_transcode, "Show in context menu")
        ddt.draw_text((x, y + 13 * gui.scale), _("Output codec setting:"), colours.grey(100), 11)
        self.button(x + 370 * gui.scale, y - 4 * gui.scale, _("Open output folder"), open_encode_out)


        y += 40 * gui.scale
        self.toggle_square(x, y, switch_flac, "FLAC")
        y += 25 * gui.scale
        self.toggle_square(x, y, switch_opus, "OPUS")
        if  prefs.transcode_codec == 'opus':
            self.toggle_square(x + 250 * gui.scale, y, switch_opus_ogg, _("Save opus as .ogg extension"))
        y += 25 * gui.scale
        self.toggle_square(x, y, switch_ogg, "OGG")
        y += 25 * gui.scale

        #if not flatpak_mode:
        self.toggle_square(x, y, switch_mp3, "MP3")
            # if prefs.transcode_codec == 'mp3' and not shutil.which("lame"):
            #     ddt.draw_text((x + 90 * gui.scale, y - 3 * gui.scale), "LAME not detected!", [220, 110, 110, 255], 12)

        if prefs.transcode_codec != 'flac':
            y += 35 * gui.scale

            prefs.transcode_bitrate = self.slide_control(x, y, _("Bitrate"), "kbs", prefs.transcode_bitrate, 32, 320, 8)

            def toggle_transcode_inplace(mode=0):
                if mode == 1:
                    if prefs.transcode_inplace:
                        return True
                    else:
                        return False
                prefs.transcode_inplace ^= True
                if prefs.transcode_inplace:
                    transcode_icon.colour = [250, 20, 20, 255]
                    show_message(
                        "DANGER! This will delete the original files. You may want to have backups in case of malfunction.",
                        'warning',
                        "For safety, this setting will reset to 'off' on restart. Embedded thumbnails are not kept so you may want to extract them first.")
                else:
                    transcode_icon.colour = [239, 74, 157, 255]
            y -= 1 * gui.scale
            x += 280 * gui.scale
            if (system == 'windows' and not os.path.isfile(user_directory + '/encoder/ffmpeg.exe')) or (
                    system != 'windows' and shutil.which('ffmpeg') is None):
                ddt.draw_text((x, y), "FFMPEG not detected!", [220, 110, 110, 255], 12)

        x = self.box_x + self.item_x_offset
        y = self.box_y - 5 * gui.scale + 220 * gui.scale
        self.toggle_square(x + 252 * gui.scale, y, toggle_transcode_output, _("Save to output folder"))
        y += 25 * gui.scale
        self.toggle_square(x + 252 * gui.scale, y, toggle_transcode_inplace, _("Save and overwite files inplace"))

    def devance_theme(self):
        global theme
        global themeChange
        theme -= 1
        themeChange = True
        if theme < 0:
            theme = len(get_themes())

    def config_b(self):

        global album_mode_art_size
        global update_layout

        x = self.box_x + self.item_x_offset - 10 * gui.scale
        y = self.box_y - 5 * gui.scale

        x += 10 * gui.scale
        y += 25 * gui.scale

        ddt.draw_text((x, y), _("Gallery art size"), colours.grey(220), 11)

        x += 95 * gui.scale


        album_mode_art_size = self.slide_control(x, y, None, "px", album_mode_art_size, 100, 400, 10, img_slide_update_gall)

        # ---------------


        x = self.box_x + self.item_x_offset - 10 * gui.scale
        x += 10 * gui.scale
        y += 25 * gui.scale

        x += 110 * gui.scale

        y += 35 * gui.scale

        x = self.box_x + self.item_x_offset
        y1 = y


        ddt.draw_text((x, y - 25 * gui.scale), _("Window"), colours.grey_blend_bg(100), 12)

        self.toggle_square(x, y, toggle_auto_theme, _("Use album art for theme colours"))

        y += 25 * gui.scale

        self.toggle_square(x, y, toggle_auto_bg, _("Use album art as background"))

        y += 25 * gui.scale

        self.toggle_square(x + 10 * gui.scale, y, toggle_auto_bg_strong, _("Stronger"))
        #self.toggle_square(x + 10 * gui.scale, y, toggle_auto_bg_strong1, _("Lo"))
        #self.toggle_square(x + 54 * gui.scale, y, toggle_auto_bg_strong2, _("Md"))
        #self.toggle_square(x + 105 * gui.scale, y, toggle_auto_bg_strong3, _("Hi"))

        #self.toggle_square(x + 159 * gui.scale, y, toggle_auto_bg_blur, _("Always blur"))
        self.toggle_square(x + 90 * gui.scale, y, toggle_auto_bg_blur, _("Blur"))

        self.toggle_square(x + 145 * gui.scale, y, toggle_auto_bg_showcase, _("Showcase only"))


        y += 28 * gui.scale

        self.toggle_square(x, y, toggle_borderless, _("Draw own window decorations"))


        y += 28 * gui.scale
        if not draw_border:
            self.toggle_square(x, y, toggle_titlebar_line, _("Show playing in titlebar"))

        y += 28 * gui.scale
        # self.toggle_square(x, y, toggle_scale, "2x UI scaling (wip)")
        # if system == "linux" or True:
        #     self.toggle_square(x, y, scale1, "1x")
        y += 25 * gui.scale
        # if system == "linux" or True:
        #     self.toggle_square(x, y, scale125, locale.str(1.25) + "x")
        #y += 25 * gui.scale
        # if system == "linux":
        #     self.toggle_square(x + 70 * gui.scale, y, scale2, "2x")

        y -= 5 * gui.scale

        self.button(x + 208 * gui.scale, y + 5 * gui.scale, _("Next Theme") + " (F2)", advance_theme)
        self.button(x + 105 * gui.scale, y + 5 * gui.scale, _("Previous Theme"), self.devance_theme)
        ddt.draw_text((x + 320 * gui.scale, y + 6 * gui.scale), gui.theme_name, colours.grey_blend_bg(90), 213)


        #self.toggle_square(x, y, toggle_sbt, "Prefer track title in bottom panel")
        # ----------

        y = self.box_y - 5 * gui.scale
        x += 270 * gui.scale

        y += 25 * gui.scale


        ddt.draw_text((x, y), _("Gallery"), colours.grey_blend_bg(100), 12)

        y += 25 * gui.scale
        # self.toggle_square(x, y, toggle_dim_albums, "Dim gallery when playing")
        self.toggle_square(x, y, toggle_gallery_click, _("Single click to play"))
        y += 25 * gui.scale
        self.toggle_square(x, y, toggle_galler_text, _("Show titles in gallery"))
        # y += 25 * gui.scale
        #
        # self.toggle_square(x + 10 * gui.scale, y, toggle_card_style, _("Use card style (Light theme only)"))
        y += 26 * gui.scale
        #y += 28 * gui.scale


        ddt.draw_text((x, y), _("Misc"), colours.grey_blend_bg(100), 12)

        y += 25 * gui.scale


        if prefs.backend == 1:
            self.toggle_square(x, y, toggle_level_meter, _("Top-panel visualisation"))
            y += 25 * gui.scale
            self.toggle_square(x, y, toggle_showcase_vis, _("Showcase visualisation"))
            y += 25 * gui.scale
        if system == "windows":
            self.toggle_square(x, y, toggle_min_tray, "Minimize to tray")

        # self.toggle_square(x, y, toggle_mini_lyrics, "Show lyrics in side panel")
        # y += 28 * gui.scale
        #if desktop == 'GNOME' or desktop == 'KDE':
        if system == "linux":
            self.toggle_square(x, y, toggle_notifications, _("Emit track change notifications"))

        #y += 25 * gui.scale
        #self.toggle_square(x, y, toggle_al_pref_album_artist, _("Artist list prefers album-artist"))





    def about(self):

        x = self.box_x + int(self.w * 0.3) + 65 * gui.scale
        y = self.box_y + 95 * gui.scale

        ddt.text_background_colour = colours.sys_background

        icon_rect = (x - 110 * gui.scale, y - 15 * gui.scale, self.about_image.w, self.about_image.h)

        genre = ""
        if pctl.playing_object() is not None:
            genre = pctl.playing_object().genre.lower()

            if any(s in genre for s in ['ock', 'lt']):
                self.about_image2.render(icon_rect[0], icon_rect[1])
            elif any(s in genre for s in ['syn', 'pop']):
                self.about_image4.render(icon_rect[0], icon_rect[1])
            elif any(s in genre for s in ['tro', 'cid']):
                self.about_image4.render(icon_rect[0], icon_rect[1])
            else:
                genre = ""

        if not genre:
            self.about_image.render(icon_rect[0], icon_rect[1])


        x += 20 * gui.scale
        y -= 10 * gui.scale

        ddt.draw_text((x, y + 4 * gui.scale), t_title, colours.grey(233), 216)


        if self.click and coll(icon_rect) and self.ani_cred == 0:
            self.ani_cred = 1
            self.ani_fade_on_timer.set()

        fade = 0

        if self.ani_cred == 1:
            t = self.ani_fade_on_timer.get()
            fade = round(t / 0.7 * 255)
            if fade > 255:
                fade = 255

            if t > 0.7:
                self.ani_cred = 2
                self.cred_page ^= 1
                self.ani_fade_on_timer.set()

            gui.update = 2

        if self.ani_cred == 2:

            t = self.ani_fade_on_timer.get()
            fade = 255 - round(t / 0.7 * 255)
            if fade < 0:
                fade = 0
            if t > 0.7:
                self.ani_cred = 0

            gui.update = 2

        y += 32 * gui.scale

        block_y = y - 10 * gui.scale


        if self.cred_page == 0:

            ddt.draw_text((x, y - 6 * gui.scale), t_version, colours.grey(90), 313)
            y += 20 * gui.scale
            ddt.draw_text((x, y), "Copyright Â© 2015-2019 Taiko2k captain.gxj@gmail.com", colours.grey(195), 13)
            y += 21 * gui.scale
            link_pa = draw_linked_text((x, y), "https://github.com/Taiko2k/tauonmusicbox", colours.grey_blend_bg3(190), 12)
            link_rect = [x, y, link_pa[1], 18 * gui.scale]
            if coll(link_rect):
                if not self.click:
                    gui.cursor_want = 3
                if self.click:
                    webbrowser.open(link_pa[2], new=2, autoraise=True)

            fields.add(link_rect)

        else:

            y += 20 * gui.scale

            ddt.draw_text((x, y + 1 * gui.scale), "Created by", colours.grey(90), 13)
            ddt.draw_text((x + 120 * gui.scale, y + 1 * gui.scale), "Taiko2k", colours.grey(220), 13)

            y += 12 * gui.scale

            #ddt.draw_text((x, y + 1 * gui.scale), "Additional testing", colours.grey(90), 13)



        ddt.rect_r((x, block_y, 369 * gui.scale, 100 * gui.scale), alpha_mod(colours.sys_background, fade), True)


        x = self.box_x + self.w - 100 * gui.scale
        y = self.box_y + self.h - 35 * gui.scale

        self.button(x, y, _("Show License"), open_license)

    def stats(self):

        x = self.box_x + self.item_x_offset - 10 * gui.scale
        y = self.box_y - 10 * gui.scale

        lt_font = 312
        lt_colour = colours.grey_blend_bg(85)

        x1 = x + (8 + 10 + 10) * gui.scale
        x2 = x1 + 125 * gui.scale
        y1 = y + 40 * gui.scale

        if self.stats_pl != pctl.multi_playlist[pctl.active_playlist_viewing][6] or self.stats_pl_timer.get() > 5:
            self.stats_pl = pctl.multi_playlist[pctl.active_playlist_viewing][6]
            self.stats_pl_timer.set()

            album_names = set()
            for tr in default_playlist:
                album_names.add(pctl.g(tr).parent_folder_path)
            self.stats_pl_albums = len(album_names)

            self.stats_pl_length = 0
            for item in default_playlist:
                self.stats_pl_length += pctl.master_library[item].length

        line = str(datetime.timedelta(seconds=int(self.stats_pl_length)))

        ddt.draw_text((x1, y1), _("Tracks in playlist"), lt_colour, lt_font)
        ddt.draw_text((x2, y1), '{:,}'.format(len(default_playlist)), colours.grey_blend_bg(220), 12)
        y1 += 20 * gui.scale
        ddt.draw_text((x1, y1), _("Albums in playlist"), lt_colour, lt_font)
        ddt.draw_text((x2, y1), str(self.stats_pl_albums), colours.grey_blend_bg(220), 12)
        y1 += 20 * gui.scale
        ddt.draw_text((x1, y1), _("Playlist duration"), lt_colour, lt_font)



        ddt.draw_text((x2, y1), line, colours.grey_blend_bg(220), 12)

        if self.stats_timer.get() > 5:

            album_names = set()
            for pl in pctl.multi_playlist:
                for tr in pl[2]:
                    album_names.add(pctl.g(tr).parent_folder_path)
            self.total_albums = len(album_names)
            self.stats_timer.set()


        y1 += 40 * gui.scale
        ddt.draw_text((x1, y1), _("Tracks in database"), lt_colour, lt_font)
        ddt.draw_text((x2, y1), locale.format_string('%d', len(pctl.master_library), True), colours.grey_blend_bg(220), 12)
        y1 += 20 * gui.scale
        ddt.draw_text((x1, y1), _("Total albums"), lt_colour, lt_font)
        ddt.draw_text((x2, y1), str(self.total_albums), colours.grey_blend_bg(220), 12)

        y1 += 20 * gui.scale
        ddt.draw_text((x1, y1), _("Total playtime"), lt_colour, lt_font)
        ddt.draw_text((x2, y1), str(datetime.timedelta(seconds=int(pctl.total_playtime))),
                  colours.grey_blend_bg(220), 15)


        # Ratio bar
        if len(pctl.master_library) > 115 * gui.scale:
            x = self.box_x + 115 * gui.scale
            y = self.box_y + self.h - 7 * gui.scale

            full_rect = [x, y, self.w - 115 * gui.scale + 0, 7 * gui.scale]
            d = 0

            # Stats
            try:
                if self.last_db_size != len(pctl.master_library):
                    self.last_db_size = len(pctl.master_library)
                    self.ext_ratio = {}
                    for key, value in pctl.master_library.items():
                        if value.file_ext in self.ext_ratio:
                            self.ext_ratio[value.file_ext] += 1
                        else:
                            self.ext_ratio[value.file_ext] = 1

                for key, value in self.ext_ratio.items():

                    colour = [200, 200, 200 ,255]
                    if key in format_colours:
                        colour = format_colours[key]

                    colour = colorsys.rgb_to_hls(colour[0] / 255, colour[1] / 255, colour[2] / 255)
                    colour = colorsys.hls_to_rgb(1 - colour[0], colour[1] * 0.8, colour[2] * 0.8)
                    colour = [int(colour[0] * 255), int(colour[1] * 255), int(colour[2] * 255), 255]

                    h = int(round(value / len(pctl.master_library) * full_rect[2]))
                    block_rect = [full_rect[0] + d, full_rect[1], h, full_rect[3]]


                    ddt.rect_r(block_rect, colour, True)
                    d += h

                    block_rect = (block_rect[0], block_rect[1], block_rect[2] - 1, block_rect[3])
                    fields.add(block_rect)
                    if coll(block_rect):
                        xx = block_rect[0] + int(block_rect[2] / 2)
                        if xx < x + 30 * gui.scale:
                            xx = x + 30 * gui.scale
                        if xx > self.box_x + self.w - 30 * gui.scale:
                            xx = self.box_x + self.w - 30 * gui.scale
                        ddt.draw_text((xx, self.box_y + self.h - 35 * gui.scale, 2), key, colours.grey_blend_bg(220), 13)

                        if self.click:
                            gen_codec_pl(key)
            except:
                print("Error draw ext bar")

    def config_v(self):

        w = 370 * gui.scale
        h = 220 * gui.scale
        x = self.box_x + self.item_x_offset
        y = self.box_y

        # x += 8
        y += 25 * gui.scale
        y2 = y
        x2 = x


        space = round(3 * gui.scale)
        inner = space * 2
        outer = inner * 2

        for k in config_items:
            if k is None:
                y += 15 * gui.scale
                continue
            ddt.draw_text((x + 20 * gui.scale, y - 3 * gui.scale), k[0], colours.grey_blend_bg(220), 12)
            ddt.rect_a((x, y), (outer, outer), [255, 255, 255, 13], True)
            ddt.rect_a((x, y), (outer, outer), [255, 255, 255, 16])
            if self.click and coll((x - 20, y - 5, 220, 24)):
                k[1]()
            if k[1](1) is True:
                ddt.rect_a((x + space, y + space), (inner, inner), colours.toggle_box_on, True)

            y += 25 * gui.scale

            # if y - y2 > 190 * gui.scale:
            #     y = y2
            #     x += 205 * gui.scale


        y = self.box_y + 25 * gui.scale
        x = self.box_x + self.item_x_offset + 270 * gui.scale

        #y += 20

        prefs.playlist_font_size = self.slide_control(x, y, "Font Size", "", prefs.playlist_font_size, 12, 17)
        y += 25 * gui.scale
        prefs.playlist_row_height = self.slide_control(x, y, "Row Size", "px", prefs.playlist_row_height, 15, 45)
        y += 25 * gui.scale

        x += 65 * gui.scale
        self.button(x, y, "Thin default", self.small_preset, 124 * gui.scale)
        y += 27 * gui.scale
        self.button(x, y, "Thick default", self.large_preset, 124 * gui.scale)

        y += 90 * gui.scale
        x -= 90 * gui.scale

        ddt.draw_text((x, y), "End of playlist action", colours.grey_blend_bg(90), 12)

        y += 25 * gui.scale
        self.toggle_square(x, y, self.set_playlist_stop, "Stop playback")
        y += 25 * gui.scale
        self.toggle_square(x, y, self.set_playlist_repeat, "Repeat playlist")
        #y += 25
        y -= 25 * gui.scale
        x += 120 * gui.scale
        self.toggle_square(x, y, self.set_playlist_advance, "Play next playlist")
        y += 25 * gui.scale
        self.toggle_square(x, y, self.set_playlist_cycle, "Cycle all playlists")

    def set_playlist_cycle(self, mode=0):
        if mode == 1:
            return True if prefs.end_setting == "cycle" else False
        prefs.end_setting = 'cycle'
        # global pl_follow
        # pl_follow = False

    def set_playlist_advance(self, mode=0):
        if mode == 1:
            return True if prefs.end_setting == "advance" else False
        prefs.end_setting = 'advance'
        # global pl_follow
        # pl_follow = False

    def set_playlist_stop(self, mode=0):
        if mode == 1:
            return True if prefs.end_setting == "stop" else False
        prefs.end_setting = 'stop'

    def set_playlist_repeat(self, mode=0):
        if mode == 1:
            return True if prefs.end_setting == "repeat" else False
        prefs.end_setting = 'repeat'


    def small_preset(self):

        prefs.playlist_row_height = round(22 * prefs.ui_scale)
        prefs.playlist_font_size = 15
        gui.update_layout()

    def large_preset(self):

        prefs.playlist_row_height = round(30 * prefs.ui_scale)
        prefs.playlist_font_size = 15
        gui.update_layout()

    def slide_control(self, x, y, label, units, value, lower_limit, upper_limit, step=1, callback=None):

        if label is not None:
            ddt.draw_text((x + 55 * gui.scale, y, 1), label, colours.grey_blend_bg(220), 11)
            x += 65 * gui.scale
        y += 1 * gui.scale
        rect = (x, y, 33 * gui.scale, 15 * gui.scale)
        fields.add(rect)
        ddt.rect_r(rect, [255, 255, 255, 20], True)
        abg = colours.grey(80)
        if coll(rect):

            if self.click:
                if value > lower_limit:
                    value -= step
                    gui.update_layout()
                    if callback is not None:
                        callback(value)

            if mouse_down:
                abg = [230, 120, 20, 255]
            else:
                abg = [220, 150, 20, 255]

        dec_arrow.render(x + 1 * gui.scale, y, abg)

        x += 33 * gui.scale

        ddt.rect_r((x, y, 58 * gui.scale, 15 * gui.scale), [255, 255, 255, 9], True)
        ddt.draw_text((x + 29 * gui.scale, y, 2), str(value) + units, colours.grey(220), 11)

        x += 58 * gui.scale

        rect = (x, y, 33 * gui.scale, 15 * gui.scale)
        fields.add(rect)
        ddt.rect_r(rect, [255, 255, 255, 20], True)
        abg = colours.grey(80)
        if coll(rect):

            if self.click:
                if value < upper_limit:
                    value += step
                    gui.update_layout()
                    if callback is not None:
                        callback(value)
            if mouse_down:
                abg = [230, 120, 20, 255]
            else:
                abg = [220, 150, 20, 255]

        inc_arrow.render(x + 1 * gui.scale, y, abg)

        return value

    # def style_up(self):
    #     prefs.line_style += 1
    #     if prefs.line_style > 5:
    #         prefs.line_style = 1

    def inside(self):

        return coll((self.box_x, self.box_y, self.w, self.h))

    def init2(self):

        self.init2done = True

        pctl.total_playtime = star_store.get_total()

    def render(self):

        if self.init2done is False:
            self.init2()

        if key_esc_press:
            self.enabled = False
            fader.fall()

        tab_width = 115 * gui.scale

        self.box_x = int(window_size[0] / 2) - int(self.w / 2)
        self.box_y = int(window_size[1] / 2) - int(self.h / 2)

        ddt.rect_a((self.box_x - 5 * gui.scale, self.box_y - 5 * gui.scale), (self.w + 10 * gui.scale, self.h + 10 * gui.scale), colours.grey(50), True)
        ddt.rect_a((self.box_x, self.box_y), (self.w, self.h), colours.sys_background, True)
        ddt.rect_a((self.box_x, self.box_y), (tab_width, self.h), colours.sys_background_2, True)



        # ddt.rect_a((self.box_x - 1, self.box_y - 1), (self.w + 2, self.h + 2), colours.grey(50))

        # # temp
        # if len(self.drives) < 1 and system == 'windows':
        #     raw_drives = win32api.GetLogicalDriveStrings()
        #     self.drives = raw_drives.split('\000')[:-1]

        current_tab = 0
        for item in self.tabs:

            if self.click and gui.message_box:
                gui.message_box = False

            box = [self.box_x, self.box_y + (current_tab * 30 * gui.scale), tab_width, 30 * gui.scale]
            box2 = [self.box_x, self.box_y + (current_tab * 30 * gui.scale), tab_width, 29 * gui.scale]
            fields.add(box2)
            # ddt.rect_r(box, colours.tab_background, True)

            if self.click and coll(box2):
                self.tab_active = current_tab
                self.lyrics_panel = False

            if current_tab == self.tab_active:
                colour = copy.deepcopy(colours.sys_tab_hl)
                #colour[3] = 190
                ddt.text_background_colour = colour
                ddt.rect_r(box, colour, True)
            else:
                ddt.text_background_colour = colours.sys_tab_bg
                ddt.rect_r(box, colours.sys_tab_bg, True)

            if coll(box2):
                ddt.rect_r(box, [255, 255, 255, 10], True)

            # ddt.draw_text((box[0] + 55, box[1] + 7, 2), item[0], [200, 200, 200, 200], 12)
            if current_tab == self.tab_active:
                ddt.draw_text((box[0] + (tab_width // 2), box[1] + 7 * gui.scale, 2), item[0], alpha_blend([240, 240, 240, 240], ddt.text_background_colour), 213)
            else:
                ddt.draw_text((box[0] + (tab_width // 2), box[1] + 7 * gui.scale, 2), item[0], alpha_blend([240, 240, 240, 100], ddt.text_background_colour), 213)

            current_tab += 1

        # ddt.line(self.box_x + 110, self.box_y + 1, self.box_x + 110, self.box_y + self.h, colours.grey(50))

        self.tabs[self.tab_active][1]()

        self.click = False
        self.right_click = False

        ddt.text_background_colour = colours.sys_background




class Fields:
    def __init__(self):

        self.id = []
        self.last_id = []

        self.field_array = []
        self.force = False

    def add(self, rect, callback=None):

        self.field_array.append((rect, callback))

    def test(self):

        if self.force:
            self.force = False
            return True

        self.last_id = self.id
        # print(len(self.id))
        self.id = []

        for f in self.field_array:
            if coll(f[0]):
                self.id.append(1)  # += "1"
                if f[1] is not None:  # Call callback if present
                    f[1]()
            else:
                self.id.append(0)  # += "0"

        if self.last_id == self.id:
            return False

        else:
            return True

    def clear(self):

        self.field_array = []


fields = Fields()

def update_playlist_call():
    gui.update + 2
    gui.pl_update = 2


pref_box = Over()

inc_arrow = asset_loader("inc.png", True)
dec_arrow = asset_loader("dec.png", True)
corner_icon = asset_loader("corner.png", True)

# ----------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------

class TopPanel:
    def __init__(self):

        self.height = gui.panelY
        self.ty = 0

        self.start_space_left = round(46 * gui.scale)
        self.start_space_compact_left = 46 * gui.scale

        self.tab_text_font = fonts.tabs
        self.tab_extra_width = round(17 * gui.scale)
        self.tab_text_start_space = 8 * gui.scale
        self.tab_text_y_offset = 7 * gui.scale
        self.tab_spacing = 0

        self.ini_menu_space = 17 * gui.scale  # 17
        self.menu_space = 17 * gui.scale
        self.click_buffer = 4 * gui.scale

        # ---
        self.space_left = 0
        self.tab_text_spaces = []
        self.index_playing = -1
        self.drag_zone_start_x = 300 * gui.scale

        self.exit_button = asset_loader('ex.png', True)
        self.restore_button = asset_loader('restore.png', True)
        self.playlist_icon = asset_loader('playlist.png', True)
        self.artist_list_icon = asset_loader('artist-list.png', True)
        self.dl_button = asset_loader('dl.png', True)

        self.adds = []

    def render(self):

        # C-TD
        global quick_drag
        global update_layout


        if quick_drag is True:
            gui.pl_update = 1

        # Draw the background
        ddt.rect_r((0, 0, window_size[0], self.height + self.ty), colours.top_panel_background, True)

        rect = (9 * gui.scale, 4 * gui.scale, 34 * gui.scale, 25 * gui.scale)
        fields.add(rect)

        if coll(rect):
            if input.mouse_click:
                gui.lsp ^= True

                update_layout = True
                gui.update += 1
            if mouse_down and quick_drag:
                gui.lsp = True
                update_layout = True
                gui.update += 1

            if right_click:
                prefs.artist_list ^= True

        colour = colours.corner_button #[230, 230, 230, 255]

        if gui.lsp:
            colour = colours.corner_button_active

        if prefs.artist_list:
            self.artist_list_icon.render(13 * gui.scale, 8 * gui.scale, colour)
        else:
            self.playlist_icon.render(13 * gui.scale, 8 * gui.scale, colour)

        if playlist_box.drag:
            drag_mode = False

        # Need to test length
        self.tab_text_spaces = []

        for i, item in enumerate(pctl.multi_playlist):
            le = ddt.get_text_w(pctl.multi_playlist[i][0], self.tab_text_font)
            self.tab_text_spaces.append(le)

        x = self.start_space_left
        y = self.ty


        # Calculate position for playing text and text
        offset = 15 * gui.scale
        if draw_border:
            offset += 61 * gui.scale
        if gui.turbo:
            offset += 90 * gui.scale
            if gui.vis == 3:
                offset += 57 * gui.scale


        if pctl.broadcast_active:

            p_text_len = ddt.get_text_w(pctl.master_library[pctl.broadcast_index].artist + " - " + pctl.master_library[
                pctl.broadcast_index].title, 11)

            p_text_len += ddt.get_text_w("Now Streaming:", 11)
            p_text_len += 20 * gui.scale
            p_text_len += 180 * gui.scale

        elif gui.show_top_title:

            p_text = trunc_line(pctl.title_text(), 12, window_size[0] - offset - 120 * gui.scale)
            p_text_len = ddt.get_text_w(p_text, 12) + 70 * gui.scale

        else:
            p_text_len = 180 * gui.scale

        right_space_es = p_text_len + offset

        x_start = x

        if mouse_up and playlist_box.drag:

            if mouse_position[0] > (gui.lspw if gui.lsp else 0) and mouse_position[1] > gui.panelY:
                playlist_box.drag = False

                if playlist_box.drag_source == 0:
                    pctl.multi_playlist[playlist_box.drag_on][8] = True
                else:
                    pctl.multi_playlist[playlist_box.drag_on][8] = False


        # TAB INPUT PROCESSING
        for i, tab in enumerate(pctl.multi_playlist):

            if not prefs.tabs_on_top:
                break

            if len(pctl.multi_playlist) != len(self.tab_text_spaces):
                break

            # Truncate early if we run out of room
            # (maybe not the best solution, but im not sure if a scroll bar would be either)
            if window_size[0] - x - (self.tab_text_spaces[i] + self.tab_extra_width) < right_space_es:
                break

            # Skip if hide flag is set
            if tab[8] is True:
                continue

            # Determine the tab width
            tab_width = self.tab_text_spaces[i] + self.tab_extra_width

            # Detect mouse over and add tab to mouse over detection
            f_rect = [x, y + 1, tab_width - 1, self.height - 1]
            tab_hit = coll(f_rect)

            # Tab functions
            if tab_hit:

                # Click to change playlist
                if input.mouse_click:
                    gui.pl_update = 1
                    playlist_box.drag = True
                    playlist_box.drag_source = 0
                    playlist_box.drag_on = i
                    switch_playlist(i)
                    gui.drag_source_position = copy.deepcopy(mouse_position)

                # Drag to move playlist
                if mouse_up and playlist_box.drag:

                    if playlist_box.drag_source == 1:
                        pctl.multi_playlist[playlist_box.drag_on][8] = False

                    if i != playlist_box.drag_on:

                        # # Reveal the tab in case it has been hidden
                        # pctl.multi_playlist[playlist_box.drag_on][8] = False

                        if key_shift_down:
                            pctl.multi_playlist[i][2] += pctl.multi_playlist[playlist_box.drag_on][2]
                            delete_playlist(playlist_box.drag_on)
                        else:
                            move_playlist(playlist_box.drag_on, i)

                    playlist_box.drag = False
                    gui.update += 1

                # Delete playlist on wheel click
                elif tab_menu.active is False and middle_click:
                    delete_playlist(i)
                    break

                # Activate menu on right click
                elif right_click:
                    tab_menu.activate(copy.deepcopy(i))
                    gui.tab_menu_pl = i

                # Quick drop tracks
                elif quick_drag is True:
                    if mouse_up:
                        quick_drag = False
                        modified = False
                        gui.pl_update += 1
                        for item in shift_selection:
                            pctl.multi_playlist[i][2].append(default_playlist[item])
                            modified = True
                        if len(shift_selection) > 0:
                            modified = True
                            self.adds.append([pctl.multi_playlist[i][6], len(shift_selection), Timer()]) # ID, num, timer
                        if modified:
                            tauon.worker_save_state = True
                            pctl.update_shuffle_pool(pctl.multi_playlist[i][6], shift_selection)

            x += tab_width + self.tab_spacing

        # Test dupelicate tab function
        if playlist_box.drag:
            rect = (0, x, self.height, window_size[0])
            fields.add(rect)

        if mouse_up and playlist_box.drag and mouse_position[0] > x and mouse_position[1] < self.height:
            #gen_dupe(playlist_box.drag_on)

            if playlist_box.drag_source == 1:
                pctl.multi_playlist[playlist_box.drag_on][8] = False

            move_playlist(playlist_box.drag_on, i)
            playlist_box.drag = False

        # Need to test length again
        self.tab_text_spaces = []

        for i, item in enumerate(pctl.multi_playlist):
            le = ddt.get_text_w(pctl.multi_playlist[i][0], self.tab_text_font)
            self.tab_text_spaces.append(le)

        # Reset X draw position
        x = x_start


        # TAB DRAWING
        for i, tab in enumerate(pctl.multi_playlist):

            if not prefs.tabs_on_top:
                break

            if len(pctl.multi_playlist) != len(self.tab_text_spaces):
                break

            if window_size[0] - x - (self.tab_text_spaces[i] + self.tab_extra_width) < right_space_es:
                break

            # if draw_alt and i != pctl.playlist_active:
            #     continue

            if tab[8] is True:
                continue

            tab_width = self.tab_text_spaces[i] + self.tab_extra_width
            rect = [x, y, tab_width, self.height]

            # Detect mouse over and add tab to mouse over detection
            f_rect = [x, y + 1, tab_width - 1, self.height - 1]
            fields.add(f_rect)
            tab_hit = coll(f_rect)
            playing_hint = False
            active = False

            # Determine tab background colour
            if i == pctl.active_playlist_viewing:
                bg = colours.tab_background_active
                active = True
            elif (tab_menu.active is True and tab_menu.reference == i) or tab_menu.active is False and tab_hit and not playlist_box.drag:
                bg = colours.tab_highlight
            elif i == pctl.active_playlist_playing:
                bg = colours.tab_background
                playing_hint = True
            else:
                bg = colours.tab_background

            # Draw tab background
            ddt.rect_r(rect, bg, True)
            if playing_hint:
                ddt.rect_r(rect, [255, 255, 255, 7], True)


            # Determine text colour
            if active:
                fg = colours.tab_text_active
            else:
                fg = colours.tab_text

            # Draw tab text
            ddt.draw_text((x + self.tab_text_start_space, y + self.tab_text_y_offset), tab[0], fg, self.tab_text_font, bg=bg)

            # Drop pulse
            if gui.pl_pulse and playlist_target == i:
                    if tab_pulse.render(x, y + self.height - 2, tab_width, 2, r=200, g=130) is False:
                        gui.pl_pulse = False

            # Drag to move playlist
            if tab_hit:
                if mouse_down and i != playlist_box.drag_on and playlist_box.drag is True:

                    if key_shift_down:
                        ddt.rect_r((x, y + self.height - 2, tab_width, 2), [80, 160, 200, 255], True)
                    else:
                        if playlist_box.drag_on < i:
                            ddt.rect_r((x + tab_width - 2, y, 2, gui.panelY), [80, 160, 200, 255], True)
                        else:
                            ddt.rect_r((x, y, 2, gui.panelY), [80, 160, 200, 255], True)

                elif quick_drag is True:
                    ddt.rect_r((x, y + self.height - 2, tab_width, 2), [80, 200, 180, 255], True)

            if len(self.adds) > 0:
                for k in reversed(range(len(self.adds))):
                    if pctl.multi_playlist[i][6] == self.adds[k][0]:
                        if self.adds[k][2].get() > 0.3:
                            del self.adds[k]
                        else:
                            ay = y + 4
                            ay -= 6 * self.adds[k][2].get() / 0.3

                            ddt.draw_text((x + tab_width - 3, int(round(ay)), 1), '+' + str(self.adds[k][1]), colours.pluse_colour, 212, bg=bg)
                            gui.update += 1


            x += tab_width + self.tab_spacing

        # Quick drag single track onto bar to create new playlist function and indicator
        if prefs.tabs_on_top:
            if quick_drag and mouse_position[0] > x and mouse_position[1] < gui.panelY and quick_d_timer.get() > 1:
                ddt.rect_r((x, y, 2 * gui.scale, gui.panelY), [80, 200, 180, 255], True)

                if mouse_up:
                    drop_tracks_to_new_playlist(shift_selection)


            # Draw end drag tab indicator
            if playlist_box.drag and mouse_position[0] > x and mouse_position[1] < gui.panelY:
                ddt.rect_r((x, y, 2 * gui.scale, gui.panelY), [80, 160, 200, 255], True)

        # -------------
        # Other input
        if mouse_up:
            quick_drag = False
            playlist_box.drag = False

        # Scroll anywhere on panel to cycle playlist
        # (This is a bit complicated because we need to skip over hidden playlists)
        if mouse_wheel != 0 and mouse_position[1] < self.height + 1 and len(pctl.multi_playlist) > 1:

            if mouse_wheel > 0:
                p = pctl.active_playlist_viewing
                le = len(pctl.multi_playlist)
                on = p
                on -= 1
                while True:
                    if on < 0:
                        on = le - 1
                    if on == p:
                        break
                    if pctl.multi_playlist[on][8] is False or not prefs.tabs_on_top:
                        switch_playlist(on)
                        break
                    on -= 1
            if mouse_wheel < 0:
                p = pctl.active_playlist_viewing
                le = len(pctl.multi_playlist)
                on = p
                on += 1
                while True:
                    if on == le:
                        on = 0
                    if on == p:
                        break
                    if pctl.multi_playlist[on][8] is False or not prefs.tabs_on_top:
                        switch_playlist(on)
                        break
                    on += 1

            gui.pl_update = 1

        # ---------
        # Menu Bar

        x += self.ini_menu_space
        y += 7 * gui.scale
        ddt.text_background_colour = colours.top_panel_background

        # MENU -----------------------------

        word = "MENU"
        word_length = ddt.get_text_w(word, 212)
        rect = [x - self.click_buffer, self.ty + 1, word_length + self.click_buffer * 2, self.height - 1]
        hit = coll(rect)
        fields.add(rect)

        if (x_menu.active or hit) and not tab_menu.active:
            bg = colours.status_text_over
        else:
            bg = colours.status_text_normal
        ddt.draw_text((x, y), word, bg, 212)

        if hit and input.mouse_click:
            if x_menu.active:
                x_menu.active = False
            else:

                x_menu.activate(position=(x + 12, self.height))
                view_box.activate(x)

        view_box.render()


        dl = len(dl_mon.ready)
        watching = len(dl_mon.watching)

        if (dl > 0 or watching > 0) and core_timer.get() > 2 and prefs.auto_extract and prefs.monitor_downloads:
            x += 52 * gui.scale
            rect = (x - 5 * gui.scale, y - 2 * gui.scale, 30 * gui.scale, 23 * gui.scale)
            fields.add(rect)

            if coll(rect):
                colour = [230, 230, 230, 255]
                if colours.lm:
                    colour = [40, 40, 40, 255]
                if dl > 0 or watching > 0:
                    if right_click:
                        dl_menu.activate(position=(mouse_position[0], gui.panelY))
                if dl > 0:
                    if input.mouse_click:
                        pln = 0
                        for item in dl_mon.ready:
                            load_order = LoadClass()
                            load_order.target = item
                            pln = pctl.active_playlist_viewing
                            load_order.playlist = pctl.multi_playlist[pln][6]
                            for i, pl in enumerate(pctl.multi_playlist):
                                if pl[0].lower() == "downloads":
                                    load_order.playlist = pl[6]
                                    pln = i
                                    break

                            load_orders.append(copy.deepcopy(load_order))
                        if len(dl_mon.ready) > 0:
                            dl_mon.ready.clear()
                            switch_playlist(pln)

                            pctl.playlist_view_position = len(default_playlist)
                            gui.update += 1
                else:
                    colour = [60, 60, 60, 255]
                    if colours.lm:
                        colour = [180, 180, 180, 255]
                    if input.mouse_click:
                        input.mouse_click = False
                        show_message("It looks like something is being downloaded...", 'info', "Let's check back later...")


            else:
                colour = [60, 60, 60, 255]
                if colours.lm:
                    colour = [180, 180, 180, 255]
                    if dl_mon.ready:
                        colour = [60, 60, 60, 255]

            self.dl_button.render(x, y + 1 * gui.scale, colour)
            if dl > 0:
                ddt.draw_text((x + 18 * gui.scale, y - 4 * gui.scale), str(dl), colours.pluse_colour, 209) #[244, 223, 66, 255]
                # [166, 244, 179, 255]




        # LAYOUT --------------------------------
        x += self.menu_space + word_length

        self.drag_zone_start_x = x - 11 * gui.scale
        status = True

        if loading_in_progress:

            bg = colours.status_info_text
            if to_got == 'xspf':
                text = "Importing XSPF playlist"
            elif to_got == 'xspfl':
                text = "Importing XSPF playlist..."
            elif to_got == 'ex':
                text = "Extracting Archive..."
            else:
                text = "Importing...  " + str(to_got) + "/" + str(to_get)
                if right_click and coll([x, y, 180 * gui.scale, 18 * gui.scale]):
                    cancel_menu.activate(position=(x + 20 * gui.scale, y + 23 * gui.scale))
        elif move_in_progress:
            text = "File copy in progress..."
            bg = colours.status_info_text
        elif cm_clean_db and to_get > 0:
            per = str(int(to_got / to_get * 100))
            text = "Cleaning db...  " + per + "%"
            bg = [100, 200, 100, 255]
        elif to_scan:
            text = "Rescanning Tags...  " + str(len(to_scan)) + " Tracks Remaining"
            bg = [100, 200, 100, 255]
        elif plex.scanning:
            text = "Accessing PLEX library..."
            bg = [229, 160, 13, 255]
        # elif transcode_list:
        #     # if key_ctrl_down and key_c_press:
        #     #     del transcode_list[1:]
        #     #     gui.tc_cancel = True
        #     if right_click and coll([x, y, 180 * gui.scale, 18 * gui.scale]):
        #         cancel_menu.activate(position=(x + 20 * gui.scale, y + 23 * gui.scale))
        #
        #     text = "Transcoding... " + str(len(transcode_list)) + " Folder Remaining " + transcode_state
        #     if len(transcode_list) > 1:
        #         text = "Transcoding... " + str(len(transcode_list)) + " Folders Remaining " + transcode_state
        #     if not gui.tc_cancel:
        #         bg = colours.status_info_text
        #     else:
        #         text = "Stopping transcode..."
        # elif pctl.join_broadcast and pctl.broadcast_active:
        #     text = "Streaming Synced"
        #     bg = [60, 75, 220, 255]  # colours.streaming_text
        elif transcode_list and gui.tc_cancel:
            bg = [150, 150, 150, 255]
            text = "Stopping transcode..."
        elif pctl.encoder_pause == 1 and pctl.broadcast_active:
            text = "Streaming Paused"
            bg = colours.streaming_text
        elif lastfm.scanning_friends:
            text = "Scanning: " + lastfm.scanning_username
            bg = [200, 150, 240, 255]
        else:
            status = False


        if status:
            x += ddt.draw_text((x, y), text, bg, 311)
            # x += ddt.get_text_w(text, 11)

        elif transcode_list:
            bg = colours.status_info_text
            # if key_ctrl_down and key_c_press:
            #     del transcode_list[1:]
            #     gui.tc_cancel = True
            if right_click and coll([x, y, 280 * gui.scale, 18 * gui.scale]):
                cancel_menu.activate(position=(x + 20 * gui.scale, y + 23 * gui.scale))


            w = 100 * gui.scale
            x += ddt.draw_text((x, y), "Transcoding", bg, 311) + 8 * gui.scale


            if gui.transcoding_batch_total:

                # c1 = [40, 40, 40, 255]
                # c2 = [60, 60, 60, 255]
                # c3 = [130, 130, 130, 255]
                #
                # if colours.lm:
                #     c1 = [100, 100, 100, 255]
                #     c2 = [130, 130, 130, 255]
                #     c3 = [180, 180, 180, 255]

                c1 = [40, 40, 40, 255]
                c2 = [100, 59, 200, 200]
                c3 = [150, 70, 200, 255]

                if colours.lm:
                    c1 = [100, 100, 100, 255]
                    c2 = [170, 140, 255, 255]
                    c3 = [230, 170, 255, 255]

                yy = y + 4 * gui.scale
                h = 9 * gui.scale
                box = [x, yy, w, h]
                #ddt.rect_r(box, [100, 100, 100, 255])
                ddt.rect_r(box, c1, True)

                done = round(gui.transcoding_bach_done / gui.transcoding_batch_total * 100)
                doing = round(core_use / gui.transcoding_batch_total * 100)

                ddt.rect_r([x, yy, done, h], c3, True)
                ddt.rect_r([x + done, yy, doing, h], c2, True)

            x += w + 8 * gui.scale


            text = str(len(transcode_list)) + " Folder Remaining " + transcode_state
            if len(transcode_list) > 1:
                text = str(len(transcode_list)) + " Folders Remaining " + transcode_state

            x += ddt.draw_text((x, y), text, bg, 311) + 8 * gui.scale



        elif pctl.broadcast_active:
            text = "Now Streaming:"
            ddt.draw_text((x, y), text, [95, 110, 230, 255], 311) # [70, 85, 230, 255]
            x += ddt.get_text_w(text, 11) + 6 * gui.scale

            text = pctl.master_library[pctl.broadcast_index].artist + " - " + pctl.master_library[
                pctl.broadcast_index].title
            trunc = window_size[0] - x - 150 * gui.scale
            #text = trunc_line(text, 11, trunc)
            ddt.draw_text((x, y), text, colours.grey(130), 311, max_w=trunc)
            x += ddt.get_text_w(text, 11) + 6* gui.scale

            x += 7
            progress = int(pctl.broadcast_time / int(pctl.master_library[pctl.broadcast_index].length) * 100 * gui.scale)
            ddt.rect_a((x, y + 4), (progress, 9 * gui.scale), [65, 80, 220, 255], True)
            ddt.rect_a((x, y + 4), (100 * gui.scale, 9 * gui.scale), colours.grey(30))

            if input.mouse_click and coll((x, y, 100 * gui.scale, 11)):
                newtime = ((mouse_position[0] - x) / (100 * gui.scale)) * pctl.master_library[pctl.broadcast_index].length
                pctl.broadcast_time = newtime
                pctl.playerCommand = 'encseek'
                pctl.playerCommandReady = True


            x += 110
            ddt.draw_text((x, y), str(len(pctl.broadcast_clients)), [70, 85, 230, 255], 11)

            self.drag_zone_start_x = x + 21 * gui.scale

            if input.mouse_click and coll((x-5, y-5, 20, 24)):
                line = ""
                input.mouse_click = False
                for client in pctl.broadcast_clients:
                    line += client.split(":")[0] + "  "

                if len(pctl.broadcast_clients) == 0:
                    show_message("There are currently no connected clients")
                elif len(pctl.broadcast_clients) == 1:
                    show_message("There is " + str(len(pctl.broadcast_clients)) + " inbound connection.", 'info',
                                 line)
                else:
                    show_message("There are " + str(len(pctl.broadcast_clients)) + " inbound connections.", 'info', line)



        if pctl.playing_state > 0 and not pctl.broadcast_active and gui.show_top_title:
            ddt.draw_text((window_size[0] - offset, y, 1), p_text, colours.side_bar_line1, 12)

        if colours.lm:
            colours.tb_line = colours.grey(200)
            ddt.rect_r((0, int(gui.panelY - 1 * gui.scale), window_size[0], int(1 * gui.scale)), colours.tb_line, True)

top_panel = TopPanel()


class BottomBarType1:
    def __init__(self):

        self.mode = 0

        self.seek_time = 0

        self.seek_down = False
        self.seek_hit = False
        self.volume_hit = False
        self.volume_bar_being_dragged = False
        self.control_line_bottom = 35 * gui.scale
        self.repeat_click_off = False
        self.random_click_off = False

        self.seek_bar_position = [300 * gui.scale, window_size[1] - gui.panelBY]
        self.seek_bar_size = [window_size[0] - (300 * gui.scale), 15 * gui.scale]
        self.volume_bar_size = [135 * gui.scale, 14 * gui.scale]
        self.volume_bar_position = [0, 45 * gui.scale]

        self.play_button = asset_loader('play.png', True)
        self.forward_button = asset_loader('ff.png', True)
        self.back_button = asset_loader('bb.png', True)

        self.scrob_stick = 0


    def update(self):

        if self.mode == 0:
            self.volume_bar_position[0] = window_size[0] - (210 * gui.scale)
            self.volume_bar_position[1] = window_size[1] - (27 * gui.scale)
            self.seek_bar_position[1] = window_size[1] - gui.panelBY
            self.seek_bar_size[0] = window_size[0] - (300 * gui.scale)
            self.seek_bar_position[0] = 300 * gui.scale
            if gui.bb_show_art:
                self.seek_bar_position[0] = 300 + gui.panelBY
                self.seek_bar_size[0] = window_size[0] - 300 - gui.panelBY

    def render(self):

        global volume_store
        global clicked
        global right_click

        ddt.rect_a((0, window_size[1] - gui.panelBY), (window_size[0], gui.panelBY), colours.bottom_panel_colour, True)

        ddt.rect_a(self.seek_bar_position, self.seek_bar_size, colours.seek_bar_background, True)


        right_offset = 0
        if gui.display_time_mode >= 2:
            right_offset = 22 * gui.scale

        # if gui.light_mode:
        #     ddt.line(0, window_size[1] - gui.panelBY, window_size[0], window_size[1] - gui.panelBY, colours.art_box)

        #FRAME
        # if gui.draw_frame:
        #     ddt.line(0, window_size[1] - gui.panelBY, 299, window_size[1] - gui.panelBY, colours.bb_line)
        #     ddt.line(299, window_size[1] - gui.panelBY, 299, window_size[1] - gui.panelBY + self.seek_bar_size[1],
        #               colours.bb_line)
        #     ddt.line(300, window_size[1] - gui.panelBY + self.seek_bar_size[1], window_size[0],
        #               window_size[1] - gui.panelBY + self.seek_bar_size[1], colours.bb_line)

        # rect = [0, window_size[1] - gui.panelBY, self.seek_bar_position[0], gui.panelBY]
        # ddt.rect_r(rect, [255, 255, 255, 5], True)

        # Scrobble marker

        if prefs.scrobble_mark and ((lastfm.hold is False and prefs.auto_lfm) or lb.enable) and pctl.playing_length > 0 and 3 > pctl.playing_state > 0:
            if pctl.master_library[pctl.track_queue[pctl.queue_step]].length > 240 * 2:
                l_target = 240
            else:
                l_target = int(pctl.master_library[pctl.track_queue[pctl.queue_step]].length * 0.50)
            l_lead = l_target - pctl.a_time

            if l_lead > 0 and pctl.master_library[pctl.track_queue[pctl.queue_step]].length > 30:
                l_x = self.seek_bar_position[0] + int(math.ceil(
                    pctl.playing_time * self.seek_bar_size[0] / int(pctl.playing_length)))
                l_x += int(math.ceil(self.seek_bar_size[0] / int(pctl.playing_length) * l_lead))

                if abs(self.scrob_stick - l_x) < 2:
                    l_x = self.scrob_stick
                else:
                    self.scrob_stick = l_x
                ddt.rect_r((self.scrob_stick, self.seek_bar_position[1], 2 * gui.scale, self.seek_bar_size[1]), [240, 10, 10, 80], True)


        # # MINI ALBUM ART
        # if gui.bb_show_art:
        #     rect = [self.seek_bar_position[0] - gui.panelBY, self.seek_bar_position[1], gui.panelBY, gui.panelBY]
        #     ddt.rect_r(rect, [255, 255, 255, 8], True)
        #     if 3 > pctl.playing_state > 0:
        #         album_art_gen.display(pctl.track_queue[pctl.queue_step], (rect[0], rect[1]), (rect[2], rect[3]))

            #ddt.rect_r(rect, [255, 255, 255, 20])

        # SEEK BAR------------------
        if pctl.playing_time < 1:
            self.seek_time = 0

        if input.mouse_click and coll_point(mouse_position,
                                      self.seek_bar_position + [self.seek_bar_size[0]] + [self.seek_bar_size[1] + 2]):
            self.seek_down = True
            self.volume_hit = True
        if right_click and coll_point(mouse_position,
                                      self.seek_bar_position + [self.seek_bar_size[0]] + [self.seek_bar_size[1] + 2]):
            pctl.pause()
            if pctl.playing_state == 0:
                pctl.play()

        fields.add(self.seek_bar_position + self.seek_bar_size)
        if coll(self.seek_bar_position + self.seek_bar_size):

            if middle_click and pctl.playing_state > 0:
                gui.seek_cur_show = True


            clicked = True
            if mouse_wheel != 0:
                pctl.seek_time(pctl.playing_time + (mouse_wheel * 3))

        if gui.seek_cur_show:
            gui.update += 1

            # fields.add([mouse_position[0] - 1, mouse_position[1] - 1, 1, 1])
            # ddt.rect_r([mouse_position[0] - 1, mouse_position[1] - 1, 1, 1], [255,0,0,180], True)

            bargetX = mouse_position[0]
            if bargetX > self.seek_bar_position[0] + self.seek_bar_size[0]:
                bargetX = self.seek_bar_position[0] + self.seek_bar_size[0]
            if bargetX < self.seek_bar_position[0]:
                bargetX = self.seek_bar_position[0]
            bargetX -= self.seek_bar_position[0]
            seek = bargetX / self.seek_bar_size[0]
            gui.cur_time = get_display_time(pctl.playing_object().length * seek)

        if self.seek_down is True:
            if mouse_position[0] == 0:
                self.seek_down = False
                self.seek_hit = True


        if (mouse_up and coll(self.seek_bar_position + self.seek_bar_size)
            and coll_point(click_location,
                           self.seek_bar_position + self.seek_bar_size)) or mouse_up and self.volume_hit or self.seek_hit:

            self.volume_hit = False
            self.seek_down = False
            self.seek_hit = False

            bargetX = mouse_position[0]
            if bargetX > self.seek_bar_position[0] + self.seek_bar_size[0]:
                bargetX = self.seek_bar_position[0] + self.seek_bar_size[0]
            if bargetX < self.seek_bar_position[0]:
                bargetX = self.seek_bar_position[0]
            bargetX -= self.seek_bar_position[0]
            seek = bargetX / self.seek_bar_size[0]

            pctl.seek_decimal(seek)
            # print(seek)

            self.seek_time = pctl.playing_time

        if pctl.playing_length > 0:
            gui.seek_bar_rect = (self.seek_bar_position[0], self.seek_bar_position[1],
                                  int(self.seek_time * self.seek_bar_size[0] / pctl.playing_length),
                       self.seek_bar_size[1])
            ddt.rect_r(gui.seek_bar_rect,
                      colours.seek_bar_fill, True)

        if gui.seek_cur_show:

            if coll([self.seek_bar_position[0] - 50, self.seek_bar_position[1] - 50, self.seek_bar_size[0] + 50, self.seek_bar_size[1] + 100]):
                if mouse_position[0] > self.seek_bar_position[0] - 1:
                    cur = [mouse_position[0] - 40, self.seek_bar_position[1] - 25, 42, 19]
                    ddt.rect_r(cur, colours.grey(15), True)
                    # ddt.rect_r(cur, colours.grey(80))
                    ddt.draw_text((mouse_position[0] - 40 + 3, self.seek_bar_position[1] - 24), gui.cur_time, colours.grey(180), 213,
                              bg=colours.grey(15))

                    ddt.rect_r([mouse_position[0], self.seek_bar_position[1], 2, self.seek_bar_size[1]],
                                [100, 100, 20, 255], True)

            else:
                gui.seek_cur_show = False

        # Volume Bar --------------------------------------------------------


        if input.mouse_click and coll((
            self.volume_bar_position[0] - right_offset, self.volume_bar_position[1], self.volume_bar_size[0],
            self.volume_bar_size[1] + 4)) or \
                        self.volume_bar_being_dragged is True:
            clicked = True

            if input.mouse_click is True or self.volume_bar_being_dragged is True:
                gui.update = 2


                self.volume_bar_being_dragged = True
                volgetX = mouse_position[0]
                if volgetX > self.volume_bar_position[0] + self.volume_bar_size[0] - right_offset:
                    volgetX = self.volume_bar_position[0] + self.volume_bar_size[0] - right_offset
                if volgetX < self.volume_bar_position[0] - right_offset:
                    volgetX = self.volume_bar_position[0] - right_offset
                volgetX -= self.volume_bar_position[0] - right_offset
                pctl.player_volume = volgetX / self.volume_bar_size[0] * 100

                # gui.rspw += 1
                # gui.update_layout()

                # time.sleep(0.018)
                #time.sleep(0.014)
                time.sleep(0.02)
                #SDL_Delay(50)

                if mouse_down is False:
                    self.volume_bar_being_dragged = False
                    pctl.player_volume = int(pctl.player_volume)
                    pctl.set_volume(True)

            if mouse_down:
                pctl.player_volume = int(pctl.player_volume)
                pctl.set_volume(False)


        if mouse_wheel != 0 and mouse_position[1] > self.seek_bar_position[1] + 4 and not coll_point(mouse_position,
                                                                                                     self.seek_bar_position + self.seek_bar_size):

            pctl.player_volume += mouse_wheel * prefs.volume_wheel_increment
            if pctl.player_volume < 1:
                pctl.player_volume = 0
            elif pctl.player_volume > 100:
                pctl.player_volume = 100

            pctl.player_volume = int(pctl.player_volume)
            pctl.set_volume()

        if right_click and coll((
                    self.volume_bar_position[0] - 15 * gui.scale, self.volume_bar_position[1] - 10 * gui.scale, self.volume_bar_size[0] + 30 * gui.scale,
                    self.volume_bar_size[1] + 20 * gui.scale)):

            if pctl.player_volume > 0:
                volume_store = pctl.player_volume
                pctl.player_volume = 0
            else:
                pctl.player_volume = volume_store

            pctl.set_volume()

        ddt.rect_a((self.volume_bar_position[0] - right_offset, self.volume_bar_position[1]), self.volume_bar_size,
                  colours.volume_bar_background, True)  # 22

        gui.volume_bar_rect = (self.volume_bar_position[0] - right_offset, self.volume_bar_position[1],
                  int(pctl.player_volume * self.volume_bar_size[0] / 100), self.volume_bar_size[1])

        ddt.rect_r(gui.volume_bar_rect,
                  colours.volume_bar_fill, True)


        fields.add(self.volume_bar_position + self.volume_bar_size)
        if pctl.active_replaygain != 0 and (coll((
                    self.volume_bar_position[0], self.volume_bar_position[1], self.volume_bar_size[0],
                    self.volume_bar_size[1])) or self.volume_bar_being_dragged):


            if pctl.player_volume > 50:
                ddt.draw_text((self.volume_bar_position[0] - right_offset + 8 * gui.scale, self.volume_bar_position[1] - 1 * gui.scale), str(pctl.active_replaygain) + " dB", colours.volume_bar_background,
                       11, bg=colours.volume_bar_fill)
            else:
                ddt.draw_text((self.volume_bar_position[0] - right_offset + 85 * gui.scale, self.volume_bar_position[1] - 1 * gui.scale), str(pctl.active_replaygain) + " dB", colours.volume_bar_fill,
                       11, bg=colours.volume_bar_background)

        if gui.show_bottom_title and pctl.playing_state > 0 and window_size[0] > 820 * gui.scale:

            line = pctl.title_text()

            x = self.seek_bar_position[0] + 1
            mx = window_size[0] - 710 * gui.scale
            # if gui.bb_show_art:
            #     x += 10 * gui.scale
            #     mx -= gui.panelBY - 10

            #line = trunc_line(line, 213, mx)
            ddt.draw_text((x, self.seek_bar_position[1] + 24 * gui.scale), line, colours.bar_title_text,
                      fonts.panel_title, max_w=mx)

        if (input.mouse_click or right_click) and coll((
                    self.seek_bar_position[0] - 10 * gui.scale, self.seek_bar_position[1] + 20 * gui.scale, window_size[0] - 710 * gui.scale, 30 * gui.scale)):
            if pctl.playing_state == 3:
                copy_to_clipboard(pctl.tag_meta)
                show_message("Text copied to clipboard")
                if input.mouse_click or right_click:
                    input.mouse_click = False
                    right_click = False
            else:
                pctl.show_current()

                if pctl.playing_ready() and not fullscreen == 1:

                    if right_click:
                        mode_menu.activate()

                    if d_click_timer.get() < 0.3 and input.mouse_click:
                        set_mini_mode()
                        gui.update += 1
                        return
                    else:
                        d_click_timer.set()

        # TIME----------------------

        x = window_size[0] - 57 * gui.scale
        y = window_size[1] - 29 * gui.scale

        rect = (x - 8 * gui.scale - right_offset, y - 3 * gui.scale, 60 * gui.scale + right_offset, 27 * gui.scale)
        # ddt.rect_r(rect, [255, 0, 0, 40], True)
        if input.mouse_click and coll(rect):
            gui.display_time_mode += 1
            if gui.display_time_mode > 3:
                gui.display_time_mode = 0

        if gui.display_time_mode == 0:
            text_time = get_display_time(pctl.playing_time)
            ddt.draw_text((x + 1 * gui.scale, y), text_time, colours.time_playing,
                      fonts.bottom_panel_time)
        elif gui.display_time_mode == 1:
            if pctl.playing_state == 0:
                text_time = get_display_time(0)
            else:
                text_time = get_display_time(pctl.playing_length - pctl.playing_time)
            ddt.draw_text((x + 1 * gui.scale, y), text_time, colours.time_playing,
                      fonts.bottom_panel_time)
            ddt.draw_text((x - 5 * gui.scale, y), '-', colours.time_playing,
                      fonts.bottom_panel_time)
        elif gui.display_time_mode == 2:
            x -= 4
            text_time = get_display_time(pctl.playing_time)
            ddt.draw_text((x - 25 * gui.scale, y), text_time, colours.time_playing,
                      fonts.bottom_panel_time)

            offset1 = 10 * gui.scale

            if system == "windows":
                offset1 += 2 * gui.scale

            offset2 = offset1 + 7 * gui.scale


            ddt.draw_text((x + offset1, y), "/", colours.time_sub,
                      fonts.bottom_panel_time)
            text_time = get_display_time(pctl.playing_length)
            if pctl.playing_state == 0:
                text_time = get_display_time(0)
            elif pctl.playing_state == 3:
                text_time = "-- : --"
            ddt.draw_text((x + offset2, y), text_time, colours.time_sub,
                      fonts.bottom_panel_time)

        elif gui.display_time_mode == 3:

            track = pctl.playing_object()
            if track and track.index != gui.dtm3_index:

                gui.dtm3_cum = 0
                gui.dtm3_total = 0
                run = True
                collected = []
                for item in default_playlist:
                    if pctl.master_library[item].parent_folder_path == track.parent_folder_path:
                        if item not in collected:
                            collected.append(item)
                            gui.dtm3_total += pctl.master_library[item].length
                            if item == track.index:
                                run = False
                            if run:
                                gui.dtm3_cum += pctl.master_library[item].length
                gui.dtm3_index = track.index

            x -= 4
            text_time = get_display_time(gui.dtm3_cum + pctl.playing_time)
            ddt.draw_text((x - 25 * gui.scale, y), text_time, colours.time_playing,
                      fonts.bottom_panel_time)

            offset1 = 10 * gui.scale
            if system == "windows":
                offset1 += 2 * gui.scale
            offset2 = offset1 + 7 * gui.scale

            ddt.draw_text((x + offset1, y), "/", colours.time_sub,
                      fonts.bottom_panel_time)
            text_time = get_display_time(gui.dtm3_total)
            if pctl.playing_state == 0:
                text_time = get_display_time(0)
            elif pctl.playing_state == 3:
                text_time = "-- : --"
            ddt.draw_text((x + offset2, y), text_time, colours.time_sub,
                      fonts.bottom_panel_time)



        # BUTTONS
        # bottom buttons

        if gui.mode == 1:

            # PLAY---
            buttons_x_offset = 0

            play_colour = colours.media_buttons_off
            pause_colour = colours.media_buttons_off
            stop_colour = colours.media_buttons_off
            forward_colour = colours.media_buttons_off
            back_colour = colours.media_buttons_off

            if pctl.playing_state == 1:
                play_colour = colours.media_buttons_active

            if pctl.auto_stop:
                stop_colour = colours.media_buttons_active

            if pctl.playing_state == 2:
                pause_colour = colours.media_buttons_active
                play_colour = colours.media_buttons_active
            elif pctl.playing_state == 3:
                play_colour = colours.media_buttons_active
                if pctl.record_stream:
                    play_colour = [220, 50 ,50 , 255]


            rect = (buttons_x_offset + (10 * gui.scale), window_size[1] - self.control_line_bottom - (13 * gui.scale), 50 * gui.scale , 40 * gui.scale)
            fields.add(rect)
            if coll(rect):
                play_colour = colours.media_buttons_over
                if input.mouse_click:
                    if pctl.playing_state == 1:
                        pctl.show_current(highlight=True)
                    else:
                        pctl.play()
                tool_tip2.test(33 * gui.scale, y - 35 * gui.scale, _("Play, RC: Go to playing"))

                if right_click:
                    pctl.show_current(highlight=True)

            self.play_button.render(29 * gui.scale, window_size[1] - self.control_line_bottom, play_colour)
            # ddt.rect_r(rect,[255,0,0,255], True)

            # PAUSE---
            x = (75 * gui.scale) + buttons_x_offset
            y = window_size[1] - self.control_line_bottom

            rect = (x - 15 * gui.scale, y - 13 * gui.scale, 50 * gui.scale, 40 * gui.scale)
            fields.add(rect)
            if coll(rect):
                pause_colour = colours.media_buttons_over
                if input.mouse_click:
                    pctl.pause()
                tool_tip2.test(x, y - 35 * gui.scale, _("Pause"))


            # ddt.rect_r(rect,[255,0,0,255], True)
            ddt.rect_a((x, y + 0), (4 * gui.scale, 13 * gui.scale), pause_colour, True)
            ddt.rect_a((x + 10 * gui.scale, y + 0), (4 * gui.scale, 13 * gui.scale), pause_colour, True)

            # STOP---
            x = 125 * gui.scale + buttons_x_offset
            rect = (x - 14 * gui.scale, y - 13 * gui.scale, 50 * gui.scale, 40 * gui.scale)
            fields.add(rect)
            if coll(rect):
                stop_colour = colours.media_buttons_over
                if input.mouse_click:
                    pctl.stop()
                if right_click:
                    pctl.auto_stop ^= True
                tool_tip2.test(x, y - 35 * gui.scale, _("Stop, RC: Toggle auto-stop"))


            ddt.rect_a((x, y + 0), (13 * gui.scale, 13 * gui.scale), stop_colour, True)
            # ddt.rect_r(rect,[255,0,0,255], True)

            # FORWARD---
            rect = (buttons_x_offset + 230 * gui.scale, window_size[1] - self.control_line_bottom - 10 * gui.scale, 50 * gui.scale, 35 * gui.scale)
            fields.add(rect)
            if coll(rect):
                forward_colour = colours.media_buttons_over
                if input.mouse_click:
                    pctl.advance()
                    gui.tool_tip_lock_off_f = True
                if right_click:
                    pctl.random_mode ^= True
                    gui.tool_tip_lock_off_f = True
                if middle_click:
                    pctl.advance(rr=True)
                    gui.tool_tip_lock_off_f = True
                #tool_tip.test(buttons_x_offset + 230 * gui.scale + 50 * gui.scale, window_size[1] - self.control_line_bottom - 20 * gui.scale, "Advance")
                # if not gui.tool_tip_lock_off_f:
                #     tool_tip2.test(x + 45 * gui.scale, y - 35 * gui.scale, _("Forward, RC: Toggle shuffle, MC: Radio random"))
            else:
                gui.tool_tip_lock_off_f = False

            self.forward_button.render(240 * gui.scale, 1 + window_size[1] - self.control_line_bottom, forward_colour)

            # ddt.rect_r(rect,[255,0,0,255], True)

            # BACK---
            rect = (buttons_x_offset + 170 * gui.scale, window_size[1] - self.control_line_bottom - 10 * gui.scale, 50 * gui.scale, 35 * gui.scale)
            fields.add(rect)
            if coll(rect):
                back_colour = colours.media_buttons_over
                if input.mouse_click:
                    pctl.back()
                    gui.tool_tip_lock_off_b = True
                if right_click:
                    pctl.repeat_mode ^= True
                    gui.tool_tip_lock_off_b = True
                if middle_click:
                    pctl.revert()
                    gui.tool_tip_lock_off_b = True
                if not gui.tool_tip_lock_off_b:
                    tool_tip2.test(x, y - 35 * gui.scale, _("Back, RC: Toggle repeat, MC: Revert"))
            else:
                gui.tool_tip_lock_off_b = False

            self.back_button.render(180 * gui.scale, 1 + window_size[1] - self.control_line_bottom, back_colour)
            # ddt.rect_r(rect,[255,0,0,255], True)


            # menu button

            x = window_size[0] - 252 * gui.scale - right_offset
            y = window_size[1] - 26 * gui.scale
            rpbc = colours.mode_button_off
            rect = (x - 9 * gui.scale, y - 5 * gui.scale, 40 * gui.scale, 25 * gui.scale)
            fields.add(rect)
            if coll(rect):
                if not extra_menu.active:
                    tool_tip.test(x, y - 28 * gui.scale, "Playback menu")
                rpbc = colours.mode_button_over
                if input.mouse_click:
                    extra_menu.activate(position=(x - 115 * gui.scale, y - 6 * gui.scale))
            if extra_menu.active:
                rpbc = colours.mode_button_active

            ddt.rect_a((x, y), (24 * gui.scale, 2 * gui.scale), rpbc, True)
            y += 5 * gui.scale
            ddt.rect_a((x, y), (24 * gui.scale, 2 * gui.scale), rpbc, True)
            y += 5 * gui.scale
            ddt.rect_a((x, y), (24 * gui.scale, 2 * gui.scale), rpbc, True)

            if window_size[0] > 690 * gui.scale and self.mode == 0:

                # shuffle button
                x = window_size[0] - 318 * gui.scale - right_offset
                y = window_size[1] - 27 * gui.scale

                rect = (x - 5 * gui.scale, y - 5 * gui.scale, 60 * gui.scale, 25 * gui.scale)
                fields.add(rect)

                rpbc = colours.mode_button_off
                if (input.mouse_click or right_click) and coll(rect):

                    if input.mouse_click:
                        pctl.random_mode ^= True
                        if pctl.random_mode is False:
                            self.random_click_off = True
                    else:
                        shuffle_menu.activate(position=(x + 30 * gui.scale, y - 7 * gui.scale))

                if pctl.random_mode:
                    rpbc = colours.mode_button_active
                    if coll(rect):
                        tool_tip.test(x, y - 28 * gui.scale, _("Shuffle"))
                elif coll(rect):
                    tool_tip.test(x, y - 28 * gui.scale, _("Shuffle"))
                    if self.random_click_off is True:
                        rpbc = colours.mode_button_off
                    elif pctl.random_mode is True:
                        rpbc = colours.mode_button_active
                    else:
                        rpbc = colours.mode_button_over
                else:
                    self.random_click_off = False

                # Keep hover highlight on if menu is open
                if shuffle_menu.active and not pctl.random_mode is True:
                    rpbc = colours.mode_button_over

                y += 3 * gui.scale
                ddt.rect_a((x, y), (25 * gui.scale, 3 * gui.scale), rpbc, True)

                if pctl.album_shuffle_mode:
                    ddt.rect_a((x + 25 * gui.scale , y), (23 * gui.scale, 3 * gui.scale), rpbc, True)

                y += 5 * gui.scale
                ddt.rect_a((x, y), (48 * gui.scale, 3 * gui.scale), rpbc, True)

                # REPEAT
                x = window_size[0] - 380 * gui.scale - right_offset
                y = window_size[1] - 27 * gui.scale

                rpbc = colours.mode_button_off

                rect = (x - 6 * gui.scale, y - 5 * gui.scale, 61 * gui.scale, 25 * gui.scale)
                fields.add(rect)
                if (input.mouse_click or right_click) and coll(rect):

                    if input.mouse_click:
                        pctl.repeat_mode ^= True
                        if pctl.repeat_mode is False:
                            self.repeat_click_off = True
                    else: # right click
                        repeat_menu.activate(position=(x + 30 * gui.scale, y - 7 * gui.scale))
                        # pctl.album_repeat_mode ^= True
                        # if not pctl.repeat_mode:
                        #     self.repeat_click_off = True

                if pctl.repeat_mode:
                    rpbc = colours.mode_button_active
                    if coll(rect):
                        if pctl.album_repeat_mode:
                            tool_tip.test(x, y - 28 * gui.scale, _("Repeat album"))
                        else:
                            tool_tip.test(x, y - 28 * gui.scale, _("Repeat track"))
                elif coll(rect):

                    # Tooltips. But don't show tooltips if menus open
                    if not repeat_menu.active and not shuffle_menu.active:
                        if pctl.album_repeat_mode:
                            tool_tip.test(x, y - 28 * gui.scale, _("Repeat album"))
                        else:
                            tool_tip.test(x, y - 28 * gui.scale, _("Repeat track"))

                    if self.repeat_click_off is True:
                        rpbc = colours.mode_button_off
                    elif pctl.repeat_mode is True:
                        rpbc = colours.mode_button_active
                    else:
                        rpbc = colours.mode_button_over
                else:
                    self.repeat_click_off = False

                # Keep hover highlight on if menu is open
                if repeat_menu.active and not pctl.repeat_mode is True:
                    rpbc = colours.mode_button_over

                y += 3 * gui.scale
                w = 3 * gui.scale

                if pctl.album_repeat_mode:
                    ddt.rect_a((x + 4 * gui.scale, y), (25 * gui.scale, w), rpbc, True)

                ddt.rect_a((x + 25 * gui.scale, y), (25 * gui.scale, w), rpbc, True)
                ddt.rect_a((x + 4 * gui.scale, y + 5 * gui.scale), (46 * gui.scale, w), rpbc, True)
                ddt.rect_a((x + 50 * gui.scale - w, y), (w, 8 * gui.scale), rpbc, True)


bottom_bar1 = BottomBarType1()


class MiniMode:

    def __init__(self):

        self.save_position = None
        self.was_borderless = True
        self.volume_timer = Timer()
        self.volume_timer.force_set(100)

        self.left_slide = asset_loader("left-slide.png", True)
        self.right_slide = asset_loader("right-slide.png", True)

        self.shuffle_fade_timer = Timer(100)
        self.repeat_fade_timer = Timer(100)

    def render(self):

        w = window_size[0]
        h = window_size[1]

        y1 = w
        if w == h:
            y1 -= 79 * gui.scale

        h1 = h - y1

        # Draw background
        ddt.rect_r((0, 0, w, h), colours.mini_mode_background, True)
        ddt.text_background_colour = colours.mini_mode_background

        detect_mouse_rect = (3, 3, w - 6, h - 6)
        fields.add(detect_mouse_rect)
        mouse_in = coll(detect_mouse_rect)

        # Play / Pause when right clicking below art
        if right_click: # and mouse_position[1] > y1:
            pctl.play_pause()

        # Volume change on scroll
        if mouse_wheel != 0:
            self.volume_timer.set()

            pctl.player_volume += mouse_wheel * prefs.volume_wheel_increment * 3
            if pctl.player_volume < 1:
                pctl.player_volume = 0
            elif pctl.player_volume > 100:
                pctl.player_volume = 100

            pctl.player_volume = int(pctl.player_volume)
            pctl.set_volume()

        track = pctl.playing_object()

        control_hit_area = (3, y1 - 15 * gui.scale, w - 6, h1 - 3 + 15 * gui.scale)
        mouse_in_area = coll(control_hit_area)
        fields.add(control_hit_area)


        if track is not None:


            # Render album art
            album_art_gen.display(pctl.track_queue[pctl.queue_step],
                                  (0, 0), (w, w))

            if h == w and mouse_in_area:
                #ddt.pretty_rect = (0, 260 * gui.scale, w, 100 * gui.scale)
                ddt.rect_r((0, y1, w, h1), [0,0,0,220], True)

            # Double click bottom text to return to full window
            text_hit_area = (60 * gui.scale, y1 + 4, 230 * gui.scale, 50 * gui.scale)



            if coll(text_hit_area):
                if input.mouse_click:
                    if d_click_timer.get() < 0.3:
                        restore_full_mode()
                        gui.update += 1
                        return
                    else:
                        d_click_timer.set()


            # Draw title texts
            line1 = track.artist
            line2 = track.title

            # Calculate seek bar position
            seek_w = 240 * gui.scale

            seek_w = int(w * 0.65)

            seek_r = [(w - seek_w) // 2, y1 + 57 * gui.scale, seek_w, 6 * gui.scale]
            seek_r_hit = [seek_r[0], seek_r[1] - 4 * gui.scale, seek_r[2], seek_r[3] + 8 * gui.scale]

            if w != h or mouse_in_area:

                if not line1 and not line2:
                    ddt.draw_text((w // 2, y1 + 18 * gui.scale, 2), track.filename, colours.grey(240), 214,
                                  window_size[0] - 30 * gui.scale)
                else:

                    ddt.draw_text((w // 2, y1 + 9 * gui.scale, 2), line1, colours.grey(180), 313,
                                  window_size[0] - 30 * gui.scale)

                    ddt.draw_text((w // 2, y1 + 30 * gui.scale, 2), line2, colours.grey(249), 214,
                                  window_size[0] - 30 * gui.scale)


                # Test click to seek
                if mouse_up and coll(seek_r_hit):

                    click_x = mouse_position[0]
                    if click_x > seek_r[0] + seek_r[2]:
                        click_x = seek_r[0] + seek_r[2]
                    if click_x < seek_r[0]:
                        click_x = seek_r[0]
                    click_x -= seek_r[0]

                    if click_x < 6 * gui.scale:
                        click_x = 0
                    seek = click_x / seek_r[2]

                    pctl.seek_decimal(seek)

                # Draw progress bar background
                ddt.rect_r(seek_r, [55, 55, 55, 255], True)

                # Calculate and draw bar foreground
                progress_w = 0
                if pctl.playing_length > 1:
                    progress_w = pctl.playing_time * seek_w / pctl.playing_length
                seek_colour = [210, 210, 210, 255]

                if pctl.playing_state != 1:
                    seek_colour = [210, 40, 100, 255]

                seek_r[2] = progress_w


                if self.volume_timer.get() < 0.9:
                    progress_w = pctl.player_volume * (seek_w - (4 * gui.scale)) / 100
                    gui.update += 1
                    seek_colour = [210, 210, 210, 255]
                    seek_r[2] = progress_w
                    seek_r[0] += 2 * gui.scale
                    seek_r[1] += 2 * gui.scale
                    seek_r[3] -= 4 * gui.scale

                ddt.rect_r(seek_r, seek_colour, True)


        left_area = (1, y1, seek_r[0] - 1, 45 * gui.scale)
        right_area = (seek_r[0] + seek_w, y1, seek_r[0] - 2, 45 * gui.scale)

        fields.add(left_area)
        fields.add(right_area)

        hint = 0
        if coll(control_hit_area):
            hint = 30
        if coll(left_area):
            hint = 240
        if hint:
            self.left_slide.render(16 * gui.scale, y1 + 17 * gui.scale, [255, 255, 255, hint])

        hint = 0
        if coll(control_hit_area):
            hint = 30
        if coll(right_area):
            hint = 240
        if hint:
            self.right_slide.render(window_size[0] - self.right_slide.w - 16 * gui.scale, y1 + 17 * gui.scale, [255, 255, 255, hint])


        # Shuffle

        shuffle_area = (seek_r[0] + seek_w, seek_r[1] - 10 * gui.scale, 50 * gui.scale, 30 * gui.scale)
        #fields.add(shuffle_area)
        # ddt.rect_r(shuffle_area, [255, 0, 0, 100], True)

        if coll(control_hit_area):
            colour = [255, 255, 255, 20]
            if input.mouse_click and coll(shuffle_area):
                pctl.random_mode ^= True
            if pctl.random_mode:
                colour = [255, 255, 255, 190]

            sx = seek_r[0] + seek_w + 8 * gui.scale
            sy = seek_r[1] - 1 * gui.scale
            ddt.rect_a((sx, sy), (14 * gui.scale, 2 * gui.scale), colour, True)
            sy += 4 * gui.scale
            ddt.rect_a((sx, sy), (28 * gui.scale, 2 * gui.scale), colour, True)


        shuffle_area = (seek_r[0] - 41 * gui.scale, seek_r[1] - 10 * gui.scale, 40 * gui.scale, 30 * gui.scale)
        if coll(control_hit_area):
            colour = [255, 255, 255, 20]
            if input.mouse_click and coll(shuffle_area):
                pctl.repeat_mode ^= True
            if pctl.repeat_mode:
                colour = [255, 255, 255, 190]

            sx = seek_r[0] - 39 * gui.scale
            sy = seek_r[1] - 1 * gui.scale

            tw = 2 * gui.scale
            ddt.rect_a((sx + 15 * gui.scale, sy), (13 * gui.scale, tw), colour, True)
            ddt.rect_a((sx + 4 * gui.scale, sy + 4 * gui.scale), (25 * gui.scale, tw), colour, True)
            ddt.rect_a((sx + 30 * gui.scale - tw, sy), (tw, 6 * gui.scale), colour, True)


        # Forward and back clicking
        if input.mouse_click:
            if coll(left_area):
                pctl.back()
            if coll(right_area):
                pctl.advance()


        # Show exit/min buttons when mosue over
        tool_rect = (window_size[0] - 110 * gui.scale, 2, 108 * gui.scale, 45 * gui.scale)
        fields.add(tool_rect)
        if coll(tool_rect):
            draw_window_tools()

        if w != h:
            ddt.rect_r((0, 0, w, h), colours.mini_mode_border)
            if gui.scale == 2:
                ddt.rect_r((1, 1, w - 2, h - 2), colours.mini_mode_border)

mini_mode = MiniMode()


class MiniMode2:

    def __init__(self):

        self.save_position = None
        self.was_borderless = True
        self.volume_timer = Timer()
        self.volume_timer.force_set(100)

        self.left_slide = asset_loader("left-slide.png", True)
        self.right_slide = asset_loader("right-slide.png", True)

    def render(self):

        w = window_size[0]
        h = window_size[1]

        x1 = h

        # Draw background
        ddt.rect_r((0, 0, w, h), colours.mini_mode_background, True)
        ddt.text_background_colour = colours.mini_mode_background

        detect_mouse_rect = (2, 2, w - 4, h - 4)
        fields.add(detect_mouse_rect)
        mouse_in = coll(detect_mouse_rect)

        # Play / Pause when right clicking below art
        if right_click: # and mouse_position[1] > y1:
            pctl.play_pause()

        # Volume change on scroll
        if mouse_wheel != 0:
            self.volume_timer.set()

            pctl.player_volume += mouse_wheel * prefs.volume_wheel_increment * 3
            if pctl.player_volume < 1:
                pctl.player_volume = 0
            elif pctl.player_volume > 100:
                pctl.player_volume = 100

            pctl.player_volume = int(pctl.player_volume)
            pctl.set_volume()

        track = pctl.playing_object()


        if track is not None:


            # Render album art
            album_art_gen.display(pctl.track_queue[pctl.queue_step],
                                  (0, 0), (h, h))

            text_hit_area = (x1, 0, w, h)

            if coll(text_hit_area):
                if input.mouse_click:
                    if d_click_timer.get() < 0.3:
                        restore_full_mode()
                        gui.update += 1
                        return
                    else:
                        d_click_timer.set()

            # Draw title texts
            line1 = track.artist
            line2 = track.title

            if not line1 and not line2:

                ddt.draw_text((x1 + 15 * gui.scale, 50 * gui.scale), track.filename, colours.grey(150), 315,
                              window_size[0] - x1 - 30 * gui.scale)
            else:



                if ddt.get_text_w(line2, 215) > window_size[0] - x1 - 30 * gui.scale:
                    ddt.draw_text((x1 + 15 * gui.scale, 25 * gui.scale), line2, colours.grey(249), 213,
                                  window_size[0] - x1 - 35 * gui.scale)

                    ddt.draw_text((x1 + 15 * gui.scale, 50 * gui.scale), line1, colours.grey(110), 313,
                                  window_size[0] - x1 -  35 * gui.scale)
                else:

                    ddt.draw_text((x1 + 15 * gui.scale, 25 * gui.scale), line2, colours.grey(249), 215,
                                  window_size[0] - x1 - 30 * gui.scale)

                    ddt.draw_text((x1 + 15 * gui.scale, 50 * gui.scale), line1, colours.grey(110), 314,
                                  window_size[0] - x1 -  30 * gui.scale)



        # Show exit/min buttons when mosue over
        tool_rect = (window_size[0] - 110 * gui.scale, 2, 108 * gui.scale, 45 * gui.scale)
        fields.add(tool_rect)
        if coll(tool_rect):
            draw_window_tools()

        # Seek bar
        if (mouse_in or prefs.mini_mode_micro_always_show_seek) and pctl.playing_state > 0:

            hit_rect = (h, h - 12 * gui.scale, w - h, 13 * gui.scale)

            if coll(hit_rect) and mouse_up:
                p = (mouse_position[0] - h) / (w - h)
                if p > .96:
                    pctl.advance()
                else:
                    pctl.seek_decimal(p)

            bg_rect = (h, h - round(5 * gui.scale), w - h, round(5 * gui.scale))
            ddt.rect_r(bg_rect, [0, 0, 0, 35], True)

            seek_rect = (h, h - round(5 * gui.scale), round((w - h) * (pctl.playing_time / pctl.playing_length)), round(5 * gui.scale))
            colour = colours.artist_text
            if pctl.playing_state != 1:
                colour = [210, 40, 100, 255]
            ddt.rect_r(seek_rect, colour, True)


        # ddt.rect_r((0, 0, w, h), colours.mini_mode_border)
        # if gui.scale == 2:
        #     ddt.rect_r((1, 1, w - 2, h - 2), colours.mini_mode_border)

mini_mode2 = MiniMode2()



def set_mini_mode():

    if fullscreen == 1:
        return

    if gui.maximized:
        SDL_RestoreWindow(t_window)
        update_layout_do()



    gui.mode = 3
    gui.vis = 0
    gui.turbo = False
    gui.draw_vis4_top = False
    gui.level_update = False

    i_y = pointer(c_int(0))
    i_x = pointer(c_int(0))
    SDL_GetWindowPosition(t_window, i_x, i_y)
    gui.save_position = (i_x.contents.value, i_y.contents.value)

    mini_mode.was_borderless = draw_border
    SDL_SetWindowBordered(t_window, False)

    window_size[0] = int(350 * gui.scale)
    window_size[1] = int(429 * gui.scale)

    if prefs.mini_mode_mode == 1:

        window_size[0] = int(330 * gui.scale)
        window_size[1] = int(330 * gui.scale)

    if prefs.mini_mode_mode == 2:
        window_size[0] = int((350 * gui.scale) * 1.2)
        window_size[1] = int((window_size[0] + 79 * gui.scale))

    if prefs.mini_mode_mode == 3:

        window_size[0] = int(430 * gui.scale)
        window_size[1] = int(430 * gui.scale)

    if prefs.mini_mode_mode == 4:

        window_size[0] = int(320 * gui.scale)
        window_size[1] = int(90 * gui.scale)

    SDL_SetWindowMinimumSize(t_window, window_size[0], window_size[1])
    SDL_SetWindowResizable(t_window, False)
    SDL_SetWindowSize(t_window, window_size[0], window_size[1])

    if mini_mode.save_position:
        SDL_SetWindowPosition(t_window, mini_mode.save_position[0], mini_mode.save_position[1])


restore_ignore_timer = Timer()
restore_ignore_timer.force_set(100)

def restore_full_mode():

    i_y = pointer(c_int(0))
    i_x = pointer(c_int(0))
    SDL_GetWindowPosition(t_window, i_x, i_y)
    mini_mode.save_position = [i_x.contents.value, i_y.contents.value]

    if not mini_mode.was_borderless:
        SDL_SetWindowBordered(t_window, True)

    window_size[0] = gui.save_size[0]
    window_size[1] = gui.save_size[1]

    SDL_SetWindowPosition(t_window, gui.save_position[0], gui.save_position[1])
    SDL_SetWindowMinimumSize(t_window, 560, 330)
    SDL_SetWindowResizable(t_window, True)
    SDL_SetWindowSize(t_window, window_size[0], window_size[1])


    restore_ignore_timer.set()  # Hacky

    gui.mode = 1

    global mouse_down
    mouse_down = False
    input.mouse_click = False

    if gui.maximized:
        SDL_MaximizeWindow(t_window)
        time.sleep(0.05)
        SDL_PumpEvents()
        SDL_GetWindowSize(t_window, i_x, i_y)
        window_size[0] = i_x.contents.value
        window_size[1] = i_y.contents.value

        print(window_size)

    gui.update_layout()


def line_render(n_track, p_track, y, this_line_playing, album_fade, start_x, width, style=1, ry=None ):
    timec = colours.bar_time
    titlec = colours.title_text
    indexc = colours.index_text
    artistc = colours.artist_text
    albumc = colours.album_text

    if this_line_playing is True:
        timec = colours.time_text
        titlec = colours.title_playing
        indexc = colours.index_playing
        artistc = colours.artist_playing
        albumc = colours.album_playing

    if n_track.found is False:
        timec = colours.playlist_text_missing
        titlec = colours.playlist_text_missing
        indexc = colours.playlist_text_missing
        artistc = colours.playlist_text_missing
        albumc = colours.playlist_text_missing

    indexoffset = 0
    artistoffset = 0
    indexLine = ""

    offset_font_extra = 0
    if gui.row_font_size > 14:
        offset_font_extra = 8

    # In windows (arial?) draws numbers too high (hack fix)
    num_y_offset = 0
    #if system == 'windows':
    #    num_y_offset = 1


    if True or style == 1:


        # if not gui.rsp and not gui.combo_mode:
        #     width -= 10 * gui.scale

        if n_track.artist != "" or \
                        n_track.title != "":
            line = track_number_process(n_track.track_number)

            indexLine = line
            line = ""

            if len(indexLine) > 2:
                indexoffset += (len(indexLine) * 5 - 15) * gui.scale

            if n_track.artist != "":
                line0 = n_track.artist
                artistoffset = ddt.draw_text((start_x + 27  * gui.scale,
                                         y),
                                         line0,
                                         alpha_mod(artistc, album_fade),
                                         gui.row_font_size,
                                         int(width / 2),
                                         )

                line = n_track.title
            else:
                line += n_track.title
        else:
            line = \
                os.path.splitext((n_track.filename))[
                    0]

        #line += "   ð"

        index = default_playlist[p_track]
        star_x = 0
        total = star_store.get(index)

        if gui.star_mode == 'line' and total > 0 and pctl.master_library[index].length > 0:
            #total = pctl.star_library[key]
            ratio = total / pctl.master_library[index].length
            if ratio > 0.55:
                star_x = int(ratio * 4 * gui.scale)
                if star_x > 60 * gui.scale:
                    star_x = 60 * gui.scale
                sp = y - 0 - gui.playlist_text_offset + int(gui.playlist_row_height / 2)
                if gui.playlist_row_height > 17 * gui.scale:
                    sp -= 1

                lh = 1
                if gui.scale != 1:
                    lh = 2

                colour = colours.star_line
                if this_line_playing and colours.star_line_playing is not None:
                    colour = colours.star_line_playing

                ddt.rect_r([width + start_x - star_x - 45 * gui.scale - offset_font_extra,
                             sp,
                             star_x + 3 * gui.scale,
                             lh
                             ], alpha_mod(colour, album_fade), True)
                star_x += 5

        if gui.star_mode == 'star' and total > 0 and pctl.master_library[
            index].length != 0:

            stars = star_count(total, pctl.master_library[index].length)
            starl = "â" * stars
            star_x = ddt.draw_text((width + start_x - 42 * gui.scale - offset_font_extra,
                       y + gui.star_text_y_offset, 1), starl,
                      alpha_mod(indexc, album_fade), gui.row_font_size)


        if gui.show_hearts:

            xxx = star_x

            count = 0
            spacing = 6 * gui.scale

            yy = ry + (gui.playlist_row_height // 2) - (5 * gui.scale)
            if gui.scale == 1.25:
                yy += 1
            if xxx > 0:
                xxx += 5 * gui.scale

            if love(False, index):

                count = 1

                x = width + start_x - 52 * gui.scale - offset_font_extra - xxx

                display_you_heart(x, yy)

                star_x += 18 * gui.scale

            for name in pctl.master_library[index].lfm_friend_likes:

                # Limit to number of hears to display
                if gui.star_mode == 'none':
                    if count > 6:
                        break
                else:
                    if count > 4:
                        break

                x = width + start_x - 52 * gui.scale - offset_font_extra - (heart_row_icon.w + spacing) * count - xxx

                display_friend_heart(x, yy, name)

                count += 1

                star_x += heart_row_icon.w + spacing + 2




        # Draw track number/index
        display_queue = False

        if pctl.force_queue:

            marks = []
            for i, item in enumerate(pctl.force_queue):
                if item[0] == n_track.index and item[1] == p_track and item[2] == pl_to_id(pctl.active_playlist_viewing):
                    if item[3] == 0:  # Only show mark if track type
                        marks.append(i)

            if marks:
                display_queue = True

        if display_queue:

            li = str(marks[0] + 1)
            if li == '1':
                li = "N"
                # if item[0] == n_track.index and item[1] == p_track and item[2] == pctl.active_playlist_viewing
                if n_track.index == pctl.track_queue[pctl.queue_step] and p_track == pctl.playlist_playing_position:
                    li = "R"

            # rect = (start_x + 3 * gui.scale, y - 1 * gui.scale, 5 * gui.scale, 5 * gui.scale)
            # ddt.rect_r(rect, [100, 200, 100, 255], True)
            if len(marks) > 1:
                li += " " + ("." * (len(marks) - 1))
                li = li[:5]

            colour = [244, 200, 66, 255]
            if colours.lm:
                colour = [220, 40, 40, 255]

            ddt.draw_text((start_x + 5 * gui.scale,
                       y, 2), li,
                      colour, gui.row_font_size + 200 - 1)

        else:
            if len(indexLine) > 2:

                ddt.draw_text((start_x + 5 * gui.scale,
                           y, 2), indexLine,
                          alpha_mod(indexc, album_fade), gui.row_font_size)
            else:

                ddt.draw_text((start_x,
                           y), indexLine,
                          alpha_mod(indexc, album_fade), gui.row_font_size)


        ddt.draw_text((start_x + 33 * gui.scale + artistoffset,
                    y),
                   line,
                   alpha_mod(titlec, album_fade),
                   gui.row_font_size,
                   width - 71 * gui.scale - artistoffset - star_x - 20 * gui.scale,
                   )

        line = get_display_time(n_track.length)

        ddt.draw_text((width + start_x - 36 * gui.scale - offset_font_extra,
                   y + num_y_offset, 0), line,
                  alpha_mod(timec, album_fade), gui.row_font_size)


pl_bg = None
if os.path.exists(user_directory + "/bg.png"):
    pl_bg = LoadImageAsset(user_directory + "/bg.png", True)

class StandardPlaylist:
    def __init__(self):
        pass

    def full_render(self):

        global highlight_left
        global highlight_right

        global playlist_hold
        global playlist_hold_position
        global playlist_selected
        global shift_selection

        global click_time
        global quick_drag
        global mouse_down
        global mouse_up
        global selection_stage

        global r_menu_index
        global r_menu_position

        left = gui.playlist_left
        width = gui.plw

        center_mode = True
        if gui.lsp or gui.set_mode or gui.rsp:
            center_mode = False

        highlight_left = 0
        highlight_width = width

        inset_left = highlight_left + 23 * gui.scale
        inset_width = highlight_width - 32 * gui.scale

        if gui.lsp and not gui.rsp:
            inset_width -= 10 * gui.scale

        if gui.lsp:
            inset_left -= 10 * gui.scale
            inset_width += 10 * gui.scale

        if center_mode:
            highlight_left = gui.scale * int(pow((window_size[0] * 0.01), 2))
            highlight_width = highlight_width - (highlight_left * 2)

            inset_left = highlight_left + 18 * gui.scale
            inset_width = highlight_width - 25 * gui.scale

        w = 0
        gui.row_extra = 0
        cv = 0  # update gui.playlist_current_visible_tracks

        # Draw the background
        SDL_SetRenderTarget(renderer, gui.ttext)
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0)
        SDL_RenderClear(renderer)

        rect = (left, gui.panelY, width, window_size[1])
        ddt.rect_r(rect, colours.playlist_panel_background, True)

        # This draws an optional background image
        if pl_bg:
            pl_bg.render(left + width - pl_bg.w - 60 * gui.scale, window_size[1] - gui.panelBY - pl_bg.h)
            if not gui.set_mode:
                ddt.pretty_rect = (left + width - pl_bg.w - 60 * gui.scale, window_size[1] - gui.panelBY - pl_bg.h, pl_bg.w, pl_bg.h)

        # Mouse wheel scrolling
        if mouse_wheel != 0 and window_size[1] - gui.panelBY - 1 > mouse_position[
            1] > gui.panelY - 2 \
                and not (coll(pl_rect)) and not search_over.active:

            # Set scroll speed
            mx = 4
            if gui.playlist_view_length < 25:
                mx = 3
            if gui.playlist_view_length < 10:
                mx = 2
            pctl.playlist_view_position -= mouse_wheel * mx


            if gui.playlist_view_length > 40:
                pctl.playlist_view_position -= mouse_wheel

            if pctl.playlist_view_position > len(default_playlist):
                pctl.playlist_view_position = len(default_playlist)
            if pctl.playlist_view_position < 1:
                pctl.playlist_view_position = 0
                edge_playlist.pulse()

            scroll_hide_timer.set()
            gui.frame_callback_list.append(TestTimer(0.9))



        # Show notice if playlist empty


        if len(default_playlist) == 0:
            colour = alpha_mod(colours.index_text, 200)  # colours.playlist_text_missing

            top_a = gui.panelY
            if gui.artist_info_panel:
                top_a += gui.artist_panel_height

            b = window_size[1] - top_a - gui.panelBY
            half = int(top_a + (b * 0.60))


            ddt.draw_text((left + int(width / 2) + 10 * gui.scale, half, 2),
                      _("Playlist is empty"), colour, 213, bg=colours.playlist_panel_background)
            ddt.draw_text((left + int(width / 2) + 10 * gui.scale, half + 30 * gui.scale, 2),
                      _("Drag and drop files to import"), colour, 13, bg=colours.playlist_panel_background)

        # Show notice if at end of playlist
        elif pctl.playlist_view_position > len(default_playlist) - 1:
            colour = alpha_mod(colours.index_text, 200)

            top_a = gui.panelY
            if gui.artist_info_panel:
                top_a += gui.artist_panel_height

            b = window_size[1] - top_a - gui.panelBY
            half = int(top_a + (b * 0.17))

            ddt.draw_text((left + int(width / 2) + 10 * gui.scale, half, 2), _("End of Playlist"),
                      colour, 213)

        # For every track in view
        for i in range(gui.playlist_view_length + 1):

            p_track = i + pctl.playlist_view_position

            track_box = (left + highlight_left, gui.playlist_top + gui.playlist_row_height * w, highlight_width,
                            gui.playlist_row_height - 1)

            input_box = (track_box[0] + 30, track_box[1] + 1, track_box[2] - 36, track_box[3] - 1)

            move_on_title = False

            if pctl.playlist_view_position < 0:
                pctl.playlist_view_position = 0
            if len(default_playlist) <= p_track:
                break

            n_track = pctl.master_library[default_playlist[p_track]]

            # Fade other tracks in album mode
            album_fade = 255
            if album_mode and pctl.playing_state != 0 and prefs.dim_art and \
                            n_track.parent_folder_name \
                            != pctl.master_library[pctl.track_queue[pctl.queue_step]].parent_folder_name:
                album_fade = 150

            # Folder Break Row
            if (p_track == 0 or n_track.parent_folder_path
                != pctl.master_library[default_playlist[p_track - 1]].parent_folder_path) and \
                            pctl.multi_playlist[pctl.active_playlist_viewing][4] == 0 and break_enable:

                # ------
                line = n_track.parent_folder_name
                if not prefs.pl_thumb:
                    album_artist_mode = False
                    if n_track.album_artist != "" and n_track.album != "":
                        line = n_track.album_artist + " - " + n_track.album

                        if prefs.left_align_album_artist_title:
                            album_artist_mode = True
                            line = n_track.album

                    if len(line) < 6 and "CD" in line:
                        line = n_track.album

                    date = ""
                    if prefs.append_date and re.match('.*([1-3][0-9]{3})', n_track.date):
                        date = "(" + n_track.date + ")"


                    if line.endswith(")"):
                        b = line.split("(")
                        if len(b) > 1 and len(b[1]) <= 11:

                            match = re.match('.*([1-3][0-9]{3})', b[1])

                            if match:
                                line = b[0]
                                date = "(" + b[1]
                    elif line.startswith("("):

                        b = line.split(")")
                        if len(b) > 1 and len(b[0]) <= 11:

                            match = re.match('.*([1-3][0-9]{3})', b[0])

                            if match:
                                line = b[1]
                                date = b[0] + ")"

                    if "(" in line and re.match('.*([1-3][0-9]{3})', line):
                        date = ""

                    qq = 0

                    if prefs.append_total_time:
                        q = p_track

                        total_time = 0
                        while q < len(default_playlist):

                            if pctl.g(default_playlist[q]).parent_folder_path != n_track.parent_folder_path:
                                break

                            total_time += pctl.g(default_playlist[q]).length

                            q += 1
                            qq += 1

                        if qq > 1:
                            date += " [â" + get_display_time(total_time) + "â]"  # Hair space inside brackets for better visual spacing


                    ex = left + highlight_left + highlight_width - 7 * gui.scale

                    light_offset = 0
                    if colours.lm:
                        light_offset = 3 * gui.scale
                    ex -= light_offset

                    if qq > 1:
                        ex += 1 * gui.scale

                    ddt.text_background_colour = colours.playlist_panel_background
                    height = (gui.playlist_top + gui.playlist_row_height * w) + gui.playlist_row_height - 19 * gui.scale #gui.pl_title_y_offset
                    if gui.scale == 2:
                        height += 1

                    # Draw highlight
                    if p_track in shift_selection and len(shift_selection) > 1:
                        ddt.text_background_colour = alpha_blend(colours.row_select_highlight, colours.playlist_panel_background)
                        ddt.rect_a((left + highlight_left, gui.playlist_top + gui.playlist_row_height * w),
                                  (highlight_width, gui.playlist_row_height), colours.row_select_highlight, True)


                    date_w = 0
                    if date:
                        date_w = ddt.draw_text((ex, height, 1), date, alpha_mod(colours.folder_title, album_fade), gui.row_font_size + gui.pl_title_font_offset)
                        date_w += 4 * gui.scale
                        if qq > 1:
                            date_w -= 1 * gui.scale

                    aa = 0
                    if album_artist_mode:
                        colour = colours.artist_text
                        if "Album Artist" in colours.column_colours:
                            colour = colours.column_colours["Album Artist"]
                        aa = ddt.draw_text((left + highlight_left + 14 * gui.scale, height), n_track.album_artist, alpha_mod(colour, album_fade),gui.row_font_size + gui.pl_title_font_offset,
                                               gui.plw // 3)
                        aa += 12 * gui.scale

                    ft_width = ddt.get_text_w(line, gui.row_font_size + gui.pl_title_font_offset)

                    left_align = highlight_width - date_w - 13 * gui.scale - light_offset

                    extra = aa
                    left_align -= extra

                    if ft_width > left_align:
                        date_w += 19 * gui.scale
                        ddt.draw_text((left + highlight_left + 8 * gui.scale + extra, height), line,
                                   alpha_mod(colours.folder_title, album_fade),
                                   gui.row_font_size + gui.pl_title_font_offset, highlight_width - date_w - extra)

                    else:

                        ddt.draw_text((ex - date_w, height, 1), line,
                                   alpha_mod(colours.folder_title, album_fade),
                                   gui.row_font_size + gui.pl_title_font_offset)



                    # Draw folder title
                    # ddt.draw_text((ex,
                    #             height, 1), line,
                    #            alpha_mod(colours.folder_title, album_fade),
                    #            gui.row_font_size + gui.pl_title_font_offset, left + highlight_width)

                    # Draw separation line below title
                    ddt.rect_r((left + highlight_left, gui.playlist_top + gui.playlist_row_height - 1 * gui.scale + gui.playlist_row_height * w, highlight_width, 1 * gui.scale), colours.folder_line, True)

                    ddt.text_background_colour = colours.playlist_panel_background

                    if playlist_hold is True and coll((
                            left + highlight_left, gui.playlist_top + gui.playlist_row_height * w, highlight_width,
                            gui.playlist_row_height)):

                        if mouse_up:  # and key_shift_down:
                            move_on_title = True



                    # Detect folder title click
                    if (input.mouse_click or right_click or middle_click) and coll(input_box) and mouse_position[1] < window_size[1] - gui.panelBY:


                        # Add folder to queue if middle click
                        if middle_click:

                            # if prefs.finish_current:
                            #     finish_current()
                            add_album_to_queue(default_playlist[p_track], p_track)

                            # pctl.force_queue.append([default_playlist[p_track],
                            #                          p_track, pl_to_id(pctl.active_playlist_viewing), 1, 0, pl_uid_gen()])

                        # Play if double click:
                        if d_mouse_click and p_track in shift_selection and coll_point(last_click_location, (track_box)):
                            click_time -= 1.5
                            pctl.jump(default_playlist[p_track], p_track)
                            line_hit = False
                            input.mouse_click = False

                            if album_mode:
                                goto_album(pctl.playlist_playing_position)

                        # Show selection menu if right clicked after select
                        if right_click:  # and len(shift_selection) > 1:
                            folder_menu.activate(default_playlist[p_track])
                            r_menu_position = p_track
                            selection_stage = 2
                            gui.pl_update = 1

                            if p_track not in shift_selection:
                                shift_selection = []
                                playlist_selected = p_track
                                u = p_track
                                while u < len(default_playlist) and n_track.parent_folder_path == pctl.master_library[
                                    default_playlist[u]].parent_folder_path:
                                    shift_selection.append(u)
                                    u += 1


                        # Add folder to selection if clicked
                        if input.mouse_click and not (scroll_enable and mouse_position[0] < 30):

                            quick_drag = True
                            gui.drag_source_position = copy.deepcopy(click_location)

                            if not pl_is_locked(pctl.active_playlist_viewing) or key_shift_down:

                                playlist_hold = True

                            selection_stage = 1
                            temp = get_folder_tracks_local(p_track)
                            # if p_track not in shift_selection: # not key_shift_down:
                            #     shift_selection = []
                            playlist_selected = p_track

                            if len(shift_selection) > 0 and key_shift_down:
                                if p_track < shift_selection[0]:
                                    for item in reversed(temp):
                                        if item not in shift_selection:
                                            shift_selection.insert(0, item)
                                else:
                                    for item in temp:
                                        if item not in shift_selection:
                                            shift_selection.append(item)

                            else:
                                shift_selection = copy.copy(temp)


                    # # Shade ever other line for folder row
                    # if True and #row_alt and w % 2 == 0:
                    #     ddt.rect_a((gui.playlist_left, gui.playlist_top + gui.playlist_row_height * w),
                    #               (gui.playlist_width, gui.playlist_row_height - 1), [255, 255, 255, 10], True)


                    # Draw blue highlight insert line
                    if mouse_down and playlist_hold and coll(input_box) and p_track not in shift_selection:  # playlist_hold_position != p_track:

                        if len(shift_selection) > 1 or key_shift_down:

                            ddt.rect_r(
                                [left + highlight_left, -1 + gui.playlist_top + gui.playlist_row_height * w + gui.playlist_row_height - 1,
                                 highlight_width, 3],
                                [135, 145, 190, 255], True)

                    w += 1
                else:

                    y = gui.playlist_top + gui.playlist_row_height * w
                    spaces = 5
                    w += spaces
                    hei = spaces * prefs.playlist_row_height

                    pl_thumbnail.size = hei - 15
                    pl_thumbnail.render(n_track.index, (gui.playlist_left, y + 5))


                if playlist_selected > p_track + 1:
                    gui.row_extra += 1

            track_box = (left + highlight_left, gui.playlist_top + gui.playlist_row_height * w, highlight_width,
                            gui.playlist_row_height)

            input_box = (track_box[0] + 30, track_box[1] + 1, track_box[2] - 36, track_box[3] - 1)
            # Shade ever other line if option set
            # if (row_alt or True) and w % 2 == 0:
            #     ddt.rect_a((gui.playlist_left, gui.playlist_top + gui.playlist_row_height * w),
            #               (gui.playlist_width, gui.playlist_row_height - 1), [0, 0, 0, 20], True)

            # Get background colours for fonts
            ddt.text_background_colour = colours.playlist_panel_background

            # Test if line hit
            line_over = False
            if coll(input_box) and mouse_position[1] < window_size[1] - gui.panelBY:
                line_over = True
                if (input.mouse_click or right_click or middle_click):
                    line_hit = True
                else:
                    line_hit = False
            else:
                line_hit = False
                line_over = False

            # Prevent click if near scroll bar
            if scroll_enable and mouse_position[0] < 30:
                line_hit = False

            # Double click to play
            if key_shift_down is False and d_mouse_click and line_hit and p_track == playlist_selected and coll_point(
                    last_click_location, track_box):

                click_time -= 1.5
                pctl.jump(default_playlist[p_track], p_track)
                quick_drag = False
                mouse_down = False
                mouse_up = False
                line_hit = False

                if album_mode:
                    goto_album(pctl.playlist_playing_position)

            # Check if index playing and highlight if true
            this_line_playing = False
            this_line_selected = False

            if len(pctl.track_queue) > 0 and pctl.track_queue[pctl.queue_step] == \
                    default_playlist[p_track]:

                if p_track == pctl.playlist_playing_position and pctl.active_playlist_viewing == pctl.active_playlist_playing:

                    ddt.rect_a((left + highlight_left, gui.playlist_top + gui.playlist_row_height * w),
                              (highlight_width, gui.playlist_row_height - 1), colours.row_playing_highlight, True)
                    this_line_playing = True
                    ddt.text_background_colour = alpha_blend(colours.row_playing_highlight, ddt.text_background_colour)

            # Highlight blue if track is being broadcast
            if default_playlist[
                p_track] == pctl.broadcast_index and pctl.broadcast_active:
                ddt.rect_r(track_box, [40, 40, 190, 80], True)
                ddt.text_background_colour = alpha_blend([40, 40, 190, 80], ddt.text_background_colour)

            # Add to queue on middle click
            if middle_click and line_hit:

                # pctl.force_queue.append([default_playlist[p_track],
                #                          p_track, pl_to_id(pctl.active_playlist_viewing), 0, 0, uid_gen()])
                pctl.force_queue.append(queue_item_gen(default_playlist[p_track],
                                                       p_track, pl_to_id(pctl.active_playlist_viewing)))

            # Make track the selection if right clicked
            if right_click and line_hit:
                if p_track not in shift_selection:
                    shift_selection = [p_track]

            if input.mouse_click and line_hit and p_track not in shift_selection:  # key_shift_down is False and line_hit:
                # shift_selection = []
                shift_selection = [p_track]

            # Deselect multiple if one clicked on and not dragged (mouse up is probably a bit of a hacky way of doing it)
            if len(shift_selection) > 1 and mouse_up and line_over and not key_shift_down and point_proximity_test(gui.drag_source_position, mouse_position, 15): # and not playlist_hold:
                shift_selection = [p_track]
                playlist_selected = p_track
                gui.pl_update = 1
                gui.update = 2

            if mouse_down and line_over and p_track in shift_selection and len(shift_selection) > 1:
                if not pl_is_locked(pctl.active_playlist_viewing):
                    playlist_hold = True
                elif key_shift_down:
                    playlist_hold = True

            if input.mouse_click and line_hit:
                quick_drag = True
                gui.drag_source_position = copy.deepcopy(click_location)

            if (input.mouse_click and key_shift_down is False and line_hit or
                        playlist_selected == p_track):

                playlist_selected = p_track
                this_line_selected = True

                if this_line_playing and colours.lm:
                    pass
                else:
                    ddt.rect_r(track_box, colours.row_select_highlight, True)
                    ddt.text_background_colour = alpha_blend(colours.row_select_highlight, ddt.text_background_colour)

                # if not key_shift_down:
                #     shift_selection = [playlist_selected]

            # Shift Move Selection
            if (move_on_title) or mouse_up and playlist_hold is True and coll((
                    left + highlight_left, gui.playlist_top + gui.playlist_row_height * w, highlight_width, gui.playlist_row_height)):

                if len(shift_selection) > 1 or key_shift_down:
                    if p_track not in shift_selection: #p_track != playlist_hold_position and

                        if len(shift_selection) == 0:

                            ref = default_playlist[playlist_hold_position]
                            default_playlist[playlist_hold_position] = "old"
                            if move_on_title:
                                default_playlist.insert(p_track, "new")
                            else:
                                default_playlist.insert(p_track + 1, "new")
                            default_playlist.remove("old")
                            playlist_selected = default_playlist.index("new")
                            default_playlist[default_playlist.index("new")] = ref

                            gui.pl_update = 1


                        else:
                            ref = []
                            selection_stage = 2
                            for item in shift_selection:
                                ref.append(default_playlist[item])

                            for item in shift_selection:
                                default_playlist[item] = 'old'

                            for item in shift_selection:
                                if move_on_title:
                                    default_playlist.insert(p_track, "new")
                                else:
                                    default_playlist.insert(p_track + 1, "new")

                            for b in reversed(range(len(default_playlist))):
                                if default_playlist[b] == 'old':
                                    del default_playlist[b]
                            shift_selection = []
                            for b in range(len(default_playlist)):
                                if default_playlist[b] == 'new':
                                    shift_selection.append(b)
                                    default_playlist[b] = ref.pop(0)

                            playlist_selected = shift_selection[0]
                            gui.pl_update += 1

                        reload_albums(True)
                        tauon.worker_save_state = True

            # Blue drop line
            if mouse_down and playlist_hold and coll(input_box) and p_track not in shift_selection: #playlist_hold_position != p_track:

                if len(shift_selection) > 1 or key_shift_down:
                    ddt.rect_r(
                        [left + highlight_left, -1 + gui.playlist_top + gui.playlist_row_height + gui.playlist_row_height * w, highlight_width, 3],
                        [125, 105, 215, 255], True)

            # Shift click actions
            if input.mouse_click and line_hit: # and key_shift_down:
                selection_stage = 2
                if p_track != playlist_selected:

                    start_s = p_track
                    end_s = playlist_selected
                    if end_s < start_s:
                        end_s, start_s = start_s, end_s
                    for y in range(start_s, end_s + 1):
                        if y not in shift_selection:
                            shift_selection.append(y)
                    shift_selection.sort()

                # else:
                if not pl_is_locked(pctl.active_playlist_viewing) or key_shift_down:
                    playlist_hold = True
                    playlist_hold_position = p_track

            # Multi Select Highlight
            if p_track in shift_selection and p_track != playlist_selected:
                ddt.rect_a((left + highlight_left, gui.playlist_top + gui.playlist_row_height * w),
                          (highlight_width, gui.playlist_row_height), colours.row_select_highlight, True)
                this_line_selected = True
                ddt.text_background_colour = alpha_blend(colours.row_select_highlight, ddt.text_background_colour)

            if right_click and line_hit and mouse_position[0] > gui.playlist_left + 10:

                if len(shift_selection) > 1:
                    selection_menu.activate(default_playlist[p_track])
                    selection_stage = 2
                else:
                    r_menu_index = default_playlist[p_track]
                    r_menu_position = p_track
                    track_menu.activate(default_playlist[p_track])
                    gui.pl_update += 1
                    gui.update += 1

                playlist_selected = p_track
                #shift_selection = [p_track]

            if line_over:
                if mouse_up and selection_stage > 0:
                    selection_stage -= 1
                if mouse_up and selection_stage == 0 and len(shift_selection) > 1:
                    playlist_hold = False
                    shift_selection = []
                    gui.pl_update = 1

            if not gui.set_mode:

                line_render(n_track, p_track, gui.playlist_text_offset + gui.playlist_top + gui.playlist_row_height * w,
                            this_line_playing, album_fade, left + inset_left, inset_width, 1, gui.playlist_top + gui.playlist_row_height * w)

            else:
                # NEE ---------------------------------------------------------

                # offset_font_extra = 0
                # if gui.row_font_size > 14:
                #     offset_font_extra = 8
                # offset_y_extra = 0
                # if gui.row_font_size > 13:
                #     offset_y_extra = 2
                #     if gui.row_font_size > 14:
                #         offset_y_extra = 3

                start = 18 * gui.scale
                if gui.lsp:
                    start += gui.lspw
                run = start
                end = start + gui.plw

                for h, item in enumerate(gui.pl_st):

                    wid = item[1] - 20 * gui.scale
                    y = gui.playlist_text_offset + gui.playlist_top + gui.playlist_row_height * w
                    ry = gui.playlist_top + gui.playlist_row_height * w
                    if run > end + 24 * gui.scale:
                        break

                    if len(gui.pl_st) == h + 1:
                        wid -= 6 * gui.scale

                    if item[0] == "Starline":
                        #key = n_track.title + n_track.filename
                        total = star_store.get_by_object(n_track)
                        #total = playtime_penalty(n_track, total)
                        #if (key in pctl.star_library) and pctl.star_library[key] != 0 and n_track.length != 0 and wid > 0:
                        if total > 0 and n_track.length != 0 and wid > 0:
                            if gui.star_mode == 'star':

                                # re = 0
                                # if get_love(n_track):
                                #     re = ddt.draw_text((run + 6, y + gui.star_text_y_offset),
                                #           "â¤",
                                #           [220, 90, 90, 255],
                                #           gui.row_font_size,
                                #           )
                                #     re += 4

                                text = star_count(total, n_track.length) * "â"

                                # if get_love(n_track):
                                #     text = text + " â¤"

                                colour = colours.index_text
                                if this_line_playing is True:
                                    colour = colours.index_playing
                                text = trunc_line(text, gui.row_font_size, wid + 7 * gui.scale, False)
                                ddt.draw_text((run + 6 * gui.scale, y + gui.star_text_y_offset),
                                          text,
                                          colour,
                                          gui.row_font_size,
                                          )
                            else:
                                #total = pctl.star_library[key]
                                ratio = total / n_track.length
                                if ratio > 0.55:
                                    star_x = int(ratio * (4 * gui.scale))
                                    if star_x > wid:
                                        star_x = wid

                                    colour = colours.star_line
                                    if this_line_playing and colours.star_line_playing is not None:
                                        colour = colours.star_line_playing

                                    sy = (gui.playlist_top + gui.playlist_row_height * w) + int(gui.playlist_row_height / 2)
                                    ddt.rect_r((run + 4 * gui.scale, sy, star_x, 1 * gui.scale), colour)
                                    # ddt.line(run + 4, sy, run + star_x + 4, sy,
                                    #           colours.star_line)

                    else:
                        text = ""
                        font = gui.row_font_size
                        colour = [200, 200, 200, 255]
                        y_off = 0
                        if item[0] == "Title":
                            colour = colours.title_text
                            if n_track.title != "":
                                text = n_track.title
                            else:
                                text = n_track.filename
                            #     colour = colours.index_playing
                            if this_line_playing is True:
                                colour = colours.title_playing

                        elif item[0] == "Artist":
                            text = n_track.artist
                            colour = colours.artist_text
                            if this_line_playing is True:
                                colour = colours.artist_playing
                        elif item[0] == "Album":
                            text = n_track.album
                            colour = colours.album_text
                            if this_line_playing is True:
                                colour = colours.album_playing
                        elif item[0] == "Album Artist":
                            text = n_track.album_artist
                            if not text and prefs.column_aa_fallback_artist:
                                text = n_track.artist
                            colour = colours.artist_text
                            if this_line_playing is True:
                                colour = colours.artist_playing
                        elif item[0] == "Composer":
                            text = n_track.composer
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing
                        elif item[0] == "Comment":
                            text = n_track.comment.replace("\n", " ").replace("\r", " ")
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing
                        elif item[0] == "T":
                            text = track_number_process(n_track.track_number)
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing
                        elif item[0] == "Date":
                            text = n_track.date
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing
                        elif item[0] == "Filepath":
                            text = n_track.fullpath
                            colour = colours.index_text
                        elif item[0] == "Codec":
                            text = n_track.file_ext
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing
                        elif item[0] == "Lyrics":
                            text = ""
                            if n_track.lyrics != "":
                                text = 'Y'
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing
                        elif item[0] == "Genre":
                            text = n_track.genre
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing
                        elif item[0] == "Bitrate":
                            text = str(n_track.bitrate)
                            if text == "0":
                                text = ""
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing
                        elif item[0] == "Time":
                            text = get_display_time(n_track.length)
                            colour = colours.bar_time
                            #colour = colours.time_text
                            if this_line_playing is True:
                                colour = colours.time_text
                        elif item[0] == "â¤":
                            # col love
                            u = 5 * gui.scale
                            yy = ry + (gui.playlist_row_height // 2) - (5 * gui.scale)
                            if gui.scale == 1.25:
                                yy += 1

                            if get_love(n_track):

                                j = 0  # justify right
                                if run < start + 100 * gui.scale:
                                    j = 1  # justify left

                                display_you_heart(run + 6 * gui.scale, yy, j)
                                u += 18 * gui.scale

                            count = 0
                            for name in n_track.lfm_friend_likes:
                                spacing = 6 * gui.scale
                                if u + (heart_row_icon.w + spacing) * count > wid + 7 * gui.scale:
                                    break

                                x = run + u + (heart_row_icon.w + spacing) * count

                                j = 0  # justify right
                                if run < start + 100 * gui.scale:
                                    j = 1  # justify left

                                display_friend_heart(x, yy, name, j)
                                count += 1


                        elif item[0] == "P":
                            #key = n_track.title + n_track.filename
                            ratio = 0
                            total = star_store.get_by_object(n_track)
                            #if (key in pctl.star_library) and pctl.star_library[key] != 0 and n_track.length != 0:
                            if total > 0 and n_track.length != 0:
                                # total = pctl.star_library[key]
                                if n_track.length > 15:
                                    total += 2
                                ratio = total / n_track.length

                            text = str(str(int(ratio)))
                            if text == "0":
                                text = ""
                            colour = colours.index_text
                            if this_line_playing is True:
                                colour = colours.index_playing

                        if prefs.dim_art and album_mode and \
                                n_track.parent_folder_name \
                                != pctl.master_library[pctl.track_queue[pctl.queue_step]].parent_folder_name:
                            colour = alpha_mod(colour, 150)
                        if n_track.found is False:
                            colour = colours.playlist_text_missing

                        if text:
                            if item[0] in colours.column_colours:
                                colour = colours.column_colours[item[0]]

                            if this_line_playing and item[0] in colours.column_colours_playing:
                                colour = colours.column_colours_playing[item[0]]

                            tt = ddt.draw_text((run + 6, y + y_off),
                                      text,
                                      colour,
                                      font,
                                      max_w=wid)


                            if ddt.was_truncated:
                                # print(text)
                                rect = (run, y, wid - 1, gui.playlist_row_height - 1)
                                gui.heart_fields.append(rect)

                                if coll(rect):
                                    columns_tool_tip.set(run - 7 * gui.scale, y, text, font, rect)

                    run += item[1]


            # -----------------------------------------------------------------
            # Count the number if visable tracks (used by Show Current function)
            if gui.playlist_top + gui.playlist_row_height * w > window_size[0] - gui.panelBY - gui.playlist_row_height:
                pass
            else:
                cv += 1

            w += 1
            if w > gui.playlist_view_length:
                break

        # This is a bit hacky since its only generated after drawing.
        # Used to keep track of how many tracks are actually in view.
        gui.playlist_current_visible_tracks = cv
        gui.playlist_current_visible_tracks_id = pctl.multi_playlist[pctl.active_playlist_viewing][6]


        if (right_click and gui.playlist_top + 40 + gui.playlist_row_height * w < mouse_position[1] < window_size[
            1] - 55 and
                            width + left > mouse_position[0] > gui.playlist_left + 15):
            playlist_menu.activate()

        SDL_SetRenderTarget(renderer, gui.main_texture)
        SDL_RenderCopy(renderer, gui.ttext, None, gui.abc)

        if mouse_down is False:
            playlist_hold = False

        ddt.pretty_rect = None

    def cache_render(self):

        SDL_RenderCopy(renderer, gui.ttext, None, gui.abc)


playlist_render = StandardPlaylist()


class ArtBox:

    def __init__(self):
        pass

    def draw(self, x, y, w, h):

        # Draw a background for whole area
        ddt.rect_r((x, y, w ,h), colours.side_panel_background, True)
        # ddt.rect_r((x, y, w ,h), [255, 0, 0, 200], True)

        # We need to find the size of the inner square for the artwork
        #box = min(w, h)

        box_x = w
        box_y = h

        box_x -= 17 * gui.scale  # Inset the square a bit
        box_y -= 17 * gui.scale  # Inset the square a bit

        # And position the square
        rect = (x + ((w - box_x) // 2), y + ((h - box_y) // 2), box_x, box_y)
        fields.add(rect)
        gui.main_art_box = rect

        # Draw the album art. If side bar is being dragged set quick draw flag
        showc = None

        target_track = None
        if 3 > pctl.playing_state > 0:
            target_track = pctl.playing_object()

        elif pctl.playing_state == 0 and prefs.meta_shows_selected:
            if -1 < playlist_selected < len(pctl.multi_playlist[pctl.active_playlist_viewing][2]):
                target_track = pctl.g(pctl.multi_playlist[pctl.active_playlist_viewing][2][playlist_selected])

        elif pctl.playing_state == 0 and prefs.meta_persists_stop:
                target_track = pctl.master_library[pctl.track_queue[pctl.queue_step]]

        if prefs.meta_shows_selected_always:
            if -1 < playlist_selected < len(pctl.multi_playlist[pctl.active_playlist_viewing][2]):
                target_track = pctl.g(pctl.multi_playlist[pctl.active_playlist_viewing][2][playlist_selected])

        if target_track:  # Only show if song playing or paused

            album_art_gen.display(target_track.index, (rect[0], rect[1]), (box_x, box_y), side_drag)

            showc = album_art_gen.get_info(target_track.index)

        # Draw faint border on album art
        ddt.rect_r(rect, colours.art_box)

        # Draw image downloading indicator
        if gui.image_downloading:
            ddt.draw_text((x + int(box_x / 2), 38 * gui.scale + int(box_y / 2), 2), "Fetching image...", colours.side_bar_line1,
                      14, bg=colours.side_panel_background)
            gui.update = 2

        # Input for album art
        if target_track:

            # Cycle images on click

            if coll(gui.main_art_box) and input.mouse_click is True and key_focused == 0:

                album_art_gen.cycle_offset(target_track.index)

                if pctl.mpris:
                    pctl.mpris.update(force=True)


        # Activate picture context menu on right click
        if right_click and coll(rect) and target_track:
            picture_menu.activate(in_reference=target_track.index)

        # Draw picture metadata
        if showc is not None and coll(rect) \
                and renamebox is False \
                and radiobox is False \
                and pref_box.enabled is False \
                and gui.rename_playlist_box is False \
                and gui.message_box is False \
                and track_box is False \
                and gui.layer_focus == 0:

            if not key_shift_down:

                line = ""
                if showc[0] == 1:
                    line += 'E '
                elif showc[0] == 2:
                    line += 'N '
                else:
                    line += 'F '

                line += str(showc[2] + 1) + "/" + str(showc[1])
                y = box_y + 11 * gui.scale

                xoff = 0
                xoff = ddt.get_text_w(line, 12) + 12 * gui.scale

                ddt.rect_a((x + box_x - xoff, y), (xoff, 18 * gui.scale),
                          [8, 8, 8, 255], True)

                ddt.draw_text((x + box_x - 6 * gui.scale, y, 1), line, [200, 200, 200, 255], 12, bg=[30, 30, 30, 255])

            else:   # Extended metadata

                line = ""
                if showc[0] == 1:
                    line += 'Embedded'
                elif showc[0] == 2:
                    line += 'Network'
                else:
                    line += 'File'

                y = 36 * gui.scale + box_y - 61 * gui.scale

                xoff = 0
                xoff = ddt.get_text_w(line, 12) + 12 * gui.scale

                ddt.rect_a((x + box_x - xoff, y), (xoff, 18 * gui.scale),
                          [8, 8, 8, 255], True)

                ddt.draw_text((x + box_x - 6 * gui.scale, y, 1), line, [200, 200, 200, 255], 12, bg=[30, 30, 30, 255])

                y += 18 * gui.scale

                line = ""
                line += showc[4]
                line += " " + str(showc[3][0]) + "Ã" + str(showc[3][1])
                xoff = 0
                xoff = ddt.get_text_w(line, 12) + 12 * gui.scale

                ddt.rect_a((x + box_x - xoff, y), (xoff, 18 * gui.scale),
                          [8, 8, 8, 255], True)
                ddt.draw_text((x + box_x - 6 * gui.scale, y, 1), line, [200, 200, 200, 255], 12,
                          bg=[30, 30, 30, 255])

                y += 18 * gui.scale

                line = ""
                line += str(showc[2] + 1) + "/" + str(showc[1])
                xoff = 0
                xoff = ddt.get_text_w(line, 12) + 12 * gui.scale

                ddt.rect_a((x + box_x - xoff, y), (xoff, 18 * gui.scale),
                          [8, 8, 8, 255], True)
                ddt.draw_text((x + box_x - 6, y, 1), line, [200, 200, 200, 255], 12,
                          bg=[30, 30, 30, 255])


art_box = ArtBox()

class ScrollBox():

    def __init__(self):

        self.held = False
        self.slide_hold = False
        self.source_click_y = 0
        self.source_bar_y = 0
        self.direction_lock = -1

    def draw(self, x, y, w, h, value, max_value, force_dark_theme=False, click=None, r_click=False, jump_distance=None):

        if max_value < 2:
            return 0

        if click is None:
            click = input.mouse_click

        bar_height = round(90 * gui.scale)

        if h > 400 * gui.scale and max_value < 20:
            bar_height = round(180 * gui.scale)


        bg = [255, 255, 255, 7]
        fg = [255, 255, 255, 30]
        fg_h = [255, 255, 255, 40]
        fg_off = [255, 255, 255, 15]

        if colours.lm and not force_dark_theme:
            bg = [0, 0, 0, 15]
            fg_off = [0, 0, 0, 30]
            fg = [0, 0, 0, 60]
            fg_h = [0, 0, 0, 70]

        ddt.rect_r((x, y, w, h), bg, True)

        half = bar_height // 2

        ratio = value / max_value

        mi = y + half
        mo = y + h - half
        distance = mo - mi
        position = int(round(distance * ratio))

        if coll((x, y, w, h)):

            if r_click:

                p = mouse_position[1] - half - y
                p = max(0, p)

                range = h - bar_height
                p = min(p, range)

                per = p / range

                value = int(round(max_value * per))

                ratio = value / max_value

                mi = y + half
                mo = y + h - half
                distance = mo - mi
                position = int(round(distance * ratio))

            in_bar = False
            if coll((x, mi + position - half, w, bar_height)):
                in_bar = True
                if click:
                    self.held = True

                    # p_y = pointer(c_int(0))
                    # SDL_GetGlobalMouseState(None, p_y)
                    get_sdl_input.mouse_capture_want = True
                    self.source_click_y = mouse_position[1]
                    self.source_bar_y = position


            if pctl.playlist_view_position < 0:
                pctl.playlist_view_position = 0


            elif mouse_down and not self.held:

                #if mouse_position[1] - y < (position + half - 2) or mouse_position[1] - y > position + half + 2:

                if click and not in_bar:
                    self.slide_hold = True
                    self.direction_lock = 1
                    if mouse_position[1] - y < position:
                        self.direction_lock = 0

                if self.slide_hold:
                    if (self.direction_lock == 1 and mouse_position[1] - y < position + half) or \
                        (self.direction_lock == 0 and mouse_position[1] - y > position + half):
                        pass
                    else:

                #if self.slide_hold:
                        if jump_distance is None:
                            jump_distance = 1 if h < 400 else 1


                        if self.direction_lock == 0:
                            position -= jump_distance
                        else:
                            position += jump_distance

                        # if self.lock_direction == 0:
                        #     self.lock_directio

                        if position < 0:
                            position = 0
                        if position > distance:
                            position = distance

                        old_value = value

                        ratio = position / distance
                        value = int(round(max_value * ratio))

                        # This forced the scroll bar to move in a direction so
                        # we dont get stuck due to rounding to same value
                        if self.direction_lock == 1 and old_value >= value:
                            value += 1
                        elif self.direction_lock == 0 and old_value <= value:
                            value -= 1
                        value = max(0, value)
                        value = min(max_value, value)

            else:
                self.slide_hold = False

            # else:
            #     self.lock_direction = 0

        if self.held and mouse_up or not mouse_down:
            self.held = False

        if self.held and not window_is_focused():
            self.held = False

        if self.held:
            # p_y = pointer(c_int(0))
            # SDL_GetGlobalMouseState(None, p_y)
            get_sdl_input.mouse_capture_want = True
            new_y = mouse_position[1]
            gui.update += 1

            offset = new_y - self.source_click_y

            position = self.source_bar_y + offset

            if position < 0:
                position = 0
            if position > distance:
                position = distance

            ratio = position / distance
            value = int(round(max_value * ratio))

        colour = fg_off
        rect = (x, mi + position - half, w, bar_height)
        fields.add(rect)
        if coll(rect):
            colour = fg
        if self.held:
            colour = fg_h

        ddt.rect_r(rect, colour, True)

        return value

mini_lyrics_scroll = ScrollBox()
playlist_panel_scroll = ScrollBox()
artist_info_scroll = ScrollBox()
device_scroll = ScrollBox()
artist_list_scroll = ScrollBox()


class RenameBox:

    def __init__(self):

        self.x = 300
        self.y = 300
        self.playlist_index = 0


    def render(self):

        if gui.level_2_click:
            input.mouse_click = True
        gui.level_2_click = False

        min_w = max(250 * gui.scale, ddt.get_text_w(rename_text_area.text, 315) + 50 * gui.scale)

        rect = [self.x, self.y, min_w, 37 * gui.scale]
        bg = [40, 40, 40, 255]
        ddt.text_background_colour = bg

        # Draw background
        ddt.rect_r(rect, bg, True)

        # Draw text entry
        rename_text_area.draw(rect[0] + 10 * gui.scale, rect[1] + 8 * gui.scale, colours.alpha_grey(250),
                              width=350 * gui.scale, font=315)

        # Draw accent
        rect2 = [self.x, self.y + rect[3] - 4 * gui.scale, min_w, 4 * gui.scale]
        ddt.rect_r(rect2, [255, 255, 255, 60], True)

        # If enter or click outside of box: save and close
        if input.key_return_press or (key_esc_press and len(editline) == 0) \
                or ((input.mouse_click or level_2_right_click) and not coll(rect)):
            gui.rename_playlist_box = False
            if len(rename_text_area.text) > 0:
                pctl.multi_playlist[self.playlist_index][0] = rename_text_area.text
            input.key_return_press = False


rename_box = RenameBox()


class FilterBox:

    def __init__(self):

        self.x = 300
        self.y = 300
        self.active = False


    def render(self):

        if not self.active:
            return

        if gui.level_2_click:
            input.mouse_click = True
        gui.level_2_click = False

        rect = [self.x, self.y, 400 * gui.scale, 120 * gui.scale]

        border = 4 * gui.scale
        rect2 = [rect[0] - border, rect[1] - border, rect[2] + border  * 2, rect[3] + border * 2]

        bg = [60, 40, 80, 255]
        ddt.text_background_colour = bg

        # Draw background
        ddt.rect_r(rect2, [130, 100, 150, 255], True)
        ddt.rect_r(rect2, [130, 100, 150, 255], True)
        ddt.rect_r(rect, bg, True)

        # Draw text entry
        # rename_text_area.draw(rect[0] + 10 * gui.scale, rect[1] + 8 * gui.scale, colours.alpha_grey(250),
        #                       width=350 * gui.scale, font=315)
        #
        # # Draw accent
        # rect2 = [self.x, self.y + rect[3] - 4 * gui.scale, rect[2], 4 * gui.scale]
        # ddt.rect_r(rect2, [255, 255, 255, 60], True)

        # If enter or click outside of box: save and close
        if input.key_return_press or (key_esc_press and len(editline) == 0) \
                or ((input.mouse_click or level_2_right_click) and not coll(rect)):
            self.active = False


filter_box = FilterBox()


class PlaylistBox:

    def __init__(self):

        self.scroll_on = 0
        self.drag = False
        self.drag_source = 0
        self.drag_on = -1

        self.adds = []

        self.indicate_w = round(2 * gui.scale)

        self.lock_icon = WhiteModImageAsset(asset_subfolder + 'lock-corner.png')

        #if gui.scale == 1.25:
        self.tab_h = round(25 * gui.scale)
        self.gap = round(2 * gui.scale)

        self.text_offset = 2 * gui.scale
        if gui.scale == 1.25:
            self.text_offset = 3


    def draw(self, x, y, w, h):

        global quick_drag

        ddt.rect_r((x, y, w, h), colours.side_panel_background, True)

        max_tabs = h // (self.gap + self.tab_h) * gui.scale

        tab_title_colour = [230, 230, 230, 255]

        light_mode = False
        # print(test_lumi(colours.side_panel_background))
        if test_lumi(colours.side_panel_background) < 0.55:
            light_mode = True
            tab_title_colour = [20, 20, 20, 255]

        dark_mode = False
        if test_lumi(colours.side_panel_background) > 0.8:
            dark_mode = True

        show_scroll = False
        tab_start = x + 10 * gui.scale

        if mouse_wheel != 0 and coll((x, y, w, h)):
            self.scroll_on -= mouse_wheel

        if self.scroll_on > len(pctl.multi_playlist) - max_tabs + 1:
            self.scroll_on = len(pctl.multi_playlist) - max_tabs + 1

        if self.scroll_on < 0:
            self.scroll_on = 0

        if len(pctl.multi_playlist) > max_tabs:
            show_scroll = True
        else:
            self.scroll_on = 0


        if show_scroll:
            tab_start += 15 * gui.scale


        tab_width = w - tab_start - 6 * gui.scale

        # Draw scroll bar
        if show_scroll:
            self.scroll_on = playlist_panel_scroll.draw(x + 2, y + 1, 15 * gui.scale, h, self.scroll_on, len(pctl.multi_playlist) - max_tabs + 1)

        draw_pin_indicator = prefs.tabs_on_top

        # Drawing each tab...
        yy = y + 5 * gui.scale
        delete_pl = None

        for i, pl in enumerate(pctl.multi_playlist):

            if yy + self.tab_h > y + h:
                break

            if i < self.scroll_on:
                continue


            if draw_pin_indicator:
                if coll((tab_start + 35 * gui.scale, yy - 1, tab_width - 35 * gui.scale, (self.tab_h + 1))):
                    if input.mouse_click:
                        switch_playlist(i)
                        self.drag_on = i
                        self.drag = True
                        self.drag_source = 1
                        gui.drag_source_position = copy.deepcopy(mouse_position)


            if coll((tab_start, yy - 1, tab_width, (self.tab_h + 1))):
                if right_click:
                    tab_menu.activate(i, mouse_position)
                    gui.tab_menu_pl = i

                if tab_menu.active is False and middle_click:
                    delete_pl = i
                    #delete_playlist(i)
                    #break

                if mouse_up and self.drag:

                    # If drag from top bar to side panel, make hidden
                    if self.drag_source == 0:
                        pctl.multi_playlist[self.drag_on][8] = True
                    #
                    # else:

                    # Move playlist tab
                    if i != self.drag_on and not point_proximity_test(gui.drag_source_position, mouse_position, 10 * gui.scale):
                        if key_shift_down:
                            pctl.multi_playlist[i][2] += pctl.multi_playlist[self.drag_on][2]
                            delete_playlist(self.drag_on)
                        else:
                            move_playlist(self.drag_on, i)

                    gui.update += 1

                if not draw_pin_indicator:
                    if input.mouse_click:
                        switch_playlist(i)
                        self.drag_on = i
                        self.drag = True
                        self.drag_source = 1
                        gui.drag_source_position = copy.deepcopy(mouse_position)


                # Process input of dragging tracks onto tab
                if quick_drag is True:
                    if mouse_up:
                        quick_drag = False
                        modified = False
                        gui.pl_update += 1
                        for item in shift_selection:
                            pctl.multi_playlist[i][2].append(default_playlist[item])
                            modified = True
                        if len(shift_selection) > 0:
                            self.adds.append([pctl.multi_playlist[i][6], len(shift_selection), Timer()]) # ID, num, timer
                            modified = True
                        if modified:
                            tauon.worker_save_state = True
                            pctl.update_shuffle_pool(pctl.multi_playlist[i][6], shift_selection)

            # Toggle hidden flag on click
            if draw_pin_indicator and input.mouse_click and coll((tab_start + 5 * gui.scale, yy + 3 * gui.scale, 25 * gui.scale , 26  * gui.scale)):
                pl[8] ^= True

            name = pl[0]
            hidden = pl[8]

            semi_light = False
            if not light_mode and test_lumi(colours.side_panel_background) < 0.85 and False:
                semi_light = True

            bg = [255, 255, 255, 6]
            if light_mode:
                bg = [0, 0, 0, 8]
            if semi_light:
                bg = [45, 45, 45, 255]

            # Background is insivible by default (for hightlighting if selected)
            bg = [0,0,0,0]

            # Additional highlight reasons
            # if i == pctl.active_playlist_playing and 3 > pctl.playing_state > 0:
            #     bg = [255, 255, 255, 10]
            #
            #     if dark_mode:
            #         bg = [255, 255, 255, 8]
            #     if light_mode:
            #         bg = [0, 0, 0, 13]
            #     if semi_light:
            #         bg = [55, 55, 55, 255]

            # Highlight if playlist selected (viewing)
            if i == pctl.active_playlist_viewing or (tab_menu.active and tab_menu.reference == i):
                bg = [255, 255, 255, 25]

                # Adjust highlight for different background brightnesses
                if dark_mode:
                    bg = [255, 255, 255, 15]
                if light_mode:
                    bg = [0, 0, 0, 25]
                if semi_light:
                    bg = [55, 55, 55, 255]

            # Highlight target playlist when tragging tracks over
            if coll((tab_start + 50 * gui.scale, yy - 1, tab_width - 50 * gui.scale, (self.tab_h + 1))) and quick_drag:
                bg = [255, 255, 255, 15]
                if light_mode:
                    bg = [0, 0, 0, 16]
                if semi_light:
                    bg = [52, 52, 52, 255]

            # Get actual bg from blend for text bg
            real_bg = alpha_blend(bg, colours.side_panel_background)

            # Draw highlight
            ddt.rect_r((tab_start, yy - 1 * gui.scale, tab_width, 25 * gui.scale), bg, True)

            # Draw title text
            text_start = 10 * gui.scale
            if draw_pin_indicator:
                #text_start = 40 * gui.scale
                text_start = 32 * gui.scale


            ddt.draw_text((tab_start + text_start, yy + self.text_offset), name, tab_title_colour, 211, max_w=tab_width - text_start - 15 * gui.scale, bg=real_bg)

            # print(light_mode)
            # print(dark_mode)

            # Set and adjust pin indicator colour for different background brightnesses
            indicator_colour = [100, 200, 90, 255]
            if light_mode:
                indicator_colour = [40, 40, 40, 210]
            if hidden:
                indicator_colour = [60, 60, 60, 245]
                if not dark_mode:
                    indicator_colour = [80, 80, 80, 120]

            # if i == pctl.active_playlist_playing:
            #     indicator_colour = [200, 230, 20, 255]
            #     if light_mode:
            #         indicator_colour = [100, 60, 180, 255]

            #else:

            # Draw pin indicator/toggle
            if draw_pin_indicator:
                ddt.rect_r((tab_start + 10 * gui.scale, yy + 8 * gui.scale, 6 * gui.scale, 6 * gui.scale), indicator_colour, True)


            # # Draw indicator playing track from this playlist
            # if i == pctl.active_playlist_playing:
            #     ddt.rect_r((tab_start + tab_width - 4 * gui.scale, yy, self.indicate_w, self.tab_h - self.indicate_w),
            #                colours.title_playing, True)

            # Draw indicator playing track from this playlist

            # Is mouse collided with tab?
            hit = coll((tab_start + 50 * gui.scale, yy - 1, tab_width - 50 * gui.scale, (self.tab_h + 1)))

            if not prefs.tabs_on_top:
                if i == pctl.active_playlist_playing:

                    indicator_colour = colours.title_playing
                    if colours.lm:
                        indicator_colour = colours.seek_bar_fill

                    ddt.rect_r((tab_start + 0 - 2 * gui.scale, yy, self.indicate_w, self.tab_h - self.indicate_w),
                               indicator_colour, True)


            # If mouse over...
            if hit:
                # Draw indicator for dragging tracks
                if quick_drag:
                    ddt.rect_r((tab_start + tab_width - 2 * gui.scale, yy, self.indicate_w, self.tab_h - self.indicate_w), [80, 200, 180, 255], True)

                # Draw indicators for moving tab
                if self.drag and i != self.drag_on and not point_proximity_test(gui.drag_source_position, mouse_position, 10 * gui.scale):
                    if key_shift_down:
                        ddt.rect_r((tab_start + tab_width - 4 * gui.scale, yy, self.indicate_w, self.tab_h - self.indicate_w), [80, 160, 200, 255], True)
                    else:
                        if i < self.drag_on:
                            ddt.rect_r((tab_start, yy - self.indicate_w, tab_width, self.indicate_w), [80, 160, 200, 255], True)
                        else:
                            ddt.rect_r((tab_start, yy + (self.tab_h - self.indicate_w), tab_width, self.indicate_w), [80, 160, 200, 255], True)


            # Draw lock icon (but not if shift append indicator)
            if pl[9] and not (key_shift_down and self.drag and hit and i != self.drag_on):
                cl = [255, 255, 255, 24]
                if light_mode:
                    cl = [0, 0, 0, 50]
                self.lock_icon.render(tab_start + tab_width - self.lock_icon.w, yy, cl)

            # Draw effect of adding tracks to playlist
            if len(self.adds) > 0:
                for k in reversed(range(len(self.adds))):
                    if pctl.multi_playlist[i][6] == self.adds[k][0]:
                        if self.adds[k][2].get() > 0.3:
                            del self.adds[k]
                        else:
                            ay = yy + 4 * gui.scale
                            ay -= 6 * gui.scale * self.adds[k][2].get() / 0.3

                            ddt.draw_text((tab_start + tab_width - 10 * gui.scale, int(round(ay)), 1), '+' + str(self.adds[k][1]), colours.pluse_colour, 212, bg=real_bg)
                            gui.update += 1

                            ddt.rect_r((tab_start + tab_width, yy, self.indicate_w, self.tab_h - self.indicate_w), [244, 212, 66, int(255 * self.adds[k][2].get() / 0.3) * -1], True)


            yy += self.tab_h + self.gap

        if delete_pl is not None:
            delete_playlist(delete_pl)
            gui.update += 1

        # Create new playlist if drag in blank space after tabs
        rect = (x, yy, w - 10 * gui.scale, h - (yy - y))
        fields.add(rect)
        if coll(rect):
            if quick_drag:
                ddt.rect_r((tab_start, yy, tab_width, self.indicate_w), [80, 160, 200, 255], True)
                if mouse_up:
                    drop_tracks_to_new_playlist(shift_selection)

            if right_click:
                extra_tab_menu.activate(pctl.active_playlist_viewing)


            # Move tab to end playlist if dragged past end
            if self.drag:
                if mouse_up:

                    # If drag from top bar to side panel, make hidden
                    if self.drag_source == 0:
                        pctl.multi_playlist[self.drag_on][8] = True

                    move_playlist(self.drag_on, i)
                    gui.update += 2
                    self.drag = False
                else:
                    ddt.rect_r((tab_start, yy, tab_width, self.indicate_w),
                               [80, 160, 200, 255], True)


playlist_box = PlaylistBox()


def create_artist_pl(artist, replace=False):

    #replace = False

    source_pl = pctl.active_playlist_viewing
    this_pl = pctl.active_playlist_viewing

    if pctl.multi_playlist[source_pl][10]:
        if pctl.multi_playlist[source_pl][0].startswith("Artist:"):
            new = id_to_pl(pctl.multi_playlist[source_pl][10])
            if new is None:
                # The original playlist is now gone
                pctl.multi_playlist[source_pl][10] = ""
            else:
                source_pl = new
                #replace = True


    playlist = []

    for item in pctl.multi_playlist[source_pl][2]:
        track = pctl.g(item)
        if track.artist == artist or track.album_artist == artist:
            playlist.append(item)

    if replace:
        pctl.multi_playlist[this_pl][2][:] = playlist[:]
        pctl.multi_playlist[this_pl][0] = "Artist: " + artist
        if album_mode:
            reload_albums()

    else:

        pctl.multi_playlist.append(pl_gen(title="Artist: " + artist,
                                          playlist=playlist,
                                          hide_title=0,
                                          parent=pl_to_id(pctl.active_playlist_viewing)))

        switch_playlist(len(pctl.multi_playlist) - 1)

artist_list_menu.add(_("Filter to New Playlist"), create_artist_pl, pass_ref=True)


def verify_discogs():
    return len(prefs.discogs_pat) == 40

def save_discogs_artist_thumb(artist, filepath):

    print("Searching discogs for artist image...")

    d = discogs_client.Client('TauonMusicBox/' + n_version, user_token=prefs.discogs_pat)

    results = d.search(artist, type='artist')

    images = results[0].images
    #print(results)

    for image in images:
        if image['height'] == image['width']:
            print("Found square")
            url = image['uri']
            break
    else:
        url = images[0]['uri']

    response = urllib.request.urlopen(url)
    im = Image.open(response)

    width, height = im.size
    if width > height:
        delta = width - height
        left = int(delta/2)
        upper = 0
        right = height + left
        lower = height
    else:
        delta = height - width
        left = 0
        upper = int(delta/2)
        right = width
        lower = width + upper

    im = im.crop((left, upper, right, lower))
    im.save(filepath, 'JPEG', quality=90)
    im.close()
    print("Found artist image from Discogs")




def save_fanart_artist_thumb(mbid, filepath, preview=False):

    print("Searching fanart.tv for image...")
    #print("mbid is " + mbid)
    r = requests.get("http://webservice.fanart.tv/v3/music/" \
                     + mbid + "?api_key=" + prefs.fatvap)
    # print(r.json())
    thumblink = r.json()['artistthumb'][0]['url']
    if preview:
        thumblink = thumblink.replace("/fanart/music", "/preview/music")

    response = urllib.request.urlopen(thumblink)
    info = response.info()

    t = io.BytesIO()
    t.seek(0)
    t.write(response.read())
    l = 0
    t.seek(0, 2)
    l = t.tell()
    t.seek(0)

    if info.get_content_maintype() == 'image' and l > 1000:
        f = open(filepath, 'wb')
        f.write(t.read())
        f.close()

        if prefs.fanart_notify:
            prefs.fanart_notify = False
            show_message("Notice: Artist image sourced from fanart.tv", 'link',
                         'They encrouge you to contribute at https://fanart.tv')
        print("Found artist thumbnail from fanart.tv")

class ArtistList:

    def __init__(self):

        self.tab_h = round(60 * gui.scale)
        self.thumb_size = round(55 * gui.scale)

        self.current_artists = []
        self.current_album_counts = {}

        self.thumb_cache = {}

        self.to_fetch = ""
        self.to_fetch_mbid_a = ""

        self.scroll_position = 0

        self.id_to_load = ""

        self.d_click_timer = Timer()
        self.d_click_ref = -1

        self.click_ref = -1
        self.click_highlight_timer = Timer()

        self.saves = {}

        self.load = False

    def load_img(self, artist):

        filepath = os.path.join(cache_directory, artist + "-lfm.png")

        if os.path.isfile(os.path.join(user_directory, "artist-pictures/" + artist + ".png")):
            filepath = os.path.join(user_directory, "artist-pictures/" + artist + ".png")

        elif os.path.isfile(os.path.join(user_directory, "artist-pictures/" + artist + ".jpg")):
            filepath = os.path.join(user_directory, "artist-pictures/" + artist + ".jpg")

        elif os.path.isfile(os.path.join(cache_directory, artist + "-ftv-full.jpg")):
            filepath = os.path.join(cache_directory, artist + "-ftv-full.jpg")

        elif os.path.isfile(os.path.join(cache_directory, artist + "-ftv.jpg")):
            filepath = os.path.join(cache_directory, artist + "-ftv.jpg")

        elif os.path.isfile(os.path.join(cache_directory, artist + "-dcg.jpg")):
            filepath = os.path.join(cache_directory, artist + "-dcg.jpg")

        if os.path.isfile(filepath):

            try:
                g = io.BytesIO()
                g.seek(0)

                im = Image.open(filepath)

                im.thumbnail((self.thumb_size, self.thumb_size), Image.ANTIALIAS)

                # bigsize = (im.size[0] * 4, im.size[1] * 4)
                # mask = Image.new('L', bigsize, 0)
                # draw = ImageDraw.Draw(mask)
                # draw.ellipse((0, 0) + bigsize, fill=255)
                # mask = mask.resize(im.size, Image.ANTIALIAS)
                # im.putalpha(mask)

                im.save(g, 'PNG')
                g.seek(0)

                wop = rw_from_object(g)
                s_image = IMG_Load_RW(wop, 0)
                texture = SDL_CreateTextureFromSurface(renderer, s_image)
                SDL_FreeSurface(s_image)
                tex_w = pointer(c_int(0))
                tex_h = pointer(c_int(0))
                SDL_QueryTexture(texture, None, None, tex_w, tex_h)
                sdl_rect = SDL_Rect(0, 0)
                sdl_rect.w = int(tex_w.contents.value)
                sdl_rect.h = int(tex_h.contents.value)

                self.thumb_cache[artist] = [texture, sdl_rect]
            except:
                print("Artist thumbnail processing error")
                self.thumb_cache[artist] = None

        elif artist in prefs.failed_artists:
            self.thumb_cache[artist] = None
        else:
            if not self.to_fetch:
                # if gall_render_last_timer.get() < 4:
                #     return
                self.to_fetch = artist


    def worker(self):

        if self.load:
            self.prep()
            self.load = False
            return

        if self.to_fetch:

            #self.thumb_cache[self.to_fetch] = None
            #self.to_fetch = ""
            #return

            if get_lfm_wait_timer.get() < 2:
                return

            artist = self.to_fetch
            filename = artist + '-lfm.png'
            filename2 = artist + '-lfm.txt'
            filename3 = artist + '-ftv.jpg'
            filename4 = artist + '-dcg.jpg'
            filepath = os.path.join(cache_directory, filename)
            filepath2 = os.path.join(cache_directory, filename2)
            filepath3 = os.path.join(cache_directory, filename3)
            filepath4 = os.path.join(cache_directory, filename4)
            try:

                # Lookup artist info on last.fm
                print("lastfm lookup artist: " + artist)
                mbid = lastfm.artist_mbid(artist)
                get_lfm_wait_timer.set()
                # if data[0] is not False:
                #     #cover_link = data[2]
                #     text = data[1]
                #
                #     if not os.path.exists(filepath2):
                #         f = open(filepath2, 'w', encoding='utf-8')
                #         f.write(text)
                #         f.close()


                if mbid:
                    save_fanart_artist_thumb(mbid, filepath3, preview=True)


            except:
                #raise
                print("Failed to find image from fanart.tv")
                if verify_discogs():
                    try:
                        save_discogs_artist_thumb(artist, filepath4)
                    except:
                        print("Failed to find image from discogs")

            if os.path.exists(filepath3) or os.path.exists(filepath4):
                gui.update += 1
            else:
                if artist not in prefs.failed_artists:
                    print("Failed featching: " + artist)
                    prefs.failed_artists.append(artist)

            self.to_fetch = ""

            #self.to_fetch_mbid_a = ""

            # if get_lfm_wait_timer.get() < 0.3:
            #     return
            #
            # artist = self.to_fetch
            # filename = artist + '-lfm.png'
            # filename2 = artist + '-lfm.txt'
            # filepath = os.path.join(cache_directory, filename)
            # filepath2 = os.path.join(cache_directory, filename2)
            # try:
            #     data = lastfm.artist_info(artist)
            #     get_lfm_wait_timer.set()
            #     if data[0] is not False:
            #         cover_link = data[2]
            #         text = data[1]
            #
            #         if not os.path.exists(filepath2):
            #             f = open(filepath2, 'w', encoding='utf-8')
            #             f.write(text)
            #             f.close()
            #
            #         if cover_link and 'http' in cover_link:
            #
            #             print("Fetching artist image... " + artist)
            #             response = urllib.request.urlopen(cover_link)
            #             info = response.info()
            #
            #             t = io.BytesIO()
            #             t.seek(0)
            #             t.write(response.read())
            #             l = 0
            #             t.seek(0, 2)
            #             l = t.tell()
            #             t.seek(0)
            #
            #             if info.get_content_maintype() == 'image' and l > 1000:
            #                 f = open(filepath, 'wb')
            #                 f.write(t.read())
            #                 f.close()
            # except:
            #     print("Fetch artist image failed")
            #
            # if os.path.exists(filepath):
            #     gui.update += 1
            # else:
            #     if artist not in prefs.failed_artists:
            #         print("Failed featching: " + artist)
            #         prefs.failed_artists.append(artist)
            #
            # self.to_fetch = ""


    def prep(self):

        #self.current_artists.clear()
        self.scroll_position = 0

        curren_pl_no = id_to_pl(self.id_to_load)
        if curren_pl_no is None:
            return
        current_pl = pctl.multi_playlist[curren_pl_no]

        all = []
        artist_parents = {}
        counts = {}

        try:

            for item in current_pl[2]:
                time.sleep(0.00001)
                track = pctl.g(item)
                artist = get_artist_strip_feat(track)
                if prefs.artist_list_prefer_album_artist and track.album_artist:
                    artist = track.album_artist

                if artist:
                    # Confirm to final list if appeared at least 5 times
                    if artist not in all:
                        if artist not in counts:
                            counts[artist] = 0
                        counts[artist] += 1
                        if counts[artist] > 4:
                            all.append(artist)
                        elif len(current_pl[2]) < 1000:
                            all.append(artist)

                    if artist not in artist_parents:
                        artist_parents[artist] = []
                    if track.parent_folder_path not in artist_parents[artist]:
                        artist_parents[artist].append(track.parent_folder_path)


            current_album_counts = artist_parents

            all.sort(key=lambda y: y.lower())

        except:
            print("Album scan failure")
            time.sleep(4)
            return

        # Artist-list, album-counts, scroll-position, playlist-length
        save = [all, current_album_counts, 0, len(current_pl[2])]

        # Scroll to playing artist
        scroll = 0
        if pctl.playing_ready():
            track = pctl.playing_object()
            for i, item in enumerate(save[0]):
                if item == track.artist or item == track.album_artist:
                    scroll = i
                    break
        save[2] = scroll

        viewing_pl_id = pctl.multi_playlist[pctl.active_playlist_viewing][6]
        if viewing_pl_id in self.saves:
            self.saves[viewing_pl_id][2] = self.scroll_position

        self.saves[current_pl[6]] = save
        gui.update += 1
        #self.current_artists.sort()

        #print(self.current_artists)

    def locate_artist_letter(self, text):

        if not text:
            return

        letter = text[0].lower()
        letter_upper = letter.upper()
        for i, item in enumerate(self.current_artists):
            if item and (item[0] == letter or item[0] == letter_upper):
                self.scroll_position = i
                break

        viewing_pl_id = pctl.multi_playlist[pctl.active_playlist_viewing][6]
        if viewing_pl_id in self.saves:
            self.saves[viewing_pl_id][2] = self.scroll_position

    def locate_artist(self, track):

        for i, item in enumerate(self.current_artists):
            if item == track.artist or item == track.album_artist:
                self.scroll_position = i
                break

        viewing_pl_id = pctl.multi_playlist[pctl.active_playlist_viewing][6]
        if viewing_pl_id in self.saves:
            self.saves[viewing_pl_id][2] = self.scroll_position
        #gui.update += 1

    def draw_card(self, artist, x, y, w):

        global playlist_selected

        area = (4 * gui.scale, y, w - 26 * gui.scale, self.tab_h - 2)

        light_mode = False
        line1_colour = [235, 235, 235, 255]
        # line2_colour = [150, 150, 150, 255]
        line2_colour = alpha_mod(colours.side_bar_line2, 150)
        fade_max = 50

        if test_lumi(colours.side_panel_background) < 0.55:
            light_mode = True
            fade_max = 20
            line1_colour = [35, 35, 35, 255]
            line2_colour = [100, 100, 100, 255]



        fade = 0
        t = self.click_highlight_timer.get()
        if self.click_ref == artist and (t < 2.2 or artist_list_menu.active):

            if t < 1.9 or artist_list_menu.active:
                fade = fade_max
            else:
                fade = fade_max - round((t - 1.9) / 0.3 * fade_max)

            gui.update += 1
            ddt.rect_r(area, [50, 50, 50, fade], True)

        bg = alpha_blend([50, 50, 50, fade], colours.side_panel_background)

        if artist not in self.thumb_cache:
            self.load_img(artist)

        thumb_x = round(x + 10 * gui.scale)

        back_colour = [30, 30, 30, 255]
        border_colour = [60, 60, 60, 255]
        if colours.lm:
            back_colour = [200, 200, 200, 255]
            border_colour = [160, 160, 160, 255]

        ddt.rect_r((thumb_x, round(y), self.thumb_size, self.thumb_size), back_colour, True)
        ddt.rect_r((thumb_x, round(y), self.thumb_size, self.thumb_size), border_colour)

        if artist in self.thumb_cache:
            thumb = self.thumb_cache[artist]
            if thumb is not None:
                thumb[1].x = thumb_x
                thumb[1].y = round(y)
                SDL_RenderCopy(renderer, thumb[0], None, thumb[1])
                if prefs.art_bg:
                    rect = SDL_Rect(thumb_x, round(y), self.thumb_size, self.thumb_size)
                    if (rect.y + rect.h) > window_size[1] - gui.panelBY:
                        diff = (rect.y + rect.h) - (window_size[1] - gui.panelBY)
                        rect.h -= round(diff)
                    style_overlay.hole_punches.append(rect)


        x_text = x + self.thumb_size + 22 * gui.scale
        ddt.draw_text((x_text, y + self.tab_h // 2 - 23 * gui.scale), artist, line1_colour, 212, w - x_text - 35 * gui.scale, bg=bg)

        album_count = len(self.current_album_counts[artist])
        text = str(album_count) + " album"
        if album_count > 1:
            text += "s"

        ddt.draw_text((x_text, y + self.tab_h // 2 + 0 * gui.scale), text, line2_colour, 312, w - x_text - 15 * gui.scale, bg=bg)

        if coll(area) and mouse_position[1] < window_size[1] - gui.panelBY:
            if input.mouse_click:
                self.click_ref = artist

                double_click = False
                if self.d_click_timer.get() < 0.4 and self.d_click_ref == artist:
                    double_click = True

                self.click_highlight_timer.set()

                if pctl.multi_playlist[pctl.active_playlist_viewing][10] and \
                        pctl.multi_playlist[pctl.active_playlist_viewing][0].startswith("Artist:"):
                    create_artist_pl(artist, replace=True)

                block_starts = []
                current = False
                for i in range(len(default_playlist)):
                    track = pctl.g(default_playlist[i])
                    if current is False:
                        if track.artist == artist or track.album_artist == artist:
                            block_starts.append(i)
                            current = True
                    else:
                        if track.artist != artist and track.album_artist != artist:
                            current = False

                if not block_starts:
                    print("No matching artists found in playlist")
                    return

                select = block_starts[0]

                if len(block_starts) > 1:
                    if -1 < playlist_selected < len(default_playlist):
                        if playlist_selected in block_starts:
                            scroll_hide_timer.set()
                            gui.frame_callback_list.append(TestTimer(0.9))
                            if block_starts[-1] == playlist_selected:
                                pass
                            else:
                                select = block_starts[block_starts.index(playlist_selected) + 1]


                gui.pl_update += 1
                if album_mode:
                    goto_album(select)

                self.click_highlight_timer.set()

                if double_click:
                    select = block_starts[0]
                    pctl.jump(default_playlist[select])
                    pctl.playlist_view_position = select
                    playlist_selected = select

                    shift_selection.clear()
                    self.d_click_timer.force_set(10)
                else:
                    #playlist_selected = i
                    pctl.playlist_view_position = select
                    playlist_selected = select
                    self.d_click_ref = artist
                    self.d_click_timer.set()


            if right_click:
                self.click_ref = artist
                self.click_highlight_timer.set()

                artist_list_menu.activate(in_reference=artist)


    def render(self, x, y ,w ,h):

        viewing_pl_id = pctl.multi_playlist[pctl.active_playlist_viewing][6]

        # use parent playlst is set
        if pctl.multi_playlist[pctl.active_playlist_viewing][10]:

            # test if parent still exsists
            new = id_to_pl(pctl.multi_playlist[pctl.active_playlist_viewing][10])
            if new is None:
                pctl.multi_playlist[pctl.active_playlist_viewing][10] = ""
            else:
                if not pctl.multi_playlist[pctl.active_playlist_viewing][0].startswith("Artist:"):
                    pctl.multi_playlist[pctl.active_playlist_viewing][10] = ""
                else:
                    viewing_pl_id = pctl.multi_playlist[pctl.active_playlist_viewing][10]



        if viewing_pl_id in self.saves:
            self.current_artists = self.saves[viewing_pl_id][0]
            self.current_album_counts = self.saves[viewing_pl_id][1]
            self.scroll_position = self.saves[viewing_pl_id][2]

            if self.saves[viewing_pl_id][3] != len(pctl.multi_playlist[id_to_pl(viewing_pl_id)][2]):
                del self.saves[viewing_pl_id]
                return

        else:

            # if self.current_pl != viewing_pl_id:
            self.id_to_load = viewing_pl_id
            if not self.load:

                #self.prep()
                self.current_artists = []
                self.current_album_counts = []
                self.load = True


        area = (x, y, w, h)
        area2 = (x + 1, y, w - 3, h)

        ddt.rect_r(area, colours.side_panel_background, True)
        ddt.text_background_colour = colours.side_panel_background

        if coll(area) and mouse_wheel:
            self.scroll_position -= mouse_wheel
        if self.scroll_position < 0:
            self.scroll_position = 0

        range = (h // self.tab_h) - 1

        whole_rage = math.floor(h // self.tab_h)

        if range > 4 and self.scroll_position > len(self.current_artists) - range:
            self.scroll_position = len(self.current_artists) - range

        if len(self.current_artists) <= whole_rage :
            self.scroll_position = 0

        fields.add(area2)
        scroll_x = x + w - 18 * gui.scale
        if colours.lm:
            scroll_x = x + w - 22 * gui.scale
        if (coll(area2) or artist_list_scroll.held) and not pref_box.enabled:
            self.scroll_position = artist_list_scroll.draw(scroll_x, y + 1, 15 * gui.scale, h, self.scroll_position, len(self.current_artists) - range, r_click=right_click, jump_distance=1)

        if not self.current_artists:
            text = _("No artists in playlist")

            if default_playlist:
                text = _("Artist threshold not met")
            if self.load:
                text = _("Loading...")
                if loading_in_progress or transcode_list:
                    text = _("Busy...")

            ddt.draw_text((4 * gui.scale + w // 2, y + (h // 7), 2), text, alpha_mod(colours.side_bar_line2, 100), 212)

        yy = y + 12 * gui.scale

        i = int(self.scroll_position)

        if viewing_pl_id in self.saves:
            self.saves[viewing_pl_id][2] = self.scroll_position

        prefetch_mode = False
        prefetch_distance = 22

        for i, artist in enumerate(self.current_artists[i:], start=i):

            if not prefetch_mode:
                self.draw_card(artist, x, yy, w)


                yy += self.tab_h

                if yy > h:
                    prefetch_mode = True
                    continue

            if prefetch_mode:
                prefetch_distance -= 1
                if prefetch_distance < 1:
                    break
                if artist not in self.thumb_cache:
                    self.load_img(artist)
                    break


artist_list_box = ArtistList()






def queue_pause_deco():

    if pctl.pause_queue:
        return [colours.menu_text, colours.menu_background, _("Resume Queue")]
    else:
        return [colours.menu_text, colours.menu_background, _('Pause Queue')]


# def finish_current_deco():
#
#     colour = colours.menu_text
#     line = "Finish Playing Album"
#
#     if pctl.playing_object() is None:
#         colour = colours.menu_text_disabled
#     if pctl.force_queue and pctl.force_queue[0][4] == 1:
#         colour = colours.menu_text_disabled
#
#     return [colour, colours.menu_background, line]

class QueueBox:

    def __init__(self):

        self.dragging = None
        self.fq = []
        self.drag_start_y = 0
        self.drag_start_top = 0
        self.tab_h = 34 * gui.scale
        self.scroll_position = 0
        self.right_click_id = None
        self.d_click_ref = None
        self.bg = [25, 25, 25, 255]
        self.card_bg = [23, 23, 23, 255]

        queue_menu.add(_("Remove This"), self.right_remove_item, show_test=self.queue_remove_show)
        queue_menu.add(_("Play Now"), self.play_now, show_test=self.queue_remove_show)
        queue_menu.add("Auto-Stop After", self.toggle_auto_stop, self.toggle_auto_stop_deco, show_test=self.queue_remove_show)

        queue_menu.add("Pause Queue", self.toggle_pause, queue_pause_deco)
        queue_menu.add(_("Clear Queue"), clear_queue)

        queue_menu.add(_("â³ Except for This"), self.clear_queue_crop, show_test=self.queue_remove_show)
        # queue_menu.add("Finish Playing Album", finish_current, finish_current_deco)

    def clear_queue_crop(self):

        save = False
        for item in pctl.force_queue:
            if item[5] == self.right_click_id:
                save = item
                break

        clear_queue()
        if save:
            pctl.force_queue.append(save)

    def play_now(self):

        queue_item = None
        queue_index = 0
        for i, item in enumerate(pctl.force_queue):
            if item[5] == self.right_click_id:
                queue_item = item
                queue_index = i
                break
        else:
            return

        del pctl.force_queue[queue_index]
        # [trackid, position, pl_id, type, album_stage, uid_gen(), auto_stop]

        if pctl.force_queue and pctl.force_queue[0][4] == 1:
            split_queue_album(None)

        target_track_id = queue_item[0]

        pl = id_to_pl(queue_item[2])
        if pl is not None:
            pctl.active_playlist_playing = pl

        if target_track_id not in pctl.playing_playlist():
            pctl.advance(nolock=True)
            return

        pctl.jump(target_track_id, queue_item[1])

        if queue_item[3] == 1:  # is album type
            queue_item[4] = 1  # set as partway playing
            pctl.force_queue.insert(0, queue_item)


    def toggle_auto_stop(self):

        for item in pctl.force_queue:
            if item[5] == self.right_click_id:
                item[6] ^= True
                break

    def toggle_auto_stop_deco(self):

        enabled = False
        for item in pctl.force_queue:
            if item[5] == self.right_click_id:
                if item[6]:
                    enabled = True
                    break

        if enabled:
            return [colours.menu_text, colours.menu_background, _("Cancel Auto-Stop")]
        else:
            return [colours.menu_text, colours.menu_background, _('Auto-Stop After')]

    def queue_remove_show(self, id):

        if self.right_click_id is not None:
            return True
        return False

    def right_remove_item(self):

        if self.right_click_id is None:
            show_message("Eh?")

        for u in reversed(range(len(pctl.force_queue))):
            if pctl.force_queue[u][5] == self.right_click_id:
                del pctl.force_queue[u]
                gui.pl_update += 1
                break
        else:
            show_message("Looks like it's gone now anyway")

    def toggle_pause(self):

        pctl.pause_queue ^= True

    def draw_card(self, x, y, w, h, yy, track, fqo, draw_back=False):

        text_colour = [230, 230, 230, 255]
        bg = self.bg

        # if fq[i][3] == 0:

        rect = (x + 13 * gui.scale, yy, w - 28 * gui.scale, self.tab_h)

        if draw_back:
            ddt.rect_r(rect, self.card_bg, True)
            bg = self.card_bg

        gall_ren.render(track.index, (rect[0] + 4 * gui.scale, rect[1] + 4 * gui.scale), round(28 * gui.scale))

        ddt.rect_r((rect[0] + 4 * gui.scale, rect[1] + 4 * gui.scale, 26, 26), [0, 0, 0, 6], True)

        line = track.album
        if fqo[3] == 0:
            line = track.title

        if not line:
            line = track.filename

        line2y = yy + 14 * gui.scale

        artist_line = track.artist
        if fqo[3] == 1 and track.album_artist:
            artist_line = track.album_artist

        if fqo[3] == 0 and not artist_line:
            line2y -= 7 * gui.scale

        ddt.draw_text((rect[0] + (40 * gui.scale), yy - 1 * gui.scale), artist_line, [90, 90, 90, 255], 210,
                      max_w=rect[2] - 60 * gui.scale, bg=bg)

        ddt.draw_text((rect[0] + (40 * gui.scale), line2y), line, text_colour, 211,
                      max_w=rect[2] - 60 * gui.scale, bg=bg)

        if fqo[3] == 1:
            if fqo[4] == 0:
                ddt.rect_r((rect[0] + rect[2] - 5 * gui.scale, rect[1], 5 * gui.scale, rect[3]), [220, 130, 20, 255],
                           True)
            else:
                ddt.rect_r((rect[0] + rect[2] - 5 * gui.scale, rect[1], 5 * gui.scale, rect[3]),
                           [140, 220, 20, 255], True)

        if fqo[6]:
            xx = rect[0] + rect[2] - 9 * gui.scale
            if fqo[3] == 1:
                xx -= 11 * gui.scale
            ddt.rect_r((xx, rect[1] + 5 * gui.scale, 7 * gui.scale, 7 * gui.scale), [230, 190, 0, 255], True)

    def draw(self, x, y, w, h):


        yy = y

        yy += 4 * gui.scale

        if not colours.lm:
            # Draw top accent
            # if not pctl.force_queue:
            #     ddt.rect_r((x, y, w, 5 * gui.scale), colours.side_panel_background, True)
            #     ddt.rect_r((x, y, w, 3 * gui.scale), [30, 30, 30, 255], True)
            # else:
            ddt.rect_r((x, y, w, 3 * gui.scale), self.bg, True)
        else:
            gui.queue_frame_draw = y

        yy += 3 * gui.scale

        box_rect = (x, yy - 3 * gui.scale, w, h)

        qb_right_click = 0

        if coll(box_rect):
            # Update scroll position
            self.scroll_position += mouse_wheel * -1
            if self.scroll_position < 0:
                self.scroll_position = 0

            if right_click:
                qb_right_click = 1

        # Draw background
        #if not pctl.force_queue:
        #    ddt.rect_r(box_rect, colours.side_panel_background, True)
        #else:
        ddt.rect_r(box_rect, [18, 18, 18, 255], True)

        ddt.text_background_colour = [18, 18, 18, 255]
        line = "Up Next:"
        if pctl.force_queue:
            #line = "Queue"
            ddt.draw_text((x + (10 * gui.scale), yy + 2 * gui.scale), line, [100, 100, 100, 255], 211)

        yy += 7 * gui.scale

        if len(pctl.force_queue) < 3:
            self.scroll_position = 0

        # Draw square dots to indicate view has been scrolled down
        if self.scroll_position > 0:

            ds = 3 * gui.scale
            gp = 4 * gui.scale

            ddt.rect_r((x + int(w / 2), yy, ds, ds), [230, 190, 0, 255], True)
            ddt.rect_r((x + int(w / 2), yy + gp, ds, ds), [230, 190, 0, 255], True)
            ddt.rect_r((x + int(w / 2), yy + gp + gp, ds, ds), [230, 190, 0, 255], True)

        # Draw pause icon
        if pctl.pause_queue:
            ddt.rect_r((x + w - 24 * gui.scale, yy + 2 * gui.scale, 3 * gui.scale, 9 * gui.scale), [230, 190, 0, 255], True)
            ddt.rect_r((x + w - 19 * gui.scale, yy + 2 * gui.scale, 3 * gui.scale, 9 * gui.scale), [230, 190, 0, 255], True)

        yy += 6 * gui.scale

        yy += 10 * gui.scale

        i = 0

        # Get new copy of queue if not dragging
        if not self.dragging:
            self.fq = copy.deepcopy(pctl.force_queue)

        # End drag if mouse not in correct state for it
        if not mouse_down and not mouse_up:
            self.dragging = None

        if not queue_menu.active:
            self.right_click_id = None

        fq = self.fq

        list_top = yy

        i = self.scroll_position

        # Limit scroll distance
        if i > len(fq):
            self.scroll_position = len(fq)
            i = self.scroll_position

        while i < len(fq) + 1:

            # Stop drawing if past window
            if yy > window_size[1] - gui.panelBY - gui.panelY - (50 * gui.scale):
                break

            # Calculate drag collision box. Special case for first and last which extend out in y direction
            h_rect = (x + 13 * gui.scale, yy, w - 28 * gui.scale, self.tab_h + 3 * gui.scale)
            if i == len(fq):
                h_rect = (x + 13 * gui.scale, yy, w - 28 * gui.scale, self.tab_h + 3 * gui.scale + 1000 * gui.scale)
            if i == 0:
                h_rect = (0, yy - 1000 * gui.scale, w - 28 * gui.scale + 10000, self.tab_h + 3 * gui.scale + 1000 * gui.scale)


            if self.dragging is not None and coll(h_rect) and mouse_up:

                ob = None
                for u in reversed(range(len(pctl.force_queue))):

                    if pctl.force_queue[u][5] == self.dragging:
                        ob = pctl.force_queue[u]
                        pctl.force_queue[u] = None
                        break

                else:
                    self.dragging = None

                if self.dragging:
                    pctl.force_queue.insert(i, ob)
                    self.dragging = None

                for u in reversed(range(len(pctl.force_queue))):
                    if pctl.force_queue[u] is None:
                        del pctl.force_queue[u]
                        gui.pl_update += 1
                        continue

                    # Reset album in flag if not first item
                    if pctl.force_queue[u][4] == 1:
                        if u != 0:
                            pctl.force_queue[u][4] = 0

                input.mouse_click = False
                self.draw(x, y, w, h)
                return

            if i > len(fq) - 1:
                break

            track = pctl.g(fq[i][0])


            if self.dragging and coll(h_rect):
                yy += self.tab_h
                yy += 4 * gui.scale

            rect = (x + 13 * gui.scale, yy, w - 28 * gui.scale, self.tab_h)

            if input.mouse_click and coll(rect):

                self.dragging = fq[i][5]
                self.drag_start_y = mouse_position[1]
                self.drag_start_top = yy

                if d_click_timer.get() < 1:

                    if self.d_click_ref == fq[i][5]:

                        pl = id_to_pl(fq[i][5])
                        if pl is not None:
                            switch_playlist(pl)

                        pctl.show_current(playing=False, highlight=True, index=fq[i][0])
                        self.d_click_ref = None
                #else:
                self.d_click_ref = fq[i][5]

                d_click_timer.set()


            if qb_right_click and coll(rect):
                self.right_click_id = fq[i][5]
                qb_right_click = 2

            if middle_click and coll(rect):

                pctl.force_queue.remove(fq[i])
                gui.pl_update += 1

            if fq[i][5] == self.dragging:
                # ddt.rect_r(rect, [22, 22, 22, 255], True)
                pass
            else:

                db = False
                if fq[i][5] == self.right_click_id:
                    db = True

                self.draw_card(x, y, w, h, yy, track, fq[i], db)
                yy += self.tab_h
                yy += 4 * gui.scale

            i += 1

        yy += 15 * gui.scale
        if fq:
            ddt.rect_r((x, yy, w, 3 * gui.scale), self.bg, True)
        yy += 11 * gui.scale


        #duration = sum(s[7] for s in fq)
        duration = 0
        tracks = 0

        for item in fq:
            if item[3] == 0:
                duration += pctl.g(item[0]).length
                tracks += 1
            else:
                pl = id_to_pl(item[2])
                if pl is not None:
                    playlist = pctl.multi_playlist[pl][2]
                    i = item[1]


                    album_parent_path = pctl.g(item[0]).parent_folder_path

                    playing_track = pctl.playing_object()

                    if pl == pctl.active_playlist_playing and item[4] and playing_track and playing_track.parent_folder_path == album_parent_path:
                        i = pctl.playlist_playing_position + 1
                    elif playlist[i] != item[0] and item[0] in playlist:
                        i = playlist.index(item[0])

                    while i < len(playlist):
                        if pctl.g(playlist[i]).parent_folder_path != album_parent_path:
                            break

                        duration += pctl.g(playlist[i]).length
                        tracks += 1
                        i += 1

        if tracks and fq:
            plural = 's'
            if tracks < 2:
                plural = ''

            line = str(tracks) + " Track" + plural + " [" + get_hms_time(duration) + "]"
            ddt.draw_text((x + 12 * gui.scale, yy), line, [100, 100, 100, 255], 11.5, bg=[18, 18, 18, 255])


        if self.dragging:

            fqo = None
            for item in fq:
                if item[5] == self.dragging:
                    fqo = item
                    break
            else:
                self.dragging = False

            if self.dragging:
                yyy = self.drag_start_top + (mouse_position[1] - self.drag_start_y)
                if yyy < list_top:
                    yyy = list_top
                track = pctl.g(fqo[0])
                self.draw_card(x, y, w, h, yyy, track, fqo, draw_back=True)

        # Drag and drop tracks from main playlist into queue
        if quick_drag and mouse_up and coll(box_rect) and shift_selection:

            pp = shift_selection[0]
            ti = default_playlist[pp]

            if len(shift_selection) == 1:
                #pctl.force_queue.append([ti, pp, pl_to_id(pctl.active_playlist_viewing), 0, 0, uid_gen()])
                pctl.force_queue.append(queue_item_gen(ti, pp, pl_to_id(pctl.active_playlist_viewing)))
            else:
                # pctl.force_queue.append([ti, pp, pl_to_id(pctl.active_playlist_viewing), 1, 0, uid_gen()])
                pctl.force_queue.append(queue_item_gen(ti, pp, pl_to_id(pctl.active_playlist_viewing), 1))

        # Right click context menu in blank space
        if qb_right_click:
            if qb_right_click == 1:
                self.right_click_id = None
            queue_menu.activate(position=mouse_position)



queue_box = QueueBox()

class MetaBox:

    def draw(self, x, y, w ,h):

        if not pctl.playing_ready():
            return
        track = pctl.playing_object()

        ddt.rect_r((x, y, w, h), colours.side_panel_background, True)

        # Test for show lyric menu on right ckick
        if coll((x + 10, y, w - 10, h)):
            if right_click: # and 3 > pctl.playing_state > 0:
                gui.force_showcase_index = -1
                showcase_menu.activate(track)


        if pctl.playing_state == 0:
            if not prefs.meta_persists_stop and not prefs.meta_shows_selected and not prefs.meta_shows_selected_always:
                return

        if h < 15:
            return


        # Check for lyrics if auto setting
        test_auto_lyrics(track)

        # Draw lyrics if avaliable
        if prefs.show_lyrics_side and pctl.track_queue \
                    and track.lyrics != "" and h > 45 * gui.scale and w > 200 * gui.scale:

            # Test for scroll wheel input
            if mouse_wheel != 0 and coll((x + 10, y, w - 10, h)):
                lyrics_ren_mini.lyrics_position += mouse_wheel * 30 * gui.scale
                if lyrics_ren_mini.lyrics_position > 0:
                    lyrics_ren_mini.lyrics_position = 0
                    lyric_side_top_pulse.pulse()

                gui.update += 1


            tw, th = ddt.get_text_wh(pctl.master_library[pctl.track_queue[pctl.queue_step]].lyrics + "\n", 15, w - 50 * gui.scale, True)

            oth = th

            th -= h
            th += 25 * gui.scale  # Empty space buffer at end

            if lyrics_ren_mini.lyrics_position * -1 > th:
                lyrics_ren_mini.lyrics_position = th * -1
                if oth > h:
                    lyric_side_bottom_pulse.pulse()

            scroll_w = 15 * gui.scale
            if gui.maximized:
                scroll_w = 17 * gui.scale

            lyrics_ren_mini.lyrics_position = mini_lyrics_scroll.draw(x + w - 17 * gui.scale, y, scroll_w, h, lyrics_ren_mini.lyrics_position * -1, th) * -1

            margin = 10 * gui.scale
            if colours.lm:
                margin += 1 * gui.scale

            lh = lyrics_ren_mini.render(pctl.track_queue[pctl.queue_step], x + margin,
                                   y + lyrics_ren_mini.lyrics_position + 11 * gui.scale,
                                   w - 50 * gui.scale,
                                   None, 0)

            ddt.rect_r((x, y + h - 1, w,
                         1), colours.side_panel_background, True)

            lyric_side_top_pulse.render(x, y, (w - 9 - margin) * gui.scale, 2 * gui.scale)
            lyric_side_bottom_pulse.render(x, y + h - 2 * gui.scale, w - 17 * gui.scale, 2 * gui.scale)


        # Draw standard metadata
        elif len(pctl.track_queue) > 0:

            if pctl.playing_state == 0:
                if not prefs.meta_persists_stop and not prefs.meta_shows_selected and not prefs.meta_shows_selected_always:
                    return

            ddt.text_background_colour = colours.side_panel_background

            if coll((x + 10, y, w - 10, h)):
                # Click area to jump to current track
                if input.mouse_click:
                    pctl.show_current()
                    gui.update += 1


            title = ""
            album = ""
            artist = ""
            ext = ""
            date = ""
            genre = ""

            margin = x + 10 * gui.scale
            if colours.lm:
                margin += 2 * gui.scale

            text_width = w - 25 * gui.scale
            tr = None

            if pctl.playing_state < 3:

                if pctl.playing_state == 0 and prefs.meta_persists_stop:
                    tr = pctl.master_library[pctl.track_queue[pctl.queue_step]]
                if pctl.playing_state == 0 and prefs.meta_shows_selected:

                    if -1 < playlist_selected < len(pctl.multi_playlist[pctl.active_playlist_viewing][2]):
                        tr = pctl.g(pctl.multi_playlist[pctl.active_playlist_viewing][2][playlist_selected])

                if prefs.meta_shows_selected_always:
                    if -1 < playlist_selected < len(pctl.multi_playlist[pctl.active_playlist_viewing][2]):
                        tr = pctl.g(pctl.multi_playlist[pctl.active_playlist_viewing][2][playlist_selected])

                if tr is None:
                    tr = pctl.playing_object()
                if tr is None:
                    return

                title = tr.title
                album = tr.album
                artist = tr.artist
                ext = tr.file_ext
                if tr.lyrics:
                    ext += ","
                date = tr.date
                genre = tr.genre
            else:
                title = pctl.tag_meta

            if h > 58 * gui.scale:

                block_y = y + 7 * gui.scale

                if not prefs.show_side_art:
                    block_y += 3 * gui.scale

                if title != "":
                    ddt.draw_text((margin, block_y + 2 * gui.scale), title, colours.side_bar_line1, fonts.side_panel_line1, max_w=text_width)
                if artist != "":
                    ddt.draw_text((margin, block_y + 23 * gui.scale), artist, colours.side_bar_line2, fonts.side_panel_line2, max_w=text_width)

                if h > 140 * gui.scale:

                    block_y = y + 80 * gui.scale
                    if artist != "":
                        ddt.draw_text((margin, block_y), album, colours.side_bar_line2,
                                  fonts.side_panel_line2, max_w=text_width)

                    if not genre == date == "":
                        line = date
                        if genre != "":
                            if line != "":
                                line += " | "
                            line += genre

                        ddt.draw_text((margin, block_y + 20 * gui.scale), line, colours.side_bar_line2,
                                  fonts.side_panel_line2, max_w=text_width)

                    if ext != "":

                        sp = ddt.draw_text((margin, block_y + 40 * gui.scale), ext, colours.side_bar_line2,
                                  fonts.side_panel_line2, max_w=text_width)

                        if tr and tr.lyrics:
                            if draw_internel_link(margin + sp + 6 * gui.scale, block_y + 40 * gui.scale, "Lyrics", colours.side_bar_line2, fonts.side_panel_line2):
                                prefs.show_lyrics_showcase = True
                                switch_showcase(tr.index)


meta_box = MetaBox()


class PictureRender:

    def __init__(self):
        self.show = False
        self.path = ""

        self.image_data = None
        self.texture = None
        self.sdl_rect = None



    def load(self, path, box_size=None):

        if not os.path.isfile(path):
            print("NO PICTURE FILE TO LOAD")
            return

        g = io.BytesIO()
        g.seek(0)

        im = Image.open(path)
        if box_size is not None:
            im.thumbnail((box_size, box_size), Image.ANTIALIAS)

        im.save(g, 'BMP')
        g.seek(0)
        self.image_data = g
        print("Save BMP to memory")

    def draw(self, x, y):

        if self.show is False:
            return

        if self.image_data is not None:
            if self.texture is not None:
                SDL_DestroyTexture(self.texture)

            # Convert raw image to sdl texture
            print("Create Texture")
            wop = rw_from_object(self.image_data)
            s_image = IMG_Load_RW(wop, 0)
            self.texture = SDL_CreateTextureFromSurface(renderer, s_image)
            SDL_FreeSurface(s_image)
            tex_w = pointer(c_int(0))
            tex_h = pointer(c_int(0))
            SDL_QueryTexture(self.texture, None, None, tex_w, tex_h)
            self.sdl_rect = SDL_Rect(round(x), round(y))
            self.sdl_rect.w = int(tex_w.contents.value)
            self.sdl_rect.h = int(tex_h.contents.value)
            self.image_data = None

        if self.texture is not None:
            self.sdl_rect.x = round(x)
            self.sdl_rect.y = round(y)
            SDL_RenderCopy(renderer, self.texture, None, self.sdl_rect)
            style_overlay.hole_punches.append(self.sdl_rect)

artist_picture_render = PictureRender()


class ArtistInfoBox:

    def __init__(self):
        self.artist_on = None
        self.min_rq_timer = Timer()
        self.min_rq_timer.force_set(10)

        self.text = ""

        self.status = ""

        self.scroll_y = 0

        self.process_text_artist = ""
        self.processed_text = ""
        self.th = 0
        self.w = 0
        self.lock = False

        self.mini_box = WhiteModImageAsset(asset_subfolder + "mini-box.png")


    def draw(self, x, y, w, h):

        if gui.artist_panel_height > 300 and w < 500 * gui.scale:
            bio_set_small()
            update_layout_do()

        if w < 300 * gui.scale:
            gui.artist_info_panel = False
            gui.update_layout()
            return

        if right_click and coll((x, y ,w, h)):
            artist_info_menu.activate()

        backgound = [27, 27, 27, 255]
        ddt.rect_r((x + 10, y + 5, w - 15, h - 5), backgound, True)

        track = pctl.playing_object()
        if track is None:
            return

        # Check if the artist has changed.
        artist = track.artist
        wait = False

        if artist != self.artist_on:
            if artist == "":
                return

            if self.min_rq_timer.get() < 5:  # Limit rate
                if os.path.isfile(os.path.join(cache_directory, artist + '-lfm.txt')):
                    pass
                else:
                    self.status = _("Cooldown...")
                    wait = True

            if pctl.playing_time < 0.5:
                if os.path.isfile(os.path.join(cache_directory, artist + '-lfm.txt')):
                    pass
                else:
                    self.status = "..."
                    wait = True

            if not wait and not self.lock:
                self.lock = True
                #self.min_rq_timer.set()

                self.scroll_y = 0
                self.status = _("Looking up...")

                shoot_dl = threading.Thread(target=self.get_data, args=([artist]))
                shoot_dl.daemon = True
                shoot_dl.start()


        if self.process_text_artist != self.artist_on:
            self.process_text_artist = self.artist_on

            text = self.text
            lic = ""
            link = ""

            if "<a" in text:
                text, ex = text.split('<a href="', 1)

                link, ex = ex.split('">', 1)

                lic = ex.split("</a>. ", 1)[1]

            text += "\n"

            self.urls = [(link, [200, 60, 60, 255], "L")]
            for word in text.replace("\n", " ").split(" "):
                if word.strip()[:4] == "http" or word.strip()[:4] == "www.":
                    word = word.rstrip(".")
                    if word.strip()[:4] == "www.":
                        word = "http://" + word
                    if 'bandcamp' in word:
                        self.urls.append((word.strip(), [200, 150, 70, 255], "B"))
                    elif 'soundcloud' in word:
                        self.urls.append((word.strip(), [220, 220, 70, 255], "S"))
                    elif 'twitter' in word:
                        self.urls.append((word.strip(), [80, 110, 230, 255], "T"))
                    elif 'facebook' in word:
                        self.urls.append((word.strip(), [60, 60, 230, 255], "F"))
                    elif 'youtube' in word:
                        self.urls.append((word.strip(), [210, 50, 50, 255], "Y"))
                    else:
                        self.urls.append((word.strip(), [120, 200, 60, 255], "W"))

            self.processed_text = text
            self.w = -1  # trigger text recalc

        if self.status == "Ready":

            # if self.w != w:
            #     tw, th = ddt.get_text_wh(self.processed_text, 14.5, w - 250 * gui.scale, True)
            #     self.th = th
            #     self.w = w

            text_max_w = w - gui.artist_panel_height - 55 * gui.scale

            if self.w != w:
                tw, th = ddt.get_text_wh(self.processed_text, 14.5, text_max_w - (text_max_w % 20), True)
                self.th = th
                self.w = w

            scroll_max = self.th - (h - 26)

            if coll((x, y, w, h)):
                self.scroll_y += mouse_wheel * -20
            if self.scroll_y < 0:
                self.scroll_y = 0
            if self.scroll_y > scroll_max:
                self.scroll_y = scroll_max

            right = x + w - 25 * gui.scale

            if self.th > h - 26:
                self.scroll_y = artist_info_scroll.draw(x + w - 20, y + 5, 15, h - 5,
                                                        self.scroll_y, scroll_max, True)
                right -= 15
                #text_max_w -= 15

            artist_picture_render.draw(x + 20 * gui.scale, y + 10 * gui.scale)
            ddt.draw_text((x + round(gui.artist_panel_height + 15 * gui.scale), y + 14 * gui.scale, 4, text_max_w - (text_max_w % 20), 14000), self.processed_text, [230, 230, 230, 255], 14.5, bg=backgound, range_height=h - 22 * gui.scale, range_top=self.scroll_y)

            yy = y + 12
            for item in self.urls:

                rect = (right - 2, yy - 2, 16, 16)

                fields.add(rect)
                self.mini_box.render(right, yy, alpha_mod(item[1], 100))
                if coll(rect):
                    if not input.mouse_click:
                        gui.cursor_want = 3
                    if input.mouse_click:
                        webbrowser.open(item[0], new=2, autoraise=True)
                    gui.pl_update += 1
                    w = ddt.get_text_w(item[0], 13)
                    xx = (right - w) - 17 * gui.scale
                    ddt.rect_r((xx - 10 * gui.scale, yy - 4 * gui.scale, w + 20 * gui.scale, 24 * gui.scale), [15, 15, 15, 255], True)
                    ddt.rect_r((xx - 10 * gui.scale, yy - 4 * gui.scale, w + 20 * gui.scale, 24 * gui.scale), [50, 50, 50, 255])

                    ddt.draw_text((xx, yy), item[0], [250, 250, 250, 255], 13, bg=[15, 15, 15, 255])
                    self.mini_box.render(right, yy, (item[1][0] + 20, item[1][1] + 20, item[1][2] + 20, 255))
                # ddt.rect_r(rect, [210, 80, 80, 255], True)

                yy += 19 * gui.scale

        else:
            ddt.draw_text((x + w // 2 , y + h // 2 - 7 * gui.scale , 2), self.status, [80, 80, 80, 255], 313, bg=backgound)


    def get_data(self, artist):

        print("Load Bio Data")

        if artist is None:
            self.artist_on = artist
            self.lock = False
            return

        #filename = artist + '-lfm.png'
        img_filename = artist + '-ftv-full.jpg'
        text_filename = artist + '-lfm.txt'
        img_filepath_lfm = os.path.join(cache_directory, artist + '-lfm.png')
        img_filepath_dcg = os.path.join(cache_directory, artist + '-dcg.jpg')
        img_filepath = os.path.join(cache_directory, img_filename)
        text_filepath = os.path.join(cache_directory, text_filename)

        # Check for cache
        try:

            if os.path.isfile(text_filepath):
                print("Load cached bio and image")

                artist_picture_render.show = False

                if os.path.isfile(os.path.join(user_directory, "artist-pictures/" + artist + ".png")):
                    filepath = os.path.join(user_directory, "artist-pictures/" + artist + ".png")
                    artist_picture_render.load(filepath, round(gui.artist_panel_height - 20 * gui.scale))
                    artist_picture_render.show = True

                elif os.path.isfile(os.path.join(user_directory, "artist-pictures/" + artist + ".jpg")):
                    filepath = os.path.join(user_directory, "artist-pictures/" + artist + ".jpg")
                    artist_picture_render.load(filepath, round(gui.artist_panel_height - 20 * gui.scale))
                    artist_picture_render.show = True

                elif os.path.isfile(img_filepath):
                    artist_picture_render.load(img_filepath, round(gui.artist_panel_height - 20 * gui.scale))
                    artist_picture_render.show = True

                elif os.path.isfile(img_filepath_dcg):
                    artist_picture_render.load(img_filepath_dcg, round(gui.artist_panel_height - 20 * gui.scale))
                    artist_picture_render.show = True

                elif os.path.isfile(img_filepath_lfm):
                    artist_picture_render.load(img_filepath_lfm, round(gui.artist_panel_height - 20 * gui.scale))
                    artist_picture_render.show = True

                with open(text_filepath, encoding="utf-8") as f:
                    self.text = f.read()
                self.status = "Ready"
                gui.update = 2
                self.artist_on = artist
                self.lock = False

                return

            # Get new from last.fm
            data = lastfm.artist_info(artist)
            if data[0] is False:
                self.text = ""
                artist_picture_render.show = False
                self.status = _("No artist bio found")
                self.artist_on = artist
                self.lock = False
                return
            else:
                self.text = data[1]
                #cover_link = data[2]
                # Save text as file
                f = open(text_filepath, 'w', encoding='utf-8')
                f.write(self.text)
                f.close()
                print("save bio text")

                artist_picture_render.show = False
                if data[3]:
                    try:
                        save_fanart_artist_thumb(data[3], img_filepath)
                        artist_picture_render.load(img_filepath, round(gui.artist_panel_height - 20 * gui.scale))
                        artist_picture_render.show = True
                    except:
                        print("Failed to find image from fanart.tv")
                if not artist_picture_render.show:
                    if verify_discogs():
                        try:
                            save_discogs_artist_thumb(artist, img_filepath_dcg)
                            artist_picture_render.load(img_filepath_dcg, round(gui.artist_panel_height - 20 * gui.scale))
                            artist_picture_render.show = True
                        except:
                            print("Failed to find image from discogs")

                self.status = "Ready"
                gui.update = 2


            # if cover_link and 'http' in cover_link:
            #     # Fetch cover_link
            #     try:
            #         # print("Fetching artist image...")
            #         response = urllib.request.urlopen(cover_link)
            #         info = response.info()
            #         # print("got response")
            #         if info.get_content_maintype() == 'image':
            #
            #             f = open(filepath, 'wb')
            #             f.write(response.read())
            #             f.close()
            #
            #             # print("written file, now loading...")
            #
            #             artist_picture_render.load(filepath, round(gui.artist_panel_height - 20 * gui.scale))
            #             artist_picture_render.show = True
            #
            #             self.status = "Ready"
            #             gui.update = 2
            #     # except HTTPError as e:
            #     #     self.status = e
            #     #     print("request failed")
            #     except:
            #         print("request failed")
            #         self.status = "Request Failed"


        except:
            self.status = "Load Failed"

        self.artist_on = artist
        self.min_rq_timer.set()
        self.lock = False


# artist info box def
artist_info_box = ArtistInfoBox()



class GuitarChords:

    def __init__(self):
        self.store_a = os.path.join(user_directory, "guitar-chords-a")  # inline format
        self.store_b = os.path.join(user_directory, "guitar-chords-b")  # 2 lines format

        self.data = []
        self.current = ""
        self.auto_scroll = True

        self.scroll_position = 0

        self.ready = {}

        self.widespace = "ã"


    def clear(self, track):

        cache_title = self.get_cache_title(track)
        self.prep_folders()
        self.current = ""
        self.scroll_position = 0

        self.ready[cache_title] = 0

        for item in os.listdir(self.store_a):
            if item == cache_title:
                os.remove(os.path.join(self.store_a, cache_title))

        for item in os.listdir(self.store_b):
            if item == cache_title:
                os.remove(os.path.join(self.store_b, cache_title))


    def save_format_b(self, track):

        t = copy_from_clipboard()
        if not t:
            show_message("Clipboard has no text")
            input.mouse_click = False
            return

        cache_title = self.get_cache_title(track)

        t = t.replace("\r", "")

        f = open(os.path.join(self.store_b, cache_title), 'w')
        f.write(t)
        f.close()


    def parse_b(self, lines):

        final = []

        last = ""

        for line in lines:


            if line == " " or line == "" or line == "\n":
                line = "                                          "

            line = line.replace("\n", "")
            line = line.replace("\r", "")

            if not last and (len(line) < 6 or \
                    "    " in line \
                    or "D " in line \
                    or "Am " in line \
                    or "Fm" in line \
                    or "Em " in line \
                    or "C " in line \
                    or "G " in line \
                    or "F " in line \
                    or "Dm" in line) and any(c.isalpha() for c in line):

                last = line
                continue

            w = list(line)
            for i, c in enumerate(w):
                if i > 0 and c == " ":
                    if w[i - 1] == " " or w[i - 1] == self.widespace:
                        w[i - 1] = self.widespace
                        w[i] = self.widespace
            line = "".join(w)

            if not last:
                final.append((line, []))
                continue


            on = 0
            mode = 0
            distance = 0
            chords = []

            while on < len(last):


                if mode == 0:
                    if last[on] == " ":
                        on += 1
                        continue
                    mode = 1
                    distance = ddt.get_text_w(line[:on], 16)

                on2 = on
                while on2 < len(last) and last[on2] != " ":
                    on2 += 1

                grab = last[on:on2]

                chords.append((grab, distance))
                mode = 0
                on = on2
                on += 1


            final.append((line, chords))
            last = ""
        self.data = final



    def prep_folders(self):

        if not os.path.exists(self.store_a):
            os.makedirs(self.store_a)

        if not os.path.exists(self.store_b):
            os.makedirs(self.store_b)

    def fetch(self, track):

        if track is None:
            return

        if self.test_ready_status(track) != 0:
            return

        cache_title = self.get_cache_title(track)

        try:

            r = requests.get('http://api.guitarparty.com/v2/songs/?query=' + urllib.parse.quote(cache_title), headers={"Guitarparty-Api-Key":"e9c0e543798c4249c24f698022ced5dd0c583ec7"})
            d = r.json()['objects'][0]['body']

            self.prep_folders()
            f = open(os.path.join(self.store_a, cache_title), "w")
            f.write(d)
            f.close()

            self.ready[cache_title] = 1

        except:
            show_message("Could not find matching track on GuitarParty")
            input.mouse_click = False
            self.ready[cache_title] = 2

    def test_ready_status(self, track):

        # 0 not searched
        # 1 ready
        # 2 failed

        cache_title = self.get_cache_title(track)

        if cache_title in self.ready:
            if self.ready[cache_title] == 1:
                return 1
            if self.ready[cache_title] == 2:
                return 2
            return 0


        self.prep_folders()
        if cache_title in os.listdir(self.store_a):
            self.ready[cache_title] = 1
            return 1
        if cache_title in os.listdir(self.store_b):
            self.ready[cache_title] = 1
            return 1
        else:
            self.ready[cache_title] = 0
            return 0



    def parse(self, lines):

        final = []

        for line in lines:
            line = line.rstrip()
            #while "  " in line:
            #line = line.replace("  ", "ãã")
            w = list(line)

            for i, c in enumerate(w):
                if i > 0 and c == " ":

                    if w[i - 1] == " " or w[i - 1] == self.widespace:
                        w[i - 1] = self.widespace
                        w[i] = self.widespace

            lyrics = []
            chords = []

            on = 0
            mode = 0

            chord_part = []

            while on < len(w):
                if mode == 0:
                    # If normal, add to lyric list
                    if w[on] != "[":
                        lyrics.append(w[on])
                        on += 1
                        continue

                    # Start of [, delete it
                    mode = 1
                    del w[on]
                    continue

                if w[on] == "]":
                    del w[on]
                    mode = 0

                    distance = 0
                    if on > 0:

                        distance = ddt.get_text_w("".join(w[:on]), 16)

                    chords.append(("".join(chord_part), distance))
                    chord_part = []
                    continue

                chord_part.append(w[on])
                del w[on]

            final.append(("".join(lyrics), chords))


        print(final)
        self.data = final

    def get_cache_title(self, track):

        name = track.artist + " " + track.title
        for char in name:
            if char in '\\/:*?"<>|':
                name = name.replace(char, '_')
        return name


    def render(self, track, x, y):

        cache_title = self.get_cache_title(track)

        if self.current == cache_title:
            if not self.data:
                return False
        else:
            self.prep_folders()
            if cache_title in os.listdir(self.store_a):
                f = open(os.path.join(self.store_a, cache_title))
                lines = f.readlines()
                f.close()
                self.parse(lines)
                self.current = cache_title
                self.scroll_position = 0

            elif cache_title in os.listdir(self.store_b):
                f = open(os.path.join(self.store_b, cache_title))
                lines = f.readlines()
                f.close()
                self.parse_b(lines)
                self.current = cache_title
                self.scroll_position = 0
            else:
                return False


        if self.auto_scroll:

            if pctl.playing_length > 20:
                progress = max(0, pctl.playing_time - 12) / (pctl.playing_length - 3)
                height = len(self.data) * (18 + 15) * gui.scale

                self.scroll_position = height * progress
                #gui.update += 1
                gui.frame_callback_list.append(TestTimer(0.3))
                #time.sleep(0.032)



        if mouse_wheel and gui.panelY < mouse_position[1] < window_size[1] - gui.panelBY:
            self.scroll_position += int(mouse_wheel * 30 * gui.scale * -1)
            self.auto_scroll = False
        y = y - self.scroll_position

        if self.data:

            self.ready[cache_title] = 1

            for line in self.data:

                if window_size[0] > y > 0:
                    min_space = 0
                    for ch in line[1]:
                        xx = max(x + ch[1], min_space)

                        if len(ch[0]) == 2 and ch[0][1].lower() == "x":
                            min_space = 1 + xx + ddt.draw_text((xx, y), ch[0], [220, 120, 240, 255], 214)
                        else:
                            min_space = 1 + xx + ddt.draw_text((xx, y), ch[0], [140, 120, 240, 255], 213)
                y += 15 * gui.scale

                if window_size[0] > y > 0:
                    colour = colours.lyrics
                    if colours.lm:
                        colour = [30, 30, 30, 255]
                    ddt.draw_text((x,y), line[0], colour, 16)

                y += 18 * gui.scale

            return True
        return False

# guitar chords def
gc = GuitarChords()



class Showcase:

    def __init__(self):

        self.lastfm_artist = None
        self.artist_mode = False


    # def get_artist_info(self):
    #
    #     track = pctl.playing_object()
    #     if track is not None:
    #         artist = track.artist

    def render(self):

        ddt.rect_r((0, gui.panelY, window_size[0], window_size[1] - gui.panelY), colours.playlist_panel_background, True)

        # album_art_gen.display_blur(pctl.playing_object().index, [200, 200])

        # ddt.rect_r((0, gui.panelY, window_size[0], window_size[1] - gui.panelY), [0,0,0,100], True)

        box = int(window_size[1] * 0.4 + 120 * gui.scale)
        x = int(window_size[0] * 0.15)
        y = int((window_size[1] / 2) - (box / 2)) - 10 * gui.scale

        bbg = colours.grey(30)
        bfg = colours.grey(40)
        bft = colours.grey(235)
        bbt = colours.grey(200)

        t1 = colours.grey(250)
        #gui.vis_4_colour = [140, 110, 200, 255]
        gui.vis_4_colour = None

        if colours.lm:
            bbg = colours.vis_colour
            bfg = alpha_blend([255, 255, 255, 60], colours.vis_colour)
            bft = colours.grey(250)
            bbt = colours.grey(245)
            #gui.vis_4_colour = [40, 40, 40, 255]

        if test_lumi(colours.playlist_panel_background) < 0.7:

            t1 = colours.grey(30)
            #gui.vis_4_colour = [180, 160, 250, 255]
            gui.vis_4_colour = [40, 40, 40, 255]


        if draw.button("Return", 25 * gui.scale, window_size[1] - gui.panelBY - 40 * gui.scale, bg=bbg, fg=bfg, fore_text=bft, back_text=bbt):
            switch_showcase()
            if gui.lyrics_was_album:
                force_album_view()
            return 0

        if pctl.playing_state == 3:

            w = window_size[0] - (x + box) - 30 * gui.scale
            x = int((window_size[0]) / 2)

            y = int(window_size[1] / 2) - 60 - gui.scale
            ddt.draw_text((x, y, 2), pctl.tag_meta, colours.side_bar_line1, 216, w)


        else:

            if len(pctl.track_queue) < 1:
                return

            # if draw.button("Return", 20, gui.panelY + 5, bg=colours.grey(30)):
            #     pass

            if gui.force_showcase_index >= 0:
                if draw.button("Show playing", 25 * gui.scale, gui.panelY + 20 * gui.scale, bg=bbg, fg=bfg, fore_text=bft, back_text=bbt):
                    gui.force_showcase_index = -1


            if gui.force_showcase_index >= 0:
                index = gui.force_showcase_index
                track = pctl.master_library[index]
            else:
                index = pctl.track_queue[pctl.queue_step]
                track = pctl.master_library[pctl.track_queue[pctl.queue_step]]


            album_art_gen.display(index, (x, y), (box, box))
            if coll((x, y, box, box)) and input.mouse_click is True:
                album_art_gen.cycle_offset(index)

            # Check for lyrics if auto setting
            test_auto_lyrics(track)

            gui.draw_vis4_top = False

            if gui.panelY < mouse_position[1] < window_size[1] - gui.panelBY:
                if mouse_wheel != 0:
                    lyrics_ren.lyrics_position += mouse_wheel * 35 * gui.scale
                if right_click:
                    # track = pctl.playing_object()
                    if track != None:
                        showcase_menu.activate(track)


            gcx = x + box + int(window_size[0] * 0.15) + 20 * gui.scale
            gcx -= 100 * gui.scale

            timed_ready = False
            if True and prefs.show_lyrics_showcase:
                timed_ready = timed_lyrics_ren.generate(track.index)

            if timed_ready and track.lyrics:

                if not prefs.guitar_chords or gc.test_ready_status(track) != 1:

                    line = "Prefer synced"
                    if prefs.prefer_synced_lyrics:
                        line = "Prefer static"
                    if draw.button(line, 25 * gui.scale, window_size[1] - gui.panelBY - 70 * gui.scale,
                                   bg=bbg, fg=bfg,
                                   fore_text=bft, back_text=bbt):
                        prefs.prefer_synced_lyrics ^= True

                timed_ready = prefs.prefer_synced_lyrics

            # elif not timed_ready:
            #
            #     if prefs.guitar_chords and track.title:
            #         if gc.test_ready_status(track) == 0:
            #             if draw.button("Query GuitarParty", 25 * gui.scale,
            #                            window_size[1] - gui.panelBY - 100 * gui.scale,
            #                            bg=bbg, fg=bfg,
            #                            fore_text=bft, back_text=bbt):
            #                 gc.fetch(track)


            if prefs.guitar_chords and track.title and prefs.show_lyrics_showcase and gc.render(track, gcx, y):

                if not gc.auto_scroll:
                    if draw.button("Auto-Scroll", 25 * gui.scale, window_size[1] - gui.panelBY - 70 * gui.scale, bg=bbg, fg=bfg,
                                   fore_text=bft, back_text=bbt):
                        gc.auto_scroll = True

            elif True and prefs.show_lyrics_showcase and timed_ready:

                timed_lyrics_ren.render(track.index, gcx, y)

            elif track.lyrics == "" or not prefs.show_lyrics_showcase:

                w = window_size[0] - (x + box) - round(30 * gui.scale)
                x = int(x + box + (window_size[0] - x - box) / 2)
                #x = int((window_size[0]) / 2)
                y = int(window_size[1] / 2) - round(60 * gui.scale)

                if prefs.showcase_vis and prefs.backend == 1:
                    y -= round(30 * gui.scale)

                # ddt.pretty_rect = (300, 100, window_size[0], window_size[1] - gui.panelBY)

                if track.artist == "" and track.title == "":

                    ddt.draw_text((x, y, 2), track.filename, t1, 216, w)

                else:

                    ddt.draw_text((x, y, 2), track.artist, t1, 17, w)

                    y += round(45 * gui.scale)

                    if len(track.title) < 35:
                        ddt.draw_text((x, y, 2), track.title, t1, 228, w)
                    elif len(track.title) < 50:
                        ddt.draw_text((x, y, 2), track.title, t1, 219, w)
                    else:
                        ddt.draw_text((x, y, 2), track.title, t1, 218, w)

                gui.spec4_rec.x = x - (gui.spec4_rec.w // 2)
                gui.spec4_rec.y = y + round(50 * gui.scale)


                # ddt.pretty_rect = None

                if prefs.showcase_vis and window_size[0] > 710 and window_size[1] > 369 and not search_over.active:

                    if showcase_menu.active or gui.message_box or pref_box.enabled:
                        self.render_vis()
                    else:
                        gui.draw_vis4_top = True


            else:

                x += box + int(window_size[0] * 0.15) + 20 * gui.scale
                x -= 100 * gui.scale
                w = window_size[0] - x - 30 * gui.scale


                if key_up_press:
                    lyrics_ren.lyrics_position += 35 * gui.scale
                if key_down_press:
                    lyrics_ren.lyrics_position -= 35 * gui.scale

                tw, th = ddt.get_text_wh(lyrics_ren.text + "\n", 17,
                                         w, True)

                if lyrics_ren.lyrics_position < th * -1 + 100 * gui.scale:
                    lyrics_ren.lyrics_position = th * -1 + 100 * gui.scale

                if lyrics_ren.lyrics_position > 50 * gui.scale:
                    lyrics_ren.lyrics_position = 50 * gui.scale


                lyrics_ren.render(index,
                                  x,
                                  y + lyrics_ren.lyrics_position,
                                  w,
                                  int(window_size[1] - 100 * gui.scale),
                                  0)



    def render_vis(self, top=False):

        SDL_SetRenderTarget(renderer, gui.spec4_tex)
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0)
        SDL_RenderClear(renderer)

        bx = 0
        by = 50 * gui.scale

        if gui.vis_4_colour is not None:
            SDL_SetRenderDrawColor(renderer, gui.vis_4_colour[0], gui.vis_4_colour[1], gui.vis_4_colour[2], gui.vis_4_colour[3])

        if (pctl.playing_time < 0.5 and pctl.playing_state == 1) or (pctl.playing_state == 0 and gui.spec4_array.count(0) != len(gui.spec4_array)):
            gui.update = 2
            gui.level_update = True

            for i in range(len(gui.spec4_array)):
                gui.spec4_array[i] -= 0.1
                if gui.spec4_array[i] < 0:
                    gui.spec4_array[i] = 0

        if not top and pctl.playing_state == 1:
            gui.update = 2

        slide = 0.7
        for i, bar in enumerate(gui.spec4_array):

            # We wont draw higher bars that may not move
            if i > 40:
                break

            # Scale input amplitude to pixel distance (Applying a slight exponentional)
            dis = (2 + math.pow(bar / (2 + slide), 1.5))
            slide -= 0.03  # Set a slight bias for higher bars

            # Define colour for bar
            if gui.vis_4_colour is None:
                set_colour(hsl_to_rgb(0.7 + min(0.15, (bar / 150)) + pctl.total_playtime / 300, min(0.9, 0.7 + (dis / 300)), min(0.9, 0.7 + (dis / 600))))

            # Define bar size and draw
            gui.bar4.x = int(bx)
            gui.bar4.y = round(by - dis * gui.scale)
            gui.bar4.w = round(2 * gui.scale)
            gui.bar4.h = round(dis * 2 * gui.scale)

            SDL_RenderFillRect(renderer, gui.bar4)

            # Set distance between bars
            bx += 8 * gui.scale

        if top:
            SDL_SetRenderTarget(renderer, None)
        else:
            SDL_SetRenderTarget(renderer, gui.main_texture)

        #SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND)
        SDL_RenderCopy(renderer, gui.spec4_tex, None, gui.spec4_rec)



showcase = Showcase()


# Animates colour between two colours
class ColourPulse2:

    def __init__(self):

        self.timer = Timer()
        self.in_timer = Timer()
        self.out_timer = Timer()
        self.out_timer.start = 0
        self.active = False

    def get(self, hit, on, off, low_hls, high_hls):

        if on:
            rgb = colorsys.hls_to_rgb(high_hls[0], high_hls[1], high_hls[2])
            return [int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255), 255]
        if off:
            rgb = colorsys.hls_to_rgb(low_hls[0], low_hls[1], low_hls[2])
            return [int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255), 255]

        ani_time = 0.15

        if hit is True and self.active is False:
            self.active = True
            self.in_timer.set()

            out_time = self.out_timer.get()
            if out_time < ani_time:
                self.in_timer.force_set(ani_time - out_time)

        elif hit is False and self.active is True:
            self.active = False
            self.out_timer.set()

            in_time = self.in_timer.get()
            if in_time < ani_time:
                self.out_timer.force_set(ani_time - in_time)


        pro = 0.5
        if self.active:
            time = self.in_timer.get()
            if time <= 0:
                pro = 0
            elif time >= ani_time:
                pro = 1
            else:
                pro = time / ani_time
                gui.update = 2
        else:
            time = self.out_timer.get()
            if time <= 0:
                pro = 1
            elif time >= ani_time:
                pro = 0
            else:
                pro = 1 - (time / ani_time)
                gui.update = 2


        lumi = low_hls[1] + ((high_hls[1] - low_hls[1]) * pro)
        sat = low_hls[2] + ((high_hls[2] - low_hls[2]) * pro)
        hue = high_hls[0]

        rgb = colorsys.hls_to_rgb(hue, lumi, sat)
        return [int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255), 255]

cctest = ColourPulse2()


class ViewBox:

    def __init__(self):
        self.x = 0
        self.y = gui.panelY
        self.w = 270 * gui.scale
        self.h = 95 * gui.scale
        self.active = False

        self.border = 3 * gui.scale

        self.tracks_img = asset_loader("tracks.png", True)
        self.side_img = asset_loader("tracks+side.png", True)
        self.gallery1_img = asset_loader("gallery1.png", True)
        self.combo_img = asset_loader("combo.png", True)
        self.lyrics_img = asset_loader("lyrics.png", True)
        self.gallery2_img = asset_loader("gallery2.png", True)
        self.col_img = asset_loader("col.png", True)
        self.artist_img = asset_loader("artist.png", True)

        # _ .15 0
        self.tracks_colour = ColourPulse2() #(0.5) # .5 .6 .75
        self.side_colour = ColourPulse2() #(0.55) # .55 .6 .75
        self.gallery1_colour = ColourPulse2() #(0.6) # .6 .6 .75
        #self.combo_colour = ColourPulse(0.75)
        self.lyrics_colour = ColourPulse2() #(0.7)
        #self.gallery2_colour = ColourPulse(0.65)
        self.col_colour = ColourPulse2() #(0.14)
        self.artist_colour = ColourPulse2() #(0.2)

        self.on_colour = [255, 190, 50, 255]
        self.over_colour = [255, 190, 50, 255]
        self.off_colour = colours.grey(40)

        gui.lyrics_was_album = False

    def activate(self, x):
        self.x = x
        self.active = True

        self.tracks_colour.out_timer.force_set(10)
        self.side_colour.out_timer.force_set(10)
        self.gallery1_colour.out_timer.force_set(10)
        #self.combo_colour.out_timer.force_set(10)
        self.lyrics_colour.out_timer.force_set(10)
        #self.gallery2_colour.out_timer.force_set(10)
        self.col_colour.out_timer.force_set(10)
        self.artist_colour.out_timer.force_set(10)

        self.tracks_colour.active = False
        self.side_colour.active = False
        self.gallery1_colour.active = False
        #self.combo_colour.active = False
        self.lyrics_colour.active = False
        #self.gallery2_colour.active = False
        self.col_colour.active = False
        self.artist_colour.active = False

        self.col_force_off = False

        #gui.level_2_click = False
        gui.update = 2

    def button(self, x, y, asset, test, colour_get=None, name="Unknown", animate=True, low=0, high=0):

        on = test()
        rect = [x - 8 * gui.scale,
                y - 8 * gui.scale,
                asset.w + 16 * gui.scale,
                asset.h + 16 * gui.scale]
        fields.add(rect)

        if on:
            colour = self.on_colour

        else:
            colour = self.off_colour


        fun = None
        col = False
        if coll(rect):

            tool_tip.test(x + asset.w + 10 * gui.scale, y - 15 * gui.scale, name)

            col = True
            if gui.level_2_click:
                fun = test
            if colour_get is None:
                colour = self.over_colour

        colour = colour_get.get(col, on, not on and not animate, low, high)
            # if "+" in name:
            #
            #     colour = cctest.get(col, on, [0, 0.2, 0.0], [0, 0.8, 0.8])

        # if not on and not animate:
        #     colour = self.off_colour

        asset.render(x, y, colour)

        return fun


    def tracks(self, hit=False):

        if hit is False:
            return album_mode is False and \
                   gui.combo_mode is False and \
                   gui.rsp is False
        view_tracks()

    def side(self, hit=False):

        if hit is False:
            return album_mode is False and \
                   gui.combo_mode is False and \
                   gui.rsp is True
        view_standard_meta()

    def gallery1(self, hit=False):

        if hit is False:
            return album_mode is True and gui.show_playlist is True
        force_album_view()


    def lyrics(self, hit=False):

        if hit is False:
            return album_mode is False and \
                   gui.combo_mode is True and \
                   gui.showcase_mode is True

        if not gui.combo_mode:
            gui.lyrics_was_album = album_mode
            switch_showcase()
        else:
            switch_showcase()
            if gui.lyrics_was_album:
                force_album_view()

    # def gallery2(self, hit=False):
    #
    #     if hit is False:
    #         return album_mode is True and \
    #                gui.combo_mode is False and \
    #                gui.show_playlist is False
    #     gallery_only_view()

    def col(self, hit=False):

        if hit is False:
            return gui.set_mode

        if not gui.set_mode:
            if gui.combo_mode:
                switch_showcase()

        if album_mode and gui.plw < 550 * gui.scale:
            toggle_album_mode()

        toggle_library_mode()

    def artist_info(self, hit=False):

        if hit is False:
            return gui.artist_info_panel

        gui.artist_info_panel ^= True
        gui.update_layout()

    def render(self):

        if not x_menu.active:
            self.active = False

        if not self.active:
            return

        #rect = [self.x, self.y, self.w, self.h]

        if x_menu.clicked:
            gui.level_2_click = True


        x = self.x - 40 * gui.scale

        vr = [x, gui.panelY, 52 * gui.scale, 257 * gui.scale]
        #vr = [x, gui.panelY, 52 * gui.scale, 220 * gui.scale]

        border_colour = colours.grey(30)
        if not colours.lm:

            ddt.rect_r((vr[0] - 4, vr[1], vr[2] + 8, vr[3] + 4), border_colour, True)
        ddt.rect_r(vr, colours.menu_background, True)

        x = x + 7 * gui.scale
        y = gui.panelY + 14 * gui.scale

        func = None

        low = (0, .15, 0)

        if colours.lm:
            low = (0, .85, 0)

        # ----

        high = (.55, .6, .75)
        if colours.lm:
            high = (.55, .75, .75)

        test = self.button(x, y, self.side_img, self.side, self.side_colour, "Tracks + Art", low=low, high=high)
        if test is not None:
            func = test

        # ----

        y += 40 * gui.scale

        high = (.6, .6, .75)
        if colours.lm:
            high = (.6, .80, .85)

        test = self.button(x, y, self.gallery1_img, self.gallery1, self.gallery1_colour, "Gallery", low=low, high=high)
        if test is not None:
            func = test

        # ---

        y += 40 * gui.scale

        high = (.5, .6, .75)
        if colours.lm:
            high = (.5, .7, .65)

        test = self.button(x + 3 * gui.scale, y, self.tracks_img, self.tracks, self.tracks_colour, "Tracks only", low=low, high=high)
        if test is not None:
            func = test

        # ---

        y += 50 * gui.scale

        high = (.7, .6, .75)
        if colours.lm:
            high = (.7, .75, .75)

        test = self.button(x + 4 * gui.scale, y, self.lyrics_img, self.lyrics, self.lyrics_colour, "Showcase + Lyrics", False, low=low, high=high)
        if test is not None:
            func = test

        # --

        y += 40 * gui.scale

        high = (.14, .6, .75)
        if colours.lm:
            high = (.9, .75, .65)

        test = self.button(x + 5 * gui.scale, y, self.col_img, self.col, self.col_colour, "Toggle columns", False, low=low, high=high)
        if test is not None:
            func = test

        # --

        y += 41 * gui.scale

        high = (.2, .6, .75)
        if colours.lm:
            high = (.2, .6, .75)

        if gui.scale == 1.25:
            x-= 1

        test = self.button(x + 2 * gui.scale, y, self.artist_img, self.artist_info, self.artist_colour, "Toggle artist info", False, low=low, high=high)
        if test is not None:
            func = test

        if func is not None:
            func(True)

        if gui.level_2_click and coll(vr):
            x_menu.clicked = False

        gui.level_2_click = False

view_box = ViewBox()


class DLMon:

    def __init__(self):

        self.ticker = Timer()
        self.ticker.force_set(8)

        self.watching = {}
        self.ready = set()
        self.done = set()


    def scan(self):

        if len(self.watching) == 0:
            if self.ticker.get() < 10:
                return
        else:
            if self.ticker.get() < 2:
                return

        self.ticker.set()

        for downloads in download_directories:

            for item in os.listdir(downloads):

                path = os.path.join(downloads, item)

                if path in self.done:
                    continue

                if path in self.ready and not os.path.exists(path):
                    del self.ready[path]
                    continue

                if path in self.watching and not os.path.exists(path):
                    del self.watching[path]
                    continue

                #stamp = os.stat(path)[stat.ST_MTIME]
                stamp = os.path.getmtime(path)

                min_age = (time.time() - stamp) / 60
                ext = os.path.splitext(path)[1][1:].lower()

                if system == "windows" and "TauonMusicBox" in path:
                    continue

                if min_age < 240 and os.path.isfile(path) and ext in Archive_Formats:
                    size = os.path.getsize(path)
                    #print("Check: " + path)
                    if path in self.watching:
                        # Check if size is stable, then scan for audio files
                        #print("watching...")
                        if size == self.watching[path] and size != 0:
                            #print("scan")
                            del self.watching[path]

                            # Check if folder to extract to exists
                            split = os.path.splitext(path)
                            target_dir = split[0]
                            if prefs.extract_to_music and music_folder is not None:
                                target_dir = os.path.join(music_folder, os.path.basename(target_dir))

                            if os.path.exists(target_dir):
                                print("Target folder for archive already exsists")

                            elif archive_file_scan(path, DA_Formats, launch_prefix) >= 0.4:
                                self.ready.add(path)
                                gui.update += 1
                                print("Archive detected as music")
                            else:
                                print("Archive rejected as music")
                            self.done.add(path)
                        else:
                            #print("update.")
                            self.watching[path] = size
                    else:
                        self.watching[path] = size
                        #print("add.")


                elif min_age < 60 and os.path.isdir(path) and path not in quick_import_done and "encode-output" not in path:
                    size = get_folder_size(path)
                    if path in self.watching:
                        # Check if size is stable, then scan for audio files
                        if size == self.watching[path]:
                            del self.watching[path]
                            if folder_file_scan(path, DA_Formats) > 0.5:

                                # Check if folder not already imported
                                imported = False
                                for pl in pctl.multi_playlist:
                                    for i in pl[2]:
                                        if path.replace("\\", "/") == pctl.master_library[i].fullpath[:len(path)]:
                                            imported = True
                                        if imported:
                                            break
                                    if imported:
                                        break
                                else:
                                    self.ready.add(path)
                                gui.update += 1
                            self.done.add(path)
                        else:
                            self.watching[path] = size
                    else:
                        self.watching[path] = size
                else:
                    self.done.add(path)

        if len(self.ready) > 0:
            temp = set()
            # print(quick_import_done)
            # print(self.ready)
            for item in self.ready:
                if item not in quick_import_done:
                    if os.path.exists(path):
                        temp.add(item)
                else:
                    print("FILE IMPORTED")
            self.ready = temp

        if len(self.watching) > 0:
            gui.update += 1

dl_mon = DLMon()


def dismiss_dl():

    dl_mon.ready.clear()
    dl_mon.done.update(dl_mon.watching)
    dl_mon.watching.clear()

dl_menu.add("Dismiss", dismiss_dl)


class Fader:

    def __init__(self):

        self.total_timer = Timer()
        self.timer = Timer()
        self.ani_duration = 0.3
        self.state = 0  # 0 = Want off, 1 = Want fade on
        self.a = 0  # The fade progress (0-1)

    def render(self):

        if self.total_timer.get() > self.ani_duration:
            self.a = self.state
        elif self.state == 0:
            t = self.timer.hit()
            self.a -= t / self.ani_duration
            self.a = max(0, self.a)
        elif self.state == 1:
            t = self.timer.hit()
            self.a += t / self.ani_duration
            self.a = min(1, self.a)

        rect = [0, 0, window_size[0], window_size[1]]
        ddt.rect_r(rect, [0, 0, 0, int(110 * self.a)], True)

        if not (self.a == 0 or self.a == 1):
            gui.update += 1

    def rise(self):

        self.state = 1
        self.timer.hit()
        self.total_timer.set()

    def fall(self):

        self.state = 0
        self.timer.hit()
        self.total_timer.set()


fader = Fader()

class EdgePulse:

    def __init__(self):

        self.timer = Timer()
        self.timer.force_set(10)
        self.ani_duration = 0.5

    def render(self, x, y, w, h, r=200, g=120, b=0):
        r = colours.pluse_colour[0]
        g = colours.pluse_colour[1]
        b = colours.pluse_colour[2]
        time = self.timer.get()
        if time < self.ani_duration:
            alpha = 255 - int(255 * (time / self.ani_duration))
            ddt.rect_r((x, y, w, h), [r, g, b, alpha], True)
            gui.update = 2
            return True
        else:
            return False

    def pulse(self):
        self.timer.set()


edge_playlist = EdgePulse()
bottom_playlist = EdgePulse()
gallery_pulse_top = EdgePulse()
tab_pulse = EdgePulse()
lyric_side_top_pulse = EdgePulse()
lyric_side_bottom_pulse = EdgePulse()



def download_img(link, target_folder):

    try:
        response = urllib.request.urlopen(link)
        info = response.info()
        if info.get_content_maintype() == 'image':
            if info.get_content_subtype() == 'jpeg':
                save_target = os.path.join(target_dir, 'image.jpg')
                f = open(save_target, 'wb')
                f.write(response.read())
                f.close()
                clear_img_cache()

            elif info.get_content_subtype() == 'png':
                save_target = os.path.join(target_dir, 'image.png')
                f = open(save_target, 'wb')
                f.write(response.read())
                f.close()
                clear_img_cache()
            else:
                show_message("Image types other than PNG or JPEG are currently not supported", 'warning')
        else:
            show_message("The link does not appear to refer to an image file.", 'warning')
        gui.image_downloading = False

    except Exception as e:
        show_message("Image download failed.", 'warning', str(e))
        gui.image_downloading = False


def display_you_heart(x, yy, just=0):


    rect = [x - 1 * gui.scale, yy - 4 * gui.scale, 15 * gui.scale, 17 * gui.scale]
    gui.heart_fields.append(rect)
    fields.add(rect, update_playlist_call)
    if coll(rect) and not track_box:
        gui.pl_update += 1
        w = ddt.get_text_w("You", 13)
        xx = (x - w) - 5 * gui.scale

        if just == 1:
            xx += w + 15 * gui.scale

        ty = yy - 28 * gui.scale
        tx = xx
        if ty < gui.panelY + 5 * gui.scale:
            ty = gui.panelY + 5 * gui.scale
            tx -= 20 * gui.scale

        # ddt.rect_r((xx - 1 * gui.scale, yy - 26 * gui.scale - 1 * gui.scale, w + 10 * gui.scale + 2 * gui.scale, 19 * gui.scale + 2 * gui.scale), [50, 50, 50, 255], True)
        ddt.rect_r((tx - 5 * gui.scale, ty, w + 20 * gui.scale, 24 * gui.scale), [15, 15, 15, 255],
                   True)
        ddt.rect_r((tx - 5 * gui.scale, ty, w + 20 * gui.scale, 24 * gui.scale), [35, 35, 35, 255])
        ddt.draw_text((tx + 5 * gui.scale, ty + 4 * gui.scale), "You", [250, 250, 250, 255], 13, bg=[15, 15, 15, 255])

    heart_row_icon.render(x,
                          yy, [244, 100, 100, 255])


def display_friend_heart(x, yy, name, just=0):

    heart_row_icon.render(x,
                          yy, heart_colours.get(name))

    rect = [x - 1, yy - 4, 15 * gui.scale, 17 * gui.scale]
    gui.heart_fields.append(rect)
    fields.add(rect, update_playlist_call)
    if coll(rect) and not track_box:
        gui.pl_update += 1
        w = ddt.get_text_w(name, 13)
        xx = (x - w) - 5 * gui.scale

        if just == 1:
            xx += w + 15 * gui.scale

        ty = yy - 28 * gui.scale
        tx = xx
        if ty < gui.panelY + 5 * gui.scale:
            ty = gui.panelY + 5 * gui.scale
            tx -= 20 * gui.scale

        ddt.rect_r((tx - 5 * gui.scale, ty, w + 20 * gui.scale, 24 * gui.scale), [15, 15, 15, 255],
                   True)
        ddt.rect_r((tx - 5 * gui.scale, ty, w + 20 * gui.scale, 24 * gui.scale), [35, 35, 35, 255])
        ddt.draw_text((tx + 5 * gui.scale, ty + 4 * gui.scale), name, [250, 250, 250, 255], 13, bg=[15, 15, 15, 255])


# Set SDL window drag areas
# if system != 'windows':

def hit_callback(win, point, data):

    # Special layout modes
    if gui.mode == 3:

        if key_shift_down or key_shiftr_down:
            return SDL_HITTEST_NORMAL

        if prefs.mini_mode_mode == 4 and point.contents.x > window_size[1] and point.contents.y > window_size[1] - 12 * gui.scale:
            return SDL_HITTEST_NORMAL

        if point.contents.y < gui.window_control_hit_area_h and point.contents.x > window_size[
            0] - gui.window_control_hit_area_w:
            return SDL_HITTEST_NORMAL

        # Square modes
        y1 = window_size[0]
        if window_size[0] == window_size[1]:
            y1 = window_size[1] - 79 * gui.scale
        if point.contents.y < y1:
            return SDL_HITTEST_DRAGGABLE

        return SDL_HITTEST_NORMAL

    # Standard player mode
    if not gui.maximized:
        if point.contents.y < 0 and point.contents.x > window_size[0]:
            return SDL_HITTEST_RESIZE_TOPRIGHT

        if point.contents.y < 0 and point.contents.x < 1:
            return SDL_HITTEST_RESIZE_TOPLEFT

        if draw_border and point.contents.y < 4 and point.contents.x < window_size[0] - 40 and not gui.maximized:
            return SDL_HITTEST_RESIZE_TOP

    if point.contents.y < gui.panelY and top_panel.drag_zone_start_x < point.contents.x < window_size[0] - 80:

        if tab_menu.active: # or pctl.broadcast_active:
            return SDL_HITTEST_NORMAL

        if gui.vis != 0 and point.contents.x > window_size[0] - 160 and system == "windows":
            return SDL_HITTEST_NORMAL

        return SDL_HITTEST_DRAGGABLE

    if not gui.maximized:
        if point.contents.x > window_size[0] - 20 and point.contents.y > window_size[1] - 20:
            return SDL_HITTEST_RESIZE_BOTTOMRIGHT
        elif point.contents.x < 5 and point.contents.y > window_size[1] - 5:
            return SDL_HITTEST_RESIZE_BOTTOMLEFT
        elif point.contents.y > window_size[1] - 7:
            return SDL_HITTEST_RESIZE_BOTTOM

        elif point.contents.x > window_size[0] - 2 and point.contents.y > 20:
            return SDL_HITTEST_RESIZE_RIGHT
        elif point.contents.x < 5:
            return SDL_HITTEST_RESIZE_LEFT
        else:
            return SDL_HITTEST_NORMAL
    else:
        return SDL_HITTEST_NORMAL


c_hit_callback = SDL_HitTest(hit_callback)
SDL_SetWindowHitTest(t_window, c_hit_callback, 0)
# --------------------------------------------------------------------------------------------

print("Starting worker threads...")

worker1Thread = threading.Thread(target=worker1)
worker1Thread.daemon = True
worker1Thread.start()

worker2Thread = threading.Thread(target=worker2)
worker2Thread.daemon = True
worker2Thread.start()

# MAIN LOOP---------------------------------------------------------------------------

if system == 'linux':
    if de_nofity_support:
        Notify.init("Tauon Music Box Transcode Notification")
        g_tc_notify = Notify.Notification.new("Tauon Music Box",
                                              "Transcoding has finished.")

        g_tc_notify.add_action(
            "action_click",
            "Open Output Folder",
            g_open_encode_out,
            None
        )


# print("Almost done...")

gui.playlist_view_length = int(((window_size[1] - gui.playlist_top) / 16) - 1)

ab_click = False
d_border = 1

update_layout = True

event = SDL_Event()

mouse_moved = False

power = 0
key_F7 = False

r_arg_queue = copy.deepcopy(sys.argv)

arg_queue = []
for item in r_arg_queue:
    if (os.path.isdir(item) or os.path.isfile(item) or "file://" in item) and '.py' not in item and 'tauon.exe' not in item:
        arg_queue.append(item)


sv = SDL_version()
SDL_GetVersion(sv)
sdl_version = sv.major * 100 + sv.minor * 10 + sv.patch
print("Using SDL verrsion: " + str(sv.major) + "." + str(sv.minor) + "." + str(sv.patch))

# C-ML
if prefs.backend == 2:
    print("Using GStreamer as fallback. Some functions disabled")
elif prefs.backend == 0:
    show_message("ERROR: No backend found", 'error')


class Undo():

    def __init__(self):

        self.e = []

    def undo(self):

        if not self.e:
            show_message("There are no more steps to undo.")
            return

        job = self.e.pop()

        if job[0] == "playlist":
            pctl.multi_playlist.append(job[1])
            switch_playlist(len(pctl.multi_playlist) - 1)
        elif job[0] == 'tracks':

            uid = job[1]
            li = job[2]

            for i, playlist in enumerate(pctl.multi_playlist):
                if playlist[6] == uid:
                    pl = playlist[2]
                    switch_playlist(i)
                    break
            else:
                print("No matching playlist ID to restore tracks to")
                return

            for i, ref in reversed(li):

                if i > len(pl):
                    print("restore track error - playlist not correct length")
                    continue
                pl.insert(i, ref)

                if not pctl.playlist_view_position < i < pctl.playlist_view_position + gui.playlist_view_length:
                    pctl.playlist_view_position = i

        gui.pl_update = 1

    def bk_playlist(self, pl_index):

        self.e.append(("playlist", pctl.multi_playlist[pl_index]))

    def bk_tracks(self, pl_index, indis):

        uid = pctl.multi_playlist[pl_index][6]
        self.e.append(("tracks", uid, indis))

undo = Undo()


if prefs.bio_large:
    bio_set_large()
else:
    bio_set_small()


def update_layout_do():

    # w = window_size[0]
    # h = window_size[1]

    if prefs.art_bg_stronger == 3:
        prefs.art_bg_opactiy = 29
    elif prefs.art_bg_stronger == 2:
        prefs.art_bg_opactiy = 19
    else:
        prefs.art_bg_opactiy = 10

    if prefs.bg_showcase_only:
        prefs.art_bg_opactiy += 8

    # prefs.art_bg_blur = 9
    # if prefs.bg_showcase_only:
    #     prefs.art_bg_blur = 15
    #
    # if w / h == 16 / 9:
    #     print("YEP")
    # elif w / h < 16 / 9:
    #     print("too low")
    # else:
    #     print("too high")
    # print(w)

    #input.mouse_click = False

    global renderer

    #print("TEST")

    if prefs.spec2_colour_mode == 0:
        prefs.spec2_base = [10, 10, 100]
        prefs.spec2_multiply = [0.5, 1, 1]
    elif prefs.spec2_colour_mode == 1:
        prefs.spec2_base = [10, 10, 10]
        prefs.spec2_multiply = [2, 1.2, 5]
    # elif prefs.spec2_colour_mode == 2:
    #     prefs.spec2_base = [10, 100, 10]
    #     prefs.spec2_multiply = [1, -1, 0.4]

    gui.draw_vis4_top = False

    if gui.combo_mode and prefs.showcase_vis and not gui.mode == 3:
        gui.vis = 4
        gui.turbo = True
    elif gui.vis_want == 0:
        gui.turbo = False
        gui.vis = 0
    else:
        gui.vis = gui.vis_want
        if gui.vis > 0:
            gui.turbo = True

    if gui.mode == 3:
        gui.vis = 0
        gui.turbo = False


    if gui.mode == 1:

        if not gui.maximized and not gui.lowered and not gui.mode == 3:
            gui.save_size[0] = window_size[0]
            gui.save_size[1] = window_size[1]

        bottom_bar1.update()

        # if system != 'windows':
        #     if draw_border:
        #         gui.panelY = 30 * gui.scale + 3 * gui.scale
        #         top_panel.ty = 3 * gui.scale
        #     else:
        #         gui.panelY = 30 * gui.scale
        #         top_panel.ty = 0

        if gui.set_bar and gui.set_mode:
            gui.playlist_top = gui.playlist_top_bk + gui.set_height - 6 * gui.scale
        else:
            gui.playlist_top = gui.playlist_top_bk

        if gui.artist_info_panel:
            gui.playlist_top += gui.artist_panel_height

        gui.offset_extra = 0
        if draw_border:
            gui.offset_extra = 61 * gui.scale

        global album_v_gap
        if gui.gallery_show_text:
            album_v_gap = 66 * gui.scale
        else:
            album_v_gap = 25 * gui.scale

        gui.gallery_scroll_field_left = window_size[0] - round(40 * gui.scale)

        #gui.spec_rect[0] = window_size[0] - gui.offset_extra - 90
        gui.spec1_rec.x = int(round(window_size[0] - gui.offset_extra - 90 * gui.scale))
        #gui.spec_x = window_size[0] - gui.offset_extra - 90

        gui.spec2_rec.x = int(round(window_size[0] - gui.spec2_rec.w - 10 * gui.scale - gui.offset_extra))

        gui.scroll_hide_box = (1, gui.panelY, 28 * gui.scale, window_size[1] - gui.panelBY - gui.panelY)
        gui.playlist_row_height = prefs.playlist_row_height
        gui.playlist_text_offset = 0
        gui.row_font_size = prefs.playlist_font_size  # 13
        # gui.pl_text_real_height = ddt.get_text_w("Testã9", gui.row_font_size, False, True)
        # gui.pl_title_real_height = ddt.get_text_w("Testã9", gui.row_font_size + gui.pl_title_font_offset, False, True)
        # gui.playlist_text_offset = (int((gui.playlist_row_height - gui.pl_text_real_height) / 2))
        # # To improve
        # if system == 'linux' and gui.scale == 1:
        #     gui.playlist_text_offset = int(round((gui.playlist_row_height + 0.5 - 0) / 2)) - 11 #* gui.scale
        #     #gui.playlist_text_offset = int(round((gui.playlist_row_height + 0.5 - 0) / 2)) - 11 #* gui.scale
        # if system == 'windows':
        #     gui.playlist_text_offset -= 1

        gui.playlist_text_offset = round(gui.playlist_row_height * 0.55) + 4 - 13 * gui.scale
        if gui.scale == 2:
            gui.playlist_text_offset += 3
        if gui.scale == 1.25:
            gui.playlist_text_offset += 1

        gui.pl_title_real_height = round(gui.playlist_row_height * 0.55) + 4 - 12

        # if gui.scale > 1:
        #     #gui.playlist_text_offset += 17
        #     #gui.playlist_row_height *= gui.scale
        #     pass

        gui.playlist_view_length = int(((window_size[1] - gui.panelBY - gui.playlist_top) / gui.playlist_row_height) - 1)



        box_r = gui.rspw / (window_size[1] - gui.panelBY - gui.panelY)

        if gui.art_aspect_ratio > 1.01:
            gui.art_unlock_ratio = True
            if gui.art_aspect_ratio > gui.art_max_ratio_lock:
                gui.art_max_ratio_lock = gui.art_aspect_ratio



        # print("Avaliabe: " + str(box_r))
        elif box_r <= 1:
            gui.art_unlock_ratio = False
            gui.art_max_ratio_lock = 1

        if side_drag and key_shift_down:
            gui.art_unlock_ratio = True
            gui.art_max_ratio_lock = 5

        # Limit the right side panel width to height of area
        if gui.rsp:
            if album_mode:
                pass
            else:

                if not gui.art_unlock_ratio:

                    if gui.rspw > window_size[1] - gui.panelY - gui.panelBY:
                        gui.rspw = window_size[1] - gui.panelY - gui.panelBY


        # Determine how wide the playlist need to be
        gui.plw = window_size[0]
        gui.playlist_left = 0
        if gui.lsp:
            #if gui.plw > gui.lspw:
            gui.plw -= gui.lspw
            gui.playlist_left = gui.lspw
        if gui.rsp:
            gui.plw -= gui.rspw


        # Shrink side panel if playlist gets too small
        if window_size[0] > 100:

            if gui.plw < 300:
                if gui.rsp:

                    l = 0
                    if gui.lsp:
                        l = gui.lspw

                    gui.rspw = max(window_size[0] - l - 300, 110)
                    if album_mode:
                        gui.pref_gallery_w = gui.rspw


        # Determine how wide the playlist need to be (again)
        gui.plw = window_size[0]
        gui.playlist_left = 0
        if gui.lsp:
            #if gui.plw > gui.lspw:
            gui.plw -= gui.lspw
            gui.playlist_left = gui.lspw
        if gui.rsp:
            gui.plw -= gui.rspw



        if window_size[0] < 630 * gui.scale:
            gui.compact_bar = True
        else:
            gui.compact_bar = False

        gui.pl_update = 1


        if window_size[0] > gui.max_window_tex or window_size[1] > gui.max_window_tex:

            while window_size[0] > gui.max_window_tex:
                gui.max_window_tex += 1000
            while window_size[1] > gui.max_window_tex:
                gui.max_window_tex += 1000


            gui.abc = SDL_Rect(0, 0, gui.max_window_tex, gui.max_window_tex)

            SDL_DestroyTexture(gui.ttext)
            SDL_RenderClear(renderer)
            gui.ttext = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_UNKNOWN, SDL_TEXTUREACCESS_TARGET, gui.max_window_tex,
                                          gui.max_window_tex)

            SDL_SetRenderTarget(renderer, gui.ttext)
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0)
            SDL_RenderClear(renderer)
            SDL_SetTextureBlendMode(gui.ttext, SDL_BLENDMODE_BLEND)

            # SDL_SetRenderTarget(renderer, gui.main_texture)
            # SDL_RenderClear(renderer)

            SDL_DestroyTexture(gui.main_texture)
            gui.main_texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.max_window_tex,
                                                 gui.max_window_tex)
            SDL_SetTextureBlendMode(gui.main_texture, SDL_BLENDMODE_BLEND)
            SDL_SetRenderTarget(renderer, gui.main_texture)
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0)
            SDL_SetRenderTarget(renderer, gui.main_texture)
            SDL_RenderClear(renderer)



            SDL_DestroyTexture(gui.main_texture_overlay_temp)
            gui.main_texture_overlay_temp = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, gui.max_window_tex,
                                                 gui.max_window_tex)
            SDL_SetTextureBlendMode(gui.main_texture_overlay_temp, SDL_BLENDMODE_BLEND)
            SDL_SetRenderTarget(renderer, gui.main_texture_overlay_temp)
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0)
            SDL_SetRenderTarget(renderer, gui.main_texture_overlay_temp)
            SDL_RenderClear(renderer)

        update_set()

print("Flushing render target...")

SDL_SetRenderTarget(renderer, None)
SDL_RenderClear(renderer)
SDL_RenderPresent(renderer)

print("Presenting Window...")

SDL_ShowWindow(t_window)

# Clear spectogram texture
SDL_SetRenderTarget(renderer, gui.spec2_tex)
SDL_RenderClear(renderer)
ddt.rect_r((0, 0, 1000, 1000), [7, 7, 7, 255], True)

SDL_SetRenderTarget(renderer, gui.spec1_tex)
SDL_RenderClear(renderer)
ddt.rect_r((0, 0, 1000, 1000), [7, 7, 7, 255], True)

SDL_SetRenderTarget(renderer, gui.spec_level_tex)
SDL_RenderClear(renderer)
ddt.rect_r((0, 0, 1000, 1000), [7, 7, 7, 255], True)

SDL_SetRenderTarget(renderer, None)

#SDL_RenderPresent(renderer)

#time.sleep(3)

class GetSDLInput:

    def __init__(self):
        self.i_y = pointer(c_int(0))
        self.i_x = pointer(c_int(0))

        self.mouse_capture_want = False
        self.mouse_capture = False

    def mouse(self):
        SDL_PumpEvents()
        SDL_GetMouseState(self.i_x, self.i_y)
        return self.i_x.contents.value, self.i_y.contents.value


    def test_capture_mouse(self):
        if not self.mouse_capture and self.mouse_capture_want:
            SDL_CaptureMouse(SDL_TRUE)
            self.mouse_capture = True
        elif self.mouse_capture and not self.mouse_capture_want:
            SDL_CaptureMouse(SDL_FALSE)
            self.mouse_capture = False


gal_up = False
gal_down = False
gal_left = False
gal_right = False


get_sdl_input = GetSDLInput()

def window_is_focused():  # thread safe?
    if SDL_GetWindowFlags(t_window) & SDL_WINDOW_INPUT_FOCUS:
        return True
    return False


def save_state():

    print("Writing database to disk.")

    # view_prefs['star-lines'] = star_lines
    view_prefs['update-title'] = update_title
    view_prefs['side-panel'] = prefs.prefer_side
    view_prefs['dim-art'] = prefs.dim_art
    view_prefs['level-meter'] = gui.turbo
    # view_prefs['pl-follow'] = pl_follow
    view_prefs['scroll-enable'] = scroll_enable
    view_prefs['break-enable'] = break_enable
    # view_prefs['dd-index'] = dd_index
    view_prefs['append-date'] = prefs.append_date

    # if album_mode:
    #     global album_playlist_width
    #     album_playlist_width = gui.playlist_width

    save = [pctl.master_library,
            master_count,
            pctl.playlist_playing_position,
            pctl.active_playlist_viewing,
            pctl.playlist_view_position,
            pctl.multi_playlist,
            pctl.player_volume,
            pctl.track_queue,
            pctl.queue_step,
            default_playlist,
            pctl.playlist_playing_position,
            None,  # Was cue list
            radio_field.text,
            theme,
            folder_image_offsets,
            None, # lfm_username,
            None, # lfm_hash,
            30,  # Version, used for upgrading
            view_prefs,
            gui.save_size,
            None,  # old side panel size
            0,  # save time (unused)
            gui.vis_want,  # gui.vis
            playlist_selected,
            album_mode_art_size,
            draw_border,
            prefs.enable_web,
            prefs.allow_remote,
            prefs.expose_web,
            True,  # prefs.enable_transcode
            prefs.show_rym,
            None,  # was combo mode art size
            gui.maximized,
            prefs.prefer_bottom_title,
            gui.display_time_mode,
            prefs.transcode_mode,
            prefs.transcode_codec,
            prefs.transcode_bitrate,
            1, # prefs.line_style,
            prefs.cache_gallery,
            prefs.playlist_font_size,
            prefs.use_title,
            gui.pl_st,
            None, # gui.set_mode,
            None,
            prefs.playlist_row_height,
            prefs.show_wiki,
            prefs.auto_extract,
            prefs.colour_from_image,
            gui.set_bar,
            gui.gallery_show_text,
            gui.bb_show_art,
            False,  # Was show stars
            prefs.auto_lfm,
            prefs.scrobble_mark,
            prefs.replay_gain,
            True,  # Was radio lyrics
            prefs.show_gimage,
            prefs.end_setting,
            prefs.show_gen,
            pctl.save_urls,
            prefs.auto_del_zip,
            gui.level_meter_colour_mode,
            prefs.ui_scale,
            prefs.show_lyrics_side,
            prefs.last_device,
            album_mode,
            None,  # album_playlist_width
            prefs.transcode_opus_as,
            gui.star_mode,
            prefs.prefer_side, #gui.rsp,
            gui.lsp,
            gui.rspw,
            gui.pref_gallery_w,
            gui.pref_rspw,
            gui.show_hearts,
            prefs.monitor_downloads,  # 76
            gui.artist_info_panel,  # 77
            prefs.extract_to_music,  # 78
            lb.enable,
            None, #lb.key,
            rename_files.text,
            rename_folder.text,
            prefs.use_jump_crossfade,
            prefs.use_transition_crossfade,
            prefs.show_notifications,
            prefs.true_shuffle,
            gui.set_mode,
            None, #prefs.show_queue, # 88
            None, # prefs.show_transfer,
            pctl.force_queue, # 90
            prefs.use_pause_fade, # 91
            prefs.append_total_time, # 92
            prefs.backend,
            pctl.album_shuffle_mode,
            pctl.album_repeat_mode, # 95
            prefs.finish_current,  # Not used
            prefs.reload_state,  # 97
            None, # prefs.reload_play_state,
            prefs.last_fm_token,
            prefs.last_fm_username,
            prefs.use_card_style,
            prefs.auto_lyrics,
            prefs.auto_lyrics_checked,
            prefs.show_side_art,
            prefs.window_opacity,
            prefs.gallery_single_click,
            prefs.tabs_on_top,
            prefs.showcase_vis,
            prefs.spec2_colour_mode,
            prefs.device_buffer,
            prefs.use_eq,
            prefs.eq,
            prefs.bio_large,
            prefs.discord_show,
            prefs.min_to_tray,
            prefs.guitar_chords,
            prefs.playback_follow_cursor,
            prefs.art_bg,
            pctl.random_mode,
            pctl.repeat_mode,
            prefs.art_bg_stronger,
            prefs.art_bg_always_blur,
            prefs.failed_artists,
            prefs.artist_list,
            prefs.auto_sort,
            prefs.lyrics_enables,
            prefs.fanart_notify,
            prefs.bg_showcase_only,
            None, #prefs.discogs_pat,
            prefs.mini_mode_mode,
            None]


    pickle.dump(save, open(user_directory + "/state.p", "wb"))

    save_prefs()

# SDL_StartTextInput()
# SDL_SetHint(SDL_HINT_IME_INTERNAL_EDITING, b"1")
# SDL_EventState(SDL_SYSWMEVENT, 1)

# class AutoSave:
#
#     def __init__(self):
#         auto_save_timer = Timer()


def test_show_add_home_music():

    gui.add_music_folder_ready = True

    if music_folder is None:
        gui.add_music_folder_ready = False
        return

    for item in pctl.multi_playlist:
        if item[7] == music_folder:
            gui.add_music_folder_ready = False
            break

test_show_add_home_music()

if gui.restart_album_mode:
    toggle_album_mode(True)

if gui.remember_library_mode:
    toggle_library_mode()

quick_import_done = []

if reload_state:
    if reload_state[0] == 1:
        pctl.jump_time = reload_state[1]
        pctl.play()

    # if reload_state[0] == 2:
    #     pctl.playing_state = 2

print("Setup done. Entering main loop\n")

pctl.notify_update()

key_focused = 0




while pctl.running:
    # bm.get('main')

    if k_input:

        keymaps.hits.clear()

        d_mouse_click = False
        mouse4 = False
        mouse5 = False
        right_click = False
        level_2_right_click = False
        input.mouse_click = False
        middle_click = False
        mouse_up = False
        input.key_return_press = False
        key_down_press = False
        key_up_press = False
        key_right_press = False
        key_left_press = False
        key_esc_press = False
        key_del = False
        key_backspace_press = False
        key_c_press = False
        key_v_press = False
        #key_f_press = False
        key_a_press = False
        key_t_press = False
        key_z_press = False
        key_x_press = False
        key_home_press = False
        key_end_press = False
        mouse_wheel = 0
        new_playlist_cooldown = False
        input_text = ''
        input.level_2_enter = False

        mouse_enter_window = False
        if key_focused:
            key_focused -= 1


    #f not mouse_down:
    k_input = False

    clicked = False
    focused = False
    mouse_moved = False
    gui.level_2_click = False

    # gui.update = 2

    while SDL_PollEvent(ctypes.byref(event)) != 0:

        # print(event.type)

        # if event.type == SDL_SYSWMEVENT:
        #      print(event.syswm.msg.contents) # Not implemented by pysdl2

        if event.type == SDL_DROPTEXT:

            link = event.drop.file.decode()
            if pctl.playing_ready() and 'http' in link:
                if system != 'windows' and sdl_version >= 204:
                    gmp = get_global_mouse()
                    gwp = get_window_position()
                    i_x = gmp[0] - gwp[0]
                    if i_x < 0:
                        i_x = 0
                    if i_x > window_size[0]:
                        i_x = window_size[0]
                    i_y = gmp[1] - gwp[1]
                    if i_y < 0:
                        i_y = 0
                    if i_y > window_size[1]:
                        i_y = window_size[1]
                else:
                    i_y = pointer(c_int(0))
                    i_x = pointer(c_int(0))

                    SDL_GetMouseState(i_x, i_y)
                    i_y = i_y.contents.value
                    i_x = i_x.contents.value

                if coll_point((i_x, i_y), gui.main_art_box):

                    print('Drop picture...')
                    print(link)
                    gui.image_downloading = True
                    track = pctl.playing_object()
                    target_dir = track.parent_folder_path

                    shoot_dl = threading.Thread(target=download_img, args=(link, target_dir))
                    shoot_dl.daemon = True
                    shoot_dl.start()

                    gui.update = True

        if event.type == SDL_DROPFILE:
            power += 5
            k = 0

            if system != 'windows' and sdl_version >= 204:
                gmp = get_global_mouse()
                gwp = get_window_position()
                i_x = gmp[0] - gwp[0]
                if i_x < 0:
                    i_x = 0
                if i_x > window_size[0]:
                    i_x = window_size[0]
                i_y = gmp[1] - gwp[1]
                if i_y < 0:
                    i_y = 0
                if i_y > window_size[1]:
                    i_y = window_size[1]
            else:
                i_y = pointer(c_int(0))
                i_x = pointer(c_int(0))

                SDL_GetMouseState(i_x, i_y)
                i_y = i_y.contents.value
                i_x = i_x.contents.value

            # print((i_x, i_y))
            playlist_target = 0
            #print(event.drop)

            # print("TEST")
            # print(gui.lsp)
            # print(gui.panelY < i_y < gui.panelBY)
            # print(i_x < gui.lspw)
            # print( gui.mode == 1)

            if i_y < gui.panelY and not new_playlist_cooldown and gui.mode == 1:
                x = top_panel.start_space_left
                for w in range(len(pctl.multi_playlist)):
                    wid = top_panel.tab_text_spaces[w] + top_panel.tab_extra_width

                    if x < i_x < x + wid:
                        playlist_target = w
                        tab_pulse.pulse()
                        gui.update += 1
                        gui.pl_pulse = True

                        print("Direct drop")
                        break
                    x += wid
                else:
                    print("MISS")
                    if new_playlist_cooldown:
                        playlist_target = pctl.active_playlist_viewing
                    else:
                        playlist_target = new_playlist()
                        new_playlist_cooldown = True

            elif gui.lsp and gui.panelY < i_y < window_size[1] - gui.panelBY and i_x < gui.lspw and gui.mode == 1:

                y = gui.panelY
                y += 5 * gui.scale
                y += playlist_box.tab_h + playlist_box.gap

                for i, pl in enumerate(pctl.multi_playlist):
                    if i_y < y:
                        playlist_target = i
                        tab_pulse.pulse()
                        gui.update += 1
                        gui.pl_pulse = True
                        print("Direct drop")
                        break
                    y += playlist_box.tab_h + playlist_box.gap
                else:
                    if new_playlist_cooldown:
                        playlist_target = pctl.active_playlist_viewing
                    else:
                        playlist_target = new_playlist()
                        new_playlist_cooldown = True


            else:
                playlist_target = pctl.active_playlist_viewing


            dropped_file_sdl = event.drop.file
            target = str(urllib.parse.unquote(dropped_file_sdl.decode("utf-8"))).replace("file:///", "/").replace("\r", "")

            if not os.path.exists(target) and flatpak_mode:
                show_message(_("Could not access! Possible insufficient Flatpak permissions."), 'bubble',
                             " See https://github.com/Taiko2k/TauonMusicBox/wiki/Flatpak-Permissions for details.")

            load_order = LoadClass()
            load_order.target = target


            if os.path.isdir(load_order.target):
                quick_import_done.append(load_order.target)

                if not pctl.multi_playlist[playlist_target][7]:
                    pctl.multi_playlist[playlist_target][7] = load_order.target

            load_order.playlist = pctl.multi_playlist[playlist_target][6]
            load_orders.append(copy.deepcopy(load_order))

            # print('dropped: ' + str(dropped_file))
            gui.update += 1

            mouse_down = False
            drag_mode = False
        elif event.type == 8192:
            gui.pl_update = 1
            gui.update += 2

        elif event.type == SDL_QUIT:
            power += 5
            pctl.running = False
            break
        elif event.type == SDL_TEXTEDITING:
            power += 5
            #print("edit text")
            editline = event.edit.text
            #print(editline)
            editline = editline.decode("utf-8", 'ignore')
            k_input = True
            gui.update += 1

        elif event.type == SDL_MOUSEMOTION:

            mouse_position[0] = event.motion.x
            mouse_position[1] = event.motion.y
            mouse_moved = True
        elif event.type == SDL_MOUSEBUTTONDOWN:

            k_input = True
            focused = True
            power += 5
            gui.update += 1

            if event.button.button == SDL_BUTTON_RIGHT:
                right_click = True
                right_down = True
                #print("RIGHT DOWN")
            elif event.button.button == SDL_BUTTON_LEFT:
                #print("LEFT DOWN")

                # if mouse_position[1] > 1 and mouse_position[0] > 1:
                #     mouse_down = True

                input.mouse_click = True

                mouse_down = True
            elif event.button.button == SDL_BUTTON_MIDDLE:
                middle_click = True
                gui.update += 1
            elif event.button.button == SDL_BUTTON_X1:
                mouse4 = True
            elif event.button.button == SDL_BUTTON_X2:
                mouse5 = True
        elif event.type == SDL_MOUSEBUTTONUP:
            k_input = True
            power += 5
            gui.update += 1
            if event.button.button == SDL_BUTTON_RIGHT:
                right_down = False
                #print("RIGHT UP")
            elif event.button.button == SDL_BUTTON_LEFT:
                #print("LEFT UP")
                mouse_down = False
                mouse_up = True
        elif event.type == SDL_KEYDOWN:
            k_input = True
            power += 5
            gui.update += 2
            keymaps.hits.append(event.key.keysym.sym)

            if event.key.keysym.sym == SDLK_RETURN and len(editline) == 0:
                input.key_return_press = True
            # elif event.key.keysym.sym == SDLK_SPACE:
            #     key_space_press = True
            elif event.key.keysym.sym == SDLK_BACKSPACE:
                key_backspace_press = True
            elif event.key.keysym.sym == SDLK_DELETE:
                key_del = True
            elif event.key.keysym.sym == SDLK_ESCAPE:
                key_esc_press = True
            elif event.key.keysym.sym == SDLK_RALT:
                key_ralt = True
            elif event.key.keysym.sym == SDLK_LALT:
                key_lalt = True
            elif event.key.keysym.sym == SDLK_v:
                key_v_press = True
            elif event.key.keysym.sym == SDLK_a:
                key_a_press = True
            elif event.key.keysym.sym == SDLK_c:
                key_c_press = True
            elif event.key.keysym.sym == SDLK_t:
                key_t_press = True
            elif event.key.keysym.sym == SDLK_z:
                key_z_press = True
            elif event.key.keysym.sym == SDLK_x:
                key_x_press = True
            elif event.key.keysym.sym == SDLK_DOWN:
                key_down_press = True
            elif event.key.keysym.sym == SDLK_UP:
                key_up_press = True
            elif event.key.keysym.sym == SDLK_LEFT:
                key_left_press = True
            elif event.key.keysym.sym == SDLK_RIGHT:
                key_right_press = True
            elif event.key.keysym.sym == SDLK_LSHIFT:
                key_shift_down = True
            elif event.key.keysym.sym == SDLK_RSHIFT:
                key_shiftr_down = True
            elif event.key.keysym.sym == SDLK_LCTRL:
                key_ctrl_down = True
            elif event.key.keysym.sym == SDLK_RCTRL:
                key_rctrl_down = True
            elif event.key.keysym.sym == SDLK_HOME:
                key_home_press = True
            elif event.key.keysym.sym == SDLK_END:
                key_end_press = True
            elif event.key.keysym.sym == SDLK_LGUI:
                key_meta = True


        elif event.type == SDL_KEYUP:
            k_input = True
            power += 5
            gui.update += 2
            if event.key.keysym.sym == SDLK_LSHIFT:
                key_shift_down = False
            elif event.key.keysym.sym == SDLK_LCTRL:
                key_ctrl_down = False
            elif event.key.keysym.sym == SDLK_RCTRL:
                key_rctrl_down = False
            elif event.key.keysym.sym == SDLK_RSHIFT:
                key_shiftr_down = False
            elif event.key.keysym.sym == SDLK_RALT:
                gui.album_tab_mode = False
                key_ralt = False
            elif event.key.keysym.sym == SDLK_LALT:
                gui.album_tab_mode = False
                key_lalt = False
            elif event.key.keysym.sym == SDLK_LGUI:
                key_meta = False

        elif event.type == SDL_TEXTINPUT:
            k_input = True
            power += 5
            input_text = event.text.text
            input_text = input_text.decode('utf-8')
            gui.update += 1
            #print(input_text)

        elif event.type == SDL_MOUSEWHEEL:
            k_input = True
            power += 6
            mouse_wheel += event.wheel.y
            gui.update += 1
        elif event.type == SDL_WINDOWEVENT:

            power += 5
            # print(event.window.event)

            if event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED:

                gnome.focus()
                k_input = True

                mouse_enter_window = True

                focused = True
                key_focused = 2
                mouse_down = False
                gui.album_tab_mode = False
                gui.pl_update = 1
                gui.update += 1

            elif event.window.event == SDL_WINDOWEVENT_FOCUS_LOST:
                for instance in Menu.instances:
                    instance.active = False

                gui.update += 1

            elif event.window.event == SDL_WINDOWEVENT_RESIZED:

                if restore_ignore_timer.get() > 1:  # Hacky
                    gui.update = 2
                    window_size[0] = event.window.data1
                    window_size[1] = event.window.data2

                    if gui.mode != 3:
                        window_size[0] = max(560, window_size[0])
                        window_size[1] = max(330, window_size[1])


                    update_layout = True

            elif event.window.event == SDL_WINDOWEVENT_ENTER:

                mouse_enter_window = True

            # elif event.window.event == SDL_WINDOWEVENT_HIDDEN:
            #
            elif event.window.event == SDL_WINDOWEVENT_EXPOSED:
                # print("expose")
                gui.lowered = False

            elif event.window.event == SDL_WINDOWEVENT_MINIMIZED:
                gui.lowered = True
                if prefs.min_to_tray:
                    tray.down()

            elif event.window.event == SDL_WINDOWEVENT_RESTORED:

                # print("RESTORE")
                gui.lowered = False
                gui.maximized = False
                gui.pl_update = 1
                gui.update += 1

                if update_title:
                    update_title_do()
                    # print("restore")

            elif event.window.event == SDL_WINDOWEVENT_SHOWN:
                focused = True
                gui.pl_update = 1
                gui.update += 1

            # elif event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED:
            #
            #     input.mouse_enter_event = True
            #     gui.update += 1
            #     k_input = True

            elif event.window.event == SDL_WINDOWEVENT_MAXIMIZED:
                gui.maximized = True
                print("Maximize window")
                update_layout = True
                gui.pl_update = 1
                gui.update += 1

    if mouse_moved:
        if fields.test():
            gui.update += 1

    if gui.request_raise:
        gui.request_raise = False
        if gui.lowered:
            SDL_RestoreWindow(t_window)
            SDL_RaiseWindow(t_window)
            gui.lowered = False

    # ----------------
    # This section of code controls the internal processing speed or 'frame-rate'.
    # It's pretty messy.

    power += 1

    if gui.frame_callback_list:
        i = len(gui.frame_callback_list) - 1
        while i >= 0:
            if gui.frame_callback_list[i].test():
                gui.update = 1
                power = 1000
                del gui.frame_callback_list[i]
            i -= 1

    if animate_monitor_timer.get() < 1 or load_orders:

        if cursor_blink_timer.get() > 0.65:
            cursor_blink_timer.set()
            TextBox.cursor ^= True
            gui.update = 1

        if k_input:
            cursor_blink_timer.set()
            TextBox.cursor = True

        SDL_Delay(3)
        power = 1000

    if mouse_wheel or k_input or gui.pl_update or gui.update or top_panel.adds or transcode_list: # or mouse_moved:
        power = 1000

    if prefs.art_bg and core_timer.get() < 3:
        power = 1000

    if mouse_down:
        power = 1000

    if gui.level_update and not album_scroll_hold and not scroll_hold:
        power = 500

    if gui.vis == 3 and (pctl.playing_state == 1 or pctl.playing_state == 3):
        power = 500
        if len(gui.spec2_buffers) > 0 and gui.spec2_timer.get() > 0.04:
            gui.spec2_timer.set()
            gui.level_update = True
            vis_update = True
        else:
            SDL_Delay(5)

    if not pctl.running:
        break

    if pctl.playing_state > 0 or pctl.broadcast_active:
        power += 400

    if power < 500:

        SDL_Delay(30)

        if pctl.playing_state == 0 and not load_orders and gui.update == 0 and not gall_ren.queue and not mouse_down:
                SDL_WaitEventTimeout(None, 1000)

                check_transfer_p()

        continue

    else:
        power = 0


    if mouse_down and not k_input:

        # Force update (for smooth scrolling) when mouse down (A little hacky)

        gui.update = 1

        # We could impose a minimum frame time here...
        # But waiting any time seems to cause scroll animations to be less smooth.
        # Most computers now have many cores/threads so perhaps its not so bad to
        # breiefly run a thread at 100% to ensure a smooth animation.

        # time.sleep(0.002)


    if gui.pl_update > 2:
        gui.pl_update = 2

    new_playlist_cooldown = False

    check_transfer_p()

    # if check_file_timer.get() > 1.1:
    #     check_file_timer.set()
    #     if os.path.isfile(transfer_target):
    #         r_arg_queue = pickle.load(open(transfer_target, "rb"))
    #         os.remove(user_directory + "/transfer.p")
    #         arg_queue = []
    #         i = 0
    #         for item in r_arg_queue:
    #             if (os.path.isdir(item) or os.path.isfile(item)) and '.py' not in item:
    #                 arg_queue.append(item)
    #                 i += 1
    #
    #         if i == 0:
    #             SDL_RaiseWindow(t_window)
    #             SDL_RestoreWindow(t_window)
    #
    #     if arg_queue:
    #         i = 0
    #         while i < len(arg_queue):
    #             load_order = LoadClass()
    #
    #             for w in range(len(pctl.multi_playlist)):
    #                 if pctl.multi_playlist[w][0] == "Default":
    #                     load_order.playlist = pctl.multi_playlist[w][6] # copy.deepcopy(w)
    #                     break
    #             else:
    #                 # pctl.multi_playlist.append(["Default", 0, [], 0, 0, 0])
    #                 pctl.multi_playlist.append(pl_gen())
    #                 load_order.playlist = pctl.multi_playlist[len(pctl.multi_playlist) - 1][6]
    #                 switch_playlist(len(pctl.multi_playlist) - 1)
    #
    #             load_order.target = arg_queue[i]
    #             load_orders.append(copy.deepcopy(load_order))
    #
    #             i += 1
    #         arg_queue = []
    #         gui.auto_play_import = True


    if mouse_down and not coll((2, 2, window_size[0] - 4, window_size[1] - 4)):
        #print(SDL_GetMouseState(None, None))
        if SDL_GetGlobalMouseState(None, None) == 0:

            mouse_down = False
            mouse_up = True
            quick_drag = False

    # print(window_size)
    # if window_size[0] / window_size[1] == 16 / 9:
    #     print('OK')
    # if window_size[0] / window_size[1] > 16 / 9:
    #     print("A")

    if k_input:

        if mouse_enter_window:
            input.key_return_press = False

        if input.mouse_click or right_click:
            last_click_location = copy.deepcopy(click_location)
            click_location = copy.deepcopy(mouse_position)

        if keymaps.test("toggle-fullscreen"):
            if not fullscreen and not gui.mode == 3:
                fullscreen = True
                SDL_SetWindowFullscreen(t_window, SDL_WINDOW_FULLSCREEN_DESKTOP)
            elif fullscreen:
                fullscreen = False
                SDL_SetWindowFullscreen(t_window, 0)

        if fullscreen and key_esc_press:
            fullscreen = False
            SDL_SetWindowFullscreen(t_window, 0)


        # Disable keys for text cursor control
        if not gui.rename_folder_box and not renamebox and not gui.rename_playlist_box and not radiobox and not pref_box.enabled:


            if not quick_search_mode and not search_over.active:
                if album_mode and gui.album_tab_mode \
                        and not key_ctrl_down \
                        and not key_meta \
                        and not key_lalt:
                    if key_left_press:
                        gal_left = True
                        key_left_press = False
                    if key_right_press:
                        gal_right = True
                        key_right_press = False
                    if key_up_press:
                        gal_up = True
                        key_up_press = False
                    if key_down_press:
                        gal_down = True
                        key_down_press = False

            if key_del:
                # Close any active menus
                for instance in Menu.instances:
                    instance.active = False
                del_selected()


            # Arrow keys to change playlist
            if (key_left_press or key_right_press) and len(pctl.multi_playlist) > 1 \
                    and not search_over.active:
                    #and not key_shiftr_down\
                    #and not key_shift_down\

                    #and not key_ctrl_down\
                    #and not key_rctrl_down\
                    # and not key_meta\
                    # and not key_lalt\
                    # and not key_ralt:

                gui.pl_update = 1
                gui.update += 1
                if gui.lsp:
                    if keymaps.test('cycle-playlist-left'):
                        switch_playlist(-1, True)
                    if keymaps.test('cycle-playlist-right'):
                        switch_playlist(1, True)
                else:
                    if keymaps.test('cycle-playlist-left'):
                        p = pctl.active_playlist_viewing
                        le = len(pctl.multi_playlist)
                        on = p
                        on -= 1
                        while True:
                            if on < 0:
                                on = le - 1
                            if on == p:
                                break
                            if pctl.multi_playlist[on][8] is False:
                                switch_playlist(on)
                                break
                            on -= 1

                    if keymaps.test('cycle-playlist-right'):
                        p = pctl.active_playlist_viewing
                        le = len(pctl.multi_playlist)
                        on = p
                        on += 1
                        while True:
                            if on == le:
                                on = 0
                            if on == p:
                                break
                            if pctl.multi_playlist[on][8] is False:
                                switch_playlist(on)
                                break
                            on += 1

            if keymaps.test("start"):
                if pctl.playing_time < 4:
                    pctl.back()
                else:
                    pctl.new_time = 0
                    pctl.playing_time = 0
                    pctl.decode_time = 0
                    pctl.playerCommand = 'seek'
                    pctl.playerCommandReady = True

            if keymaps.test("goto-top"):
                pctl.playlist_view_position = 0
                playlist_selected = 0
                gui.pl_update = 1

            if keymaps.test("goto-bottom"):
                n = len(default_playlist) - gui.playlist_view_length + 1
                if n < 0:
                    n = 0
                pctl.playlist_view_position = n
                playlist_selected = len(default_playlist) - 1
                gui.pl_update = 1



        if not quick_search_mode and not pref_box.enabled and not radiobox and not renamebox \
                and not gui.rename_folder_box \
                and not gui.rename_playlist_box and not search_over.active:

            if key_c_press and key_ctrl_down:
                gui.pl_update = 1
                s_copy()

            if key_x_press and key_ctrl_down:
                gui.pl_update = 1
                s_cut()

            if key_v_press and key_ctrl_down:
                gui.pl_update = 1

                clip = copy_from_clipboard()
                if clip:
                    clip = clip.split("\n")
                    for i, line in enumerate(clip):
                        if line.startswith("file://"):
                            target = str(urllib.parse.unquote(line)).replace("file://", "").replace("\r", "")
                            load_order = LoadClass()
                            load_order.target = target
                            load_order.playlist = pctl.multi_playlist[pctl.active_playlist_viewing][6]
                            load_orders.append(copy.deepcopy(load_order))
                else:
                    paste()

            if keymaps.test("playpause"):
                if pctl.playing_state == 0:
                    pctl.play()
                else:
                    pctl.pause()

            if keymaps.test("add-to-queue") and pctl.selected_ready():

                gui.pl_update += 1

                if gui.album_tab_mode:
                    add_album_to_queue(default_playlist[get_album_info(playlist_selected)[1][0]], playlist_selected)

                else:
                    # pctl.force_queue.append([default_playlist[playlist_selected],
                    #                          playlist_selected, pl_to_id(pctl.active_playlist_viewing), 0, 0,
                    #                          uid_gen()])
                    pctl.force_queue.append(queue_item_gen(default_playlist[playlist_selected],
                                             playlist_selected, pl_to_id(pctl.active_playlist_viewing)))


        if input.key_return_press and (gui.rename_folder_box or renamebox or radiobox):
            input.key_return_press = False
            input.level_2_enter = True

        if keymaps.test("playlist-toggle-breaks"):
            # Toggle force off folder break for viewed playlist
            pctl.multi_playlist[pctl.active_playlist_viewing][4] ^= 1
            gui.pl_update = 1


        if keymaps.test("find-playing-artist"):
            #standard_size()
            if len(pctl.track_queue) > 0:
                quick_search_mode = True
                search_text.text = ""
                input_text = pctl.playing_object().artist


        if key_ctrl_down and key_z_press:
            undo.undo()
            # if pctl.playlist_backup:
            #     pctl.multi_playlist.append(pctl.playlist_backup.pop())
            # else:
            #     show_message("There are no more playlists to un-delete.")

        if keymaps.test("show-encode-folder"):
            open_encode_out()

        if keymaps.test('toggle-left-panel'):
            gui.lsp ^= True
            update_layout_do()

        if keymaps.test("toggle-broadcast"):
            toggle_broadcast()

        # print(keymaps.maps)
        # print(keymaps.hits)

        if keymaps.test('testkey'): #  F7: test


            pass

        if gui.mode < 3:
            if keymaps.test("toggle-auto-theme"):
                prefs.colour_from_image ^= True
                if prefs.colour_from_image:
                    show_message(_("Enabled auto theme"))
                else:
                    show_message(_("Disabled auto theme"))
                    themeChange = True
                    gui.theme_temp_current = -1

            if mouse4 or keymaps.test("toggle-gallery"):
                toggle_album_mode()

            if mouse5 or keymaps.test("toggle-right-panel"):
                if gui.combo_mode:
                    switch_showcase()
                elif not album_mode:
                    toggle_side_panel()
                else:
                    toggle_album_mode()

            if keymaps.test("toggle-minimode"):
                set_mini_mode()
                gui.update += 1

            if keymaps.test("cycle-layouts"):

                if view_box.tracks():
                    view_box.side(True)
                elif view_box.side():
                    view_box.gallery1(True)
                elif view_box.gallery1():
                    view_box.lyrics(True)
                else:
                    view_box.tracks(True)

            if keymaps.test("cycle-layouts-reverse"):

                if view_box.tracks():
                    view_box.lyrics(True)
                elif view_box.lyrics():
                    view_box.gallery1(True)
                elif view_box.gallery1():
                    view_box.side(True)
                else:
                    view_box.tracks(True)


            if keymaps.test("toggle-columns"):
                view_box.col(True)

            if keymaps.test("toggle-artistinfo"):
                view_box.artist_info(True)

            if keymaps.test("toggle-showcase"):
                view_box.lyrics(True)

            if keymaps.test("toggle-gallery-keycontrol"):
                if not album_mode:
                    toggle_album_mode()
                    gui.gall_tab_enter = True
                    gui.album_tab_mode = True
                    show_in_gal(playlist_selected, silent=True)
                elif gui.gall_tab_enter:
                    # Exit gallery and tab mode
                    toggle_album_mode()
                else:
                    gui.album_tab_mode ^= True
                    if gui.album_tab_mode:
                        show_in_gal(playlist_selected, silent=True)

        elif gui.mode == 3:
            if keymaps.test("toggle-minimode"):
                restore_full_mode()
                gui.update += 1

        ab_click = False

        if key_a_press and key_ctrl_down:
            gui.pl_update = 1
            shift_selection = range(len(default_playlist))


        if key_t_press and key_ctrl_down:
            new_playlist()

        if keymaps.test("delete-playlist"):
            delete_playlist(pctl.active_playlist_viewing)

        if keymaps.test("rename-playlist"):
            rename_playlist(pctl.active_playlist_viewing)
            rename_box.x = 60 * gui.scale
            rename_box.y = 60 * gui.scale

        # Transfer click register to menus
        if input.mouse_click:
            for instance in Menu.instances:
                if instance.active:
                    instance.click()
                    input.mouse_click = False
                    ab_click = True

        if input.mouse_click and (radiobox or search_over.active or gui.rename_folder_box or gui.rename_playlist_box or renamebox or view_box.active or filter_box.active) and not gui.message_box:
            input.mouse_click = False
            gui.level_2_click = True
        else:
            gui.level_2_click = False

        if track_box and input.mouse_click:
            w = 540
            h = 240
            x = int(window_size[0] / 2) - int(w / 2)
            y = int(window_size[1] / 2) - int(h / 2)
            if coll([x, y, w, h]):
                input.mouse_click = False
                gui.level_2_click = True

        if pref_box.enabled:

            if pref_box.inside():
                if input.mouse_click:
                    pref_box.click = True
                    input.mouse_click = False
                if right_click:
                    right_click = False
                    pref_box.right_click = True

                pref_box.scroll = mouse_wheel
                mouse_wheel = 0
            else:
                if input.mouse_click:
                    pref_box.enabled = False
                    if gui.opened_config_file == True:
                        input.mouse_click = False
                        show_message('Remember to click "Reload Config File" if you made changes or they will be lost')
                    fader.fall()
                if right_click:
                    pref_box.enabled = False
                    fader.fall()
                if pref_box.lock is False:
                    pass

        if right_click:
            level_2_right_click = True

        if right_click and (radiobox or renamebox or gui.rename_playlist_box or gui.rename_folder_box or search_over.active):
            right_click = False

        if mouse_wheel != 0:
            gui.update += 1
        if mouse_down is True:
            gui.update += 1

        if keymaps.test('pagedown'): #key_PGD:
            if len(default_playlist) > 10:
                pctl.playlist_view_position += gui.playlist_view_length - 4
                if pctl.playlist_view_position > len(default_playlist):
                    pctl.playlist_view_position = len(default_playlist) - 2
                gui.pl_update = 1
        if keymaps.test('pageup'):
            if len(default_playlist) > 0:
                pctl.playlist_view_position -= gui.playlist_view_length - 4
                if pctl.playlist_view_position < 0:
                    pctl.playlist_view_position = 0
                gui.pl_update = 1


        if quick_search_mode is False and renamebox is False and gui.rename_folder_box is False and gui.rename_playlist_box is False and not pref_box.enabled and not radiobox:


            if keymaps.test("info-playing"):
                if playlist_selected < len(default_playlist):
                    r_menu_index = pctl.g(default_playlist[playlist_selected]).index
                    track_box = True

            if keymaps.test("info-show"):
                if playlist_selected < len(default_playlist):
                    r_menu_index = pctl.g(default_playlist[playlist_selected]).index
                    track_box = True

            if keymaps.test("advance"):
                key_right_press = False
                pctl.advance()

            if keymaps.test("previous"):
                key_left_press = False
                pctl.back()

            if keymaps.test("vol-down"):
                if pctl.player_volume > 3:
                    pctl.player_volume -= 3
                else:
                    pctl.player_volume = 0
                pctl.set_volume()

            if keymaps.test("vol-up"):
                pctl.player_volume += 3
                if pctl.player_volume > 100:
                    pctl.player_volume = 100
                pctl.set_volume()



            if keymaps.test("revert"):
                pctl.revert()
            if keymaps.test("random-track-start"):
                pctl.advance(rr=True)

            if keymaps.test("toggle-shuffle"):
                pctl.random_mode ^= True

            if keymaps.test("goto-playing"):
                pctl.show_current()
            if keymaps.test("goto-previous"):
                if pctl.queue_step > 1:
                    pctl.show_current(index=pctl.track_queue[pctl.queue_step - 1])

            if keymaps.test("toggle-repeat"):
                pctl.repeat_mode ^= True

            if keymaps.test("random-track"):
                random_track()


            if keymaps.test('opacity-up'):
                prefs.window_opacity += .05
                if prefs.window_opacity > 1:
                    prefs.window_opacity = 1
                SDL_SetWindowOpacity(t_window, prefs.window_opacity)

            if keymaps.test('opacity-down'):
                prefs.window_opacity -= .05
                if prefs.window_opacity < .30:
                    prefs.window_opacity = .30
                SDL_SetWindowOpacity(t_window, prefs.window_opacity)

            if keymaps.test("seek-forward"):
                pctl.new_time = pctl.playing_time + 15
                pctl.playing_time += 15
                pctl.playerCommand = 'seek'
                pctl.playerCommandReady = True

            if keymaps.test("seek-back"):
                pctl.new_time = pctl.playing_time - 15
                pctl.playing_time -= 15
                if pctl.new_time < 0:
                    pctl.new_time = 0
                    pctl.playing_time = 0
                    pctl.decode_time = 0
                pctl.playerCommand = 'seek'
                pctl.playerCommandReady = True

            if keymaps.test("play"):
                pctl.play()

            if keymaps.test("stop"):
                pctl.stop()

            if keymaps.test("pause"):
                pctl.pause_only()

            if keymaps.test("love-playing"):
                bar_love()

            if keymaps.test("global-search"):
                toggle_search()

    # if mouse_position[1] < 1:
    #     mouse_down = False

    if mouse_down is False:
        scroll_hold = False

    # if focused is True:
    #     mouse_down = False

    if mediaKey_pressed:
        if mediaKey == 'Play':
            if pctl.playing_state == 0:
                pctl.play()
            else:
                pctl.pause()
        elif mediaKey == 'Pause':
            pctl.pause_only()
        elif mediaKey == 'Stop':
            pctl.stop()
        elif mediaKey == 'Next':
            pctl.advance()
        elif mediaKey == 'Previous':
            pctl.back()

        elif mediaKey == 'Rewind':
            pctl.seek_time(pctl.playing_time - 10)
        elif mediaKey == 'FastForward':
            pctl.seek_time(pctl.playing_time + 10)
        elif mediaKey == 'Repeat':
            pctl.repeat_mode ^= True
        elif mediaKey == 'Shuffle':
            pctl.shuffle_mode ^= True


        mediaKey_pressed = False

    if len(load_orders) > 0:
        loading_in_progress = True
        if loaderCommand == LC_None:
            for order in load_orders:
                if order.stage == 0:
                    order.traget = order.target.replace('\\', '/')
                    order.stage = 1
                    if os.path.isdir(order.traget):
                        loaderCommand = LC_Folder
                    else:
                        loaderCommand = LC_File
                        if '.xspf' in order.traget:
                            to_got = 'xspf'
                            to_get = 0
                        else:
                            to_got = 1
                            to_get = 1
                    loaderCommandReady = True
                    break

    elif loading_in_progress is True:
        loading_in_progress = False
        tauon.worker_save_state = True

    if loaderCommand == LC_Done:
        loaderCommand = LC_None
        gui.update += 1
        # gui.pl_update = 1
        # loading_in_progress = False

    if update_layout:

        update_layout_do()
        # update layout
        # C-UL
        update_layout = False

    # if tauon.worker_save_state and\
    #         not gui.pl_pulse and\
    #         not loading_in_progress and\
    #         not to_scan and\
    #         not plex.scanning and\
    #         not cm_clean_db and\
    #         not lastfm.scanning_friends and\
    #         not move_in_progress:
    #     save_state()
    #     cue_list.clear()
    #     tauon.worker_save_state = False

    # -----------------------------------------------------
    # THEME SWITCHER--------------------------------------------------------------------
    if keymaps.test("cycle-theme"):
        themeChange = True
        gui.theme_temp_current = -1
        gui.temp_themes.clear()
        theme += 1

    if themeChange is True:
        gui.light_mode = False
        gui.draw_frame = False
        gui.pl_update = 1
        if theme > 25:
            theme = 0
        if theme > 0:
            theme_number = theme - 1
            try:

                theme_files = get_themes()
                #print(theme_files)
                colours.column_colours.clear()
                colours.column_colours_playing.clear()

                for i, item in enumerate(theme_files):
                    # print(theme_files[i])
                    if i == theme_number:
                        colours.lm = False
                        colours.__init__()
                        with open(item[0], encoding="utf_8") as f:
                            content = f.readlines()
                            gui.theme_name = item[1]
                            print("Applying external theme: " + gui.theme_name)
                            for p in content:
                                if "#" in p:
                                    continue
                                if "light-mode" in p:
                                    colours.light_mode()
                                if 'draw-frame' in p:
                                    gui.draw_frame = True
                                if 'light-theme-mode' in p:
                                    gui.light_mode = True
                                    print("light mode")
                                if 'gallery highlight' in p:
                                    colours.gallery_highlight = get_colour_from_line(p)
                                if 'index playing' in p:
                                    colours.index_playing = get_colour_from_line(p)
                                if 'time playing' in p:
                                    colours.time_text = get_colour_from_line(p)
                                if 'artist playing' in p:
                                    colours.artist_playing = get_colour_from_line(p)
                                if 'album line' in p:
                                    colours.album_text = get_colour_from_line(p)
                                if 'album playing' in p:
                                    colours.album_playing = get_colour_from_line(p)
                                if 'player background' in p:
                                    colours.top_panel_background = get_colour_from_line(p)
                                if 'side panel' in p:
                                    colours.side_panel_background = get_colour_from_line(p)
                                if 'gallery background' in p:
                                    colours.gallery_background = get_colour_from_line(p)
                                if 'playlist panel' in p:
                                    colours.playlist_panel_background = get_colour_from_line(p)
                                if 'track line' in p:
                                    colours.title_text = get_colour_from_line(p)
                                if 'track missing' in p:
                                    colours.playlist_text_missing = get_colour_from_line(p)
                                if 'playing highlight' in p:
                                    colours.row_playing_highlight = get_colour_from_line(p)
                                if 'track time' in p:
                                    colours.bar_time = get_colour_from_line(p)
                                if 'fav line' in p:
                                    colours.star_line = get_colour_from_line(p)
                                if 'folder title' in p:
                                    colours.folder_title = get_colour_from_line(p)
                                if 'folder line' in p:
                                    colours.folder_line = get_colour_from_line(p)
                                if 'buttons off' in p:
                                    colours.media_buttons_off = get_colour_from_line(p)
                                if 'buttons over' in p:
                                    colours.media_buttons_over = get_colour_from_line(p)
                                if 'buttons active' in p:
                                    colours.media_buttons_active = get_colour_from_line(p)
                                if 'playing time' in p:
                                    colours.time_playing = get_colour_from_line(p)
                                if 'track index' in p:
                                    colours.index_text = get_colour_from_line(p)
                                if 'track playing' in p:
                                    colours.title_playing = get_colour_from_line(p)
                                if 'select highlight' in p:
                                    colours.row_select_highlight = get_colour_from_line(p)
                                if 'track artist' in p:
                                    colours.artist_text = get_colour_from_line(p)
                                if 'tab active line' in p:
                                    colours.tab_text_active = get_colour_from_line(p)
                                if 'tab line' in p:
                                    colours.tab_text = get_colour_from_line(p)
                                if 'tab background' in p:
                                    colours.tab_background = get_colour_from_line(p)
                                if 'tab over' in p:
                                    colours.tab_highlight = get_colour_from_line(p)
                                if 'tab active background' in p:
                                    colours.tab_background_active = get_colour_from_line(p)
                                if 'title info' in p:
                                    colours.side_bar_line1 = get_colour_from_line(p)
                                if 'extra info' in p:
                                    colours.side_bar_line2 = get_colour_from_line(p)
                                if 'scroll bar' in p:
                                    colours.scroll_colour = get_colour_from_line(p)
                                if 'seek bar' in p:
                                    colours.seek_bar_fill = get_colour_from_line(p)
                                if 'seek bg' in p:
                                    colours.seek_bar_background = get_colour_from_line(p)
                                if 'volume bar' in p:
                                    colours.volume_bar_fill = get_colour_from_line(p)
                                if 'volume bg' in p:
                                    colours.volume_bar_background = get_colour_from_line(p)
                                if 'mode off' in p:
                                    colours.mode_button_off = get_colour_from_line(p)
                                if 'mode over' in p:
                                    colours.mode_button_over = get_colour_from_line(p)
                                if 'mode on' in p:
                                    colours.mode_button_active = get_colour_from_line(p)
                                if 'art border' in p:
                                    colours.art_box = get_colour_from_line(p)
                                if 'sep line' in p:
                                    colours.sep_line = get_colour_from_line(p)
                                if 'bb line' in p:
                                    colours.bb_line = get_colour_from_line(p)
                                if 'tb line' in p:
                                    colours.tb_line = get_colour_from_line(p)
                                if 'music vis' in p:
                                    colours.vis_colour = get_colour_from_line(p)
                                if 'menu background' in p:
                                    colours.menu_background = get_colour_from_line(p)
                                if 'menu text' in p:
                                    colours.menu_text = get_colour_from_line(p)
                                if 'menu disable' in p:
                                    colours.menu_text_disabled = get_colour_from_line(p)
                                if 'menu highlight' in p:
                                    colours.menu_highlight_background = get_colour_from_line(p)
                                if 'lyrics showcase' in p:
                                    colours.lyrics = get_colour_from_line(p)
                                if 'bottom panel' in p:
                                    colours.bottom_panel_colour = get_colour_from_line(p)
                                    colours.menu_background = colours.bottom_panel_colour
                                if 'mini bg' in p:
                                    colours.mini_mode_background = get_colour_from_line(p)
                                if 'mini border' in p:
                                    colours.mini_mode_border = get_colour_from_line(p)
                                if 'column-' in p:
                                    key = p[p.find("column-") + 7:].replace("-", " ").lower().title().rstrip()
                                    value = get_colour_from_line(p)
                                    colours.column_colours[key] = value
                                if 'column+' in p:
                                    key = p[p.find("column+") + 7:].replace("-", " ").lower().title().rstrip()
                                    value = get_colour_from_line(p)
                                    colours.column_colours_playing[key] = value

                            colours.post_config()
                            if colours.lm:
                                colours.light_mode()
                            # temp
                            #colours.menu_highlight_background = [40, 40, 40, 255]

                        break
                else:
                    theme = 0
            except:
                # raise
                show_message("Error loading theme file", 'warning', "")

        if theme == 0:
            gui.theme_name = "Mindaro"
            print("Applying default theme: Mindaro")
            colours.lm = False
            colours.__init__()
            colours.post_config()

        print("Theme number: " + str(theme))
        themeChange = False
        ddt.text_background_colour = colours.playlist_panel_background

    # ---------------------------------------------------------------------------------------------------------
    # GUI DRAWING------
    # print(gui.update)
    # print(gui.lowered)
    if gui.mode == 3:
        gui.pl_update = 0

    if gui.pl_update and not gui.update:
        gui.update = 1

    if gui.update > 0 and gui.lowered != True and not resize_mode:
        if gui.update > 2:
            gui.update = 2

        SDL_SetRenderTarget(renderer, None)
        SDL_SetRenderDrawColor(renderer, colours.top_panel_background[0], colours.top_panel_background[1],
                               colours.top_panel_background[2], colours.top_panel_background[3])
        SDL_RenderClear(renderer)
        SDL_SetRenderTarget(renderer, gui.main_texture)
        SDL_RenderClear(renderer)

        # perf_timer.set()

        mouse_position[0], mouse_position[1] = get_sdl_input.mouse()

        fields.clear()
        gui.cursor_want = 0

        gui.layer_focus = 0
        if filter_box.active:
            gui.layer_focus = 1

        if input.mouse_click:
            n_click_time = time.time()
            if n_click_time - click_time < 0.42:
                d_mouse_click = True
            click_time = n_click_time

        if input.mouse_click or mouse_wheel or right_click:
            mouse_position[0], mouse_position[1] = get_sdl_input.mouse()

        if gui.mode == 1 or gui.mode == 2:

            ddt.text_background_colour = colours.playlist_panel_background

            # Side Bar Draging----------

            if mouse_down is not True:
                side_drag = False

            rect = (window_size[0] - gui.rspw - 5 * gui.scale, gui.panelY, 12 * gui.scale,
                            window_size[1] - gui.panelY - gui.panelBY)
            fields.add(rect)

            if (coll(rect) or side_drag is True) \
                    and renamebox is False \
                    and radiobox is False \
                    and gui.rename_playlist_box is False \
                    and gui.message_box is False \
                    and pref_box.enabled is False \
                    and track_box is False \
                    and not gui.rename_folder_box \
                    and extra_menu.active is False\
                    and (gui.rsp or album_mode)\
                    and not x_menu.active \
                    and not view_menu.active \
                    and not track_menu.active \
                    and not tab_menu.active \
                    and not selection_menu.active\
                    and not view_box.active \
                    and not folder_menu.active \
                    and not set_menu.active \
                    and not artist_info_scroll.held \
                    and gui.layer_focus == 0:

                #update_layout = True

                if side_drag != True:
                    draw_sep_hl = True

                if input.mouse_click:
                    side_drag = True
                    gui.side_bar_drag_source = mouse_position[0]
                    gui.side_bar_drag_original = gui.rspw

                if not quick_drag:
                    gui.cursor_want = 1

            # side drag update
            if side_drag is True:

                offset = gui.side_bar_drag_source - mouse_position[0]

                target = gui.side_bar_drag_original + offset

                # Reset max ratio if drag drops below ratio width
                if target < round((window_size[1] - gui.panelY - gui.panelBY) * gui.art_aspect_ratio):
                    gui.art_max_ratio_lock = gui.art_aspect_ratio

                max_w = round(((window_size[1] - gui.panelY - gui.panelBY - 17 * gui.scale) * gui.art_max_ratio_lock) + 17 * gui.scale)
                # 17 here is the art box inset value

                if not album_mode and target > max_w:
                    target = max_w

                    gui.rspw = target
                else:
                    gui.rspw = target

                if album_mode:
                    gui.rspw = target

                if album_mode and gui.rspw < album_mode_art_size + 50 * gui.scale:
                    gui.rspw = album_mode_art_size + 50 * gui.scale
                #gui.update_layout()


                # Prevent side bar getting too small
                if gui.rspw < 120 * gui.scale:
                    gui.rspw = 120 * gui.scale


                update_layout_do()

                # Remember size for this view mode
                if not album_mode:
                    gui.pref_rspw = gui.rspw
                else:
                    gui.pref_gallery_w = gui.rspw


            # ALBUM GALLERY RENDERING:
            # Gallery view
            # C-AR

            if album_mode:

                if gal_right:
                    gal_right = False
                    gal_jump_select(False, 1)
                    goto_album(playlist_selected)
                    pctl.playlist_view_position = playlist_selected
                    gui.pl_update = 1

                if gal_down:
                    gal_down = False
                    gal_jump_select(False, row_len)
                    goto_album(playlist_selected, down=True)
                    pctl.playlist_view_position = playlist_selected
                    gui.pl_update = 1

                if gal_left:
                    gal_left = False
                    gal_jump_select(True, 1)
                    goto_album(playlist_selected)
                    pctl.playlist_view_position = playlist_selected
                    gui.pl_update = 1

                if gal_up:
                    gal_up = False
                    gal_jump_select(True, row_len)
                    goto_album(playlist_selected)
                    pctl.playlist_view_position = playlist_selected
                    gui.pl_update = 1


                # if not gui.show_playlist:
                #     rect = [0, gui.panelY, window_size[0],
                #             window_size[1] - gui.panelY - gui.panelBY - 0]
                #     ddt.rect_r(rect, colours.side_panel_background, True)
                # else:

                w = gui.rspw
                x = window_size[0] - w
                h = window_size[1] - gui.panelY - gui.panelBY

                rect = [x, gui.panelY, w, h]
                ddt.rect_r(rect, colours.gallery_background, True)

                area_x = w + 38 * gui.scale

                row_len = int((area_x - album_h_gap) / (album_mode_art_size + album_h_gap))

                # print(row_len)

                compact = 40 * gui.scale
                a_offset = 7 * gui.scale

                l_area = x
                r_area = w
                c_area = r_area // 2 + l_area

                ddt.text_background_colour = colours.gallery_background

                line1_colour = colours.gallery_artist_line
                line2_colour = colours.side_bar_line1

                if colours.side_panel_background != colours.gallery_background:
                    # Why? idk, might not make much difference
                    line2_colour = [220, 220, 220, 255]
                    line1_colour = alpha_mod([220, 220, 220, 255], 120)
                    #line1_colour = [200, 200, 200, 255]

                if test_lumi(colours.gallery_background) < 0.5 or (prefs.use_card_style and colours.lm):
                    line1_colour = colours.grey(80)
                    line2_colour = colours.grey(40)

                if row_len == 0:
                    row_len = 1
                dev = int((r_area - compact) / (row_len + 0))

                render_pos = 0
                album_on = 0

                max_scroll = round((math.ceil((len(album_dex)) / row_len) - 1) * (album_mode_art_size + album_v_gap)) - 55

                if mouse_position[0] > window_size[0] - w and gui.panelY < mouse_position[1] < window_size[1] - gui.panelBY:
                    if prefs.gallery_row_scroll:
                        album_pos_px -= mouse_wheel * (album_mode_art_size + album_v_gap)  # 90
                    else:
                        album_pos_px -= mouse_wheel * prefs.gallery_scroll_wheel_px

                    if album_pos_px < -55:
                        album_pos_px = -55
                        gallery_pulse_top.pulse()

                    if album_pos_px > max_scroll:
                        album_pos_px = max_scroll

                gallery_pulse_top.render(gui.plw + 5 * gui.scale, gui.panelY + 1, window_size[0] - gui.plw, 2)

                # ----
                rect = (gui.gallery_scroll_field_left, gui.panelY, 5 + window_size[0] - gui.gallery_scroll_field_left, h)

                excl_rect = (0,0,0,0)

                if gui.power_bar is not None and len(gui.power_bar) > 2:

                    excl_rect = (window_size[0] - 22 * gui.scale, gui.panelY, 20 * gui.scale, (len(gui.power_bar) * 28 * gui.scale) + 2)

                rect_up = (rect[0], rect[1], rect[2], round(rect[3] * 0.5))
                rect_down = (rect[0], rect[1] + round(rect[3] * 0.5) + 1, rect[2], round(rect[3] * 0.5))

                if mouse_down:
                    # rect = (window_size[0] - 30, gui.panelY, 30, window_size[1] - gui.panelBY - gui.panelY)
                    if coll(rect) and not coll(excl_rect):
                        # if mouse_position[1] > window_size[1] / 2:
                        #     album_pos_px += 30
                        # else:
                        #     album_pos_px -= 30
                        album_scroll_hold = True
                        tt = scroll_timer.hit()
                        if tt > 1:
                            mv = 0
                        else:
                            mv = int(tt * 1500 * gui.scale)
                            if mv < 30:
                                if coll(rect_down):#mouse_position[1] > (rect[1] + rect[3]) * 0.5:
                                    album_pos_px += mv
                                else:
                                    album_pos_px -= mv
                else:
                    album_scroll_hold = False

                if gui.power_bar is not None and len(gui.power_bar) > 2:

                    pass

                else:

                    fields.add(rect)

                    fields.add(rect_up)
                    fields.add(rect_down)

                    if coll(rect):
                        right = window_size[0] - 25 * gui.scale

                        colour = alpha_mod(colours.side_bar_line2, 100)
                        if coll(rect_up):
                            colour = alpha_mod(colours.side_bar_line2, 210)


                        ddt.draw_text((right, (int((rect[1] + rect[3]) * 0.25))), "â²",
                                  colour, 13)

                        colour = alpha_mod(colours.side_bar_line2, 100)
                        if coll(rect_down):
                            colour = alpha_mod(colours.side_bar_line2, 210)

                        ddt.draw_text((right, (int((rect[1] + rect[3]) * 0.75))), "â¼",
                                  colour, 13)

                if right_click:

                    if coll(rect):
                        per = (mouse_position[1] - gui.panelY - 25 * gui.scale) / (window_size[1] - gui.panelBY - gui.panelY)
                        if per > 100:
                            per = 100
                        if per < 0:
                            per = 0
                        album_pos_px = int((len(album_dex) / row_len) * (album_mode_art_size + album_v_gap) * per) - 50 * gui.scale



                if last_row != row_len:
                    last_row = row_len

                    goto_album(pctl.playlist_playing_position)

                # Process inputs first
                if (input.mouse_click or right_click or middle_click) and default_playlist:
                    while render_pos < album_pos_px + window_size[1]:

                        if b_info_bar and render_pos > album_pos_px + b_info_y:
                            break

                        if render_pos < album_pos_px - album_mode_art_size - album_v_gap:
                            # Skip row
                            render_pos += album_mode_art_size + album_v_gap
                            album_on += row_len
                        else:
                            # render row
                            y = render_pos - album_pos_px
                            row_x = 0
                            for a in range(row_len):
                                if album_on > len(album_dex) - 1:
                                    break

                                x = (l_area + dev * a) - int(album_mode_art_size / 2) + int(dev / 2) + int(
                                    compact / 2) - a_offset

                                if album_dex[album_on] > len(default_playlist):
                                    break

                                extend = 0
                                if card_mode: #gui.gallery_show_text:
                                    extend = 40 * gui.scale

                                if coll((
                                        x, y, album_mode_art_size, album_mode_art_size + extend * gui.scale)) and gui.panelY < mouse_position[
                                    1] < window_size[1] - gui.panelBY:

                                    info = get_album_info(album_dex[album_on])

                                    if input.mouse_click:

                                        if prefs.gallery_single_click:

                                            if info[0] == 1 and pctl.playing_state == 2:
                                                pctl.play()
                                            elif info[0] == 1 and pctl.playing_state > 0:
                                                pctl.playlist_view_position = album_dex[album_on]
                                            else:
                                                pctl.playlist_view_position = album_dex[album_on]
                                                pctl.jump(default_playlist[album_dex[album_on]], album_dex[album_on])

                                            pctl.show_current()

                                        else:

                                            if d_click_timer.get() < 1 and gui.d_click_ref == album_dex[album_on]:

                                                if info[0] == 1 and pctl.playing_state == 2:
                                                    pctl.play()
                                                elif info[0] == 1 and pctl.playing_state > 0:
                                                    pctl.playlist_view_position = album_dex[album_on]
                                                else:
                                                    pctl.playlist_view_position = album_dex[album_on]
                                                    pctl.jump(default_playlist[album_dex[album_on]], album_dex[album_on])

                                            else:
                                                gui.d_click_ref = album_dex[album_on]
                                                d_click_timer.set()


                                            pctl.playlist_view_position = album_dex[album_on]
                                            playlist_selected = album_dex[album_on]
                                            gui.pl_update += 1



                                    elif middle_click:
                                        # Middle click to add album to queue

                                        # if prefs.finish_current:
                                        #     finish_current()

                                        partway = 0
                                        if not pctl.force_queue:
                                            if pctl.g(
                                                    default_playlist[album_dex[album_on]]).parent_folder_path == pctl.playing_object().parent_folder_path:
                                                partway = 1

                                        # pctl.force_queue.append([default_playlist[album_dex[album_on]],
                                        #                          album_dex[album_on],
                                        #                          pl_to_id(pctl.active_playlist_viewing), 1, partway,
                                        #                          uid_gen()])
                                        pctl.force_queue.append(queue_item_gen(default_playlist[album_dex[album_on]],
                                                                 album_dex[album_on],
                                                                 pl_to_id(pctl.active_playlist_viewing), 1, partway))


                                    else:
                                        playlist_selected = album_dex[album_on]
                                        #playlist_position = playlist_selected
                                        shift_selection = [playlist_selected]
                                        gallery_menu.activate(default_playlist[playlist_selected])

                                        shift_selection = []
                                        u = playlist_selected
                                        while u < len(default_playlist) and pctl.master_library[
                                                    default_playlist[u]].parent_folder_path == \
                                                pctl.master_library[
                                                    default_playlist[playlist_selected]].parent_folder_path:
                                            shift_selection.append(u)
                                            u += 1
                                        pctl.render_playlist()

                                album_on += 1

                            if album_on > len(album_dex):
                                break
                            render_pos += album_mode_art_size + album_v_gap


                render_pos = 0
                album_on = 0

                if not pref_box.enabled or mouse_wheel != 0:
                    gui.first_in_grid = None

                # Render album grid
                while render_pos < album_pos_px + window_size[1] and default_playlist:

                    if b_info_bar and render_pos > album_pos_px + b_info_y:
                        break

                    if render_pos < album_pos_px - album_mode_art_size - album_v_gap:
                        # Skip row
                        render_pos += album_mode_art_size + album_v_gap
                        album_on += row_len
                    else:
                        # render row
                        y = render_pos - album_pos_px

                        row_x = 0

                        if y > window_size[1] - gui.panelBY - 30 * gui.scale and window_size[1] < 340 * gui.scale:
                            break
                        # if y >

                        for a in range(row_len):

                            if album_on > len(album_dex) - 1:
                                break

                            x = (l_area + dev * a) - int(album_mode_art_size / 2) + int(dev / 2) + int(
                                compact / 2) - a_offset

                            if album_dex[album_on] > len(default_playlist):
                                break

                            info = get_album_info(album_dex[album_on])

                            if gui.first_in_grid is None and y > gui.panelY:  # This marks what track is the first in the grid
                                gui.first_in_grid = album_dex[album_on]

                            #artisttitle = colours.side_bar_line2
                            #albumtitle = colours.side_bar_line1  # grey(220)


                            card_mode = False
                            if prefs.use_card_style and colours.lm and gui.gallery_show_text:

                                card_mode = True
                                ddt.text_background_colour = colours.grey(250)


                            if card_mode:
                                drop_shadow.render(x + 3 * gui.scale, y + 3 * gui.scale, album_mode_art_size + 11 * gui.scale, album_mode_art_size + 45 * gui.scale + 13 * gui.scale)
                                ddt.rect_r((x, y, album_mode_art_size, album_mode_art_size + 45 * gui.scale), colours.grey(250), True)


                            # White background needs extra border
                            if colours.lm and not card_mode:
                                ddt.rect_a((x - 2, y - 2), (album_mode_art_size + 4, album_mode_art_size + 4),
                                          colours.grey(200), True)



                            if a == row_len - 1:

                                gui.gallery_scroll_field_left = max(x + album_mode_art_size, window_size[0] - round(50 * gui.scale))


                            if info[0] == 1 and pctl.playing_state != 0:
                                ddt.rect_a((x - 4, y - 4), (album_mode_art_size + 8, album_mode_art_size + 8),
                                          colours.gallery_highlight, True)
                                # ddt.rect_a((x, y), (album_mode_art_size, album_mode_art_size),
                                #            colours.gallery_background, True)

                            # Draw transcode highlight
                            if transcode_list and os.path.isdir(prefs.encoder_output):

                                track = pctl.master_library[default_playlist[album_dex[album_on]]]
                                tr = False

                                if (encode_folder_name(track) in os.listdir(prefs.encoder_output)):
                                    tr = True
                                else:
                                    for folder in transcode_list:
                                        if pctl.g(folder[0]).parent_folder_path == track.parent_folder_path:
                                            tr = True
                                            break
                                if tr:
                                    c = [244, 212, 66, 255]
                                    if colours.lm:
                                        c = [244, 64, 244, 255]
                                    ddt.rect_a((x - 4, y - 4), (album_mode_art_size + 8, album_mode_art_size + 8),
                                              c, True)
                                    # ddt.rect_a((x, y), (album_mode_art_size, album_mode_art_size),
                                    #            colours.gallery_background, True)

                            # Draw selection
                            if (gui.album_tab_mode or gallery_menu.active) and info[2] is True:

                                c = colours.gallery_highlight
                                c = [c[1], c[2], c[0], c[3]]
                                ddt.rect_a((x - 4, y - 4), (album_mode_art_size + 8, album_mode_art_size + 8),
                                          c, True) #[150, 80, 222, 255]
                                # ddt.rect_a((x, y), (album_mode_art_size, album_mode_art_size),
                                #            colours.gallery_background, True)

                            # Draw selection animation
                            if gui.gallery_animate_highlight_on == album_dex[album_on] and gallery_select_animate_timer.get() < 1.5:

                                t = gallery_select_animate_timer.get()
                                c = colours.gallery_highlight
                                if t < 0.2:
                                    a = int(255 * (t / 0.2))
                                elif t < 0.5:
                                    a = 255
                                else:
                                    a = int(255 - 255 * (t - 0.5))


                                c = [c[1], c[2], c[0], a]
                                ddt.rect_a((x - 5, y - 5), (album_mode_art_size + 10, album_mode_art_size + 10),
                                          c, True) #[150, 80, 222, 255]

                                gui.update += 1

                            ddt.rect_a((x, y), (album_mode_art_size, album_mode_art_size),
                                       colours.gallery_background, True)
                            # Draw back colour
                            back_colour = [40, 40, 40, 50]
                            if colours.lm:
                                back_colour = [10, 10, 10, 15]
                            ddt.rect_a((x, y), (album_mode_art_size, album_mode_art_size), back_colour, True)

                            # Draw faint outline
                            ddt.rect_a((x - 1 * gui.scale, y - 1 * gui.scale), (album_mode_art_size + 2 * gui.scale, album_mode_art_size + 2 * gui.scale),
                                      [255, 255, 255, 11])

                            # Draw album art
                            drawn_art = gall_ren.render(default_playlist[album_dex[album_on]], (x, y))
                            if drawn_art is False and gui.gallery_show_text is False:

                                ddt.draw_text((x + int(album_mode_art_size / 2), y + album_mode_art_size - 22 * gui.scale, 2),
                                           pctl.master_library[default_playlist[album_dex[album_on]]].parent_folder_name,
                                           colours.gallery_artist_line,
                                           13,
                                           album_mode_art_size - 15 * gui.scale,
                                           bg=alpha_blend(back_colour, colours.gallery_background))


                            if prefs.art_bg and drawn_art:
                                rect = SDL_Rect(round(x), round(y), album_mode_art_size, album_mode_art_size)
                                if rect.y < gui.panelY:
                                    diff = round(gui.panelY - rect.y)
                                    rect.y += diff
                                    rect.h -= diff
                                elif (rect.y + rect.h) > window_size[1] - gui.panelBY:
                                    diff = round((rect.y + rect.h) - (window_size[1] - gui.panelBY))
                                    rect.h -= diff


                                if rect.h > 0:
                                    style_overlay.hole_punches.append(rect)


                            if gui.album_tab_mode or gallery_menu.active:
                                if info[2] is False and info[0] != 1 and not colours.lm:
                                    ddt.rect_a((x, y), (album_mode_art_size, album_mode_art_size), [0, 0, 0, 110], True)
                                    albumtitle = colours.grey(160)

                            else:
                                if info[0] != 1 and pctl.playing_state != 0 and prefs.dim_art:
                                    ddt.rect_a((x, y), (album_mode_art_size, album_mode_art_size), [0, 0, 0, 110], True)
                                    albumtitle = colours.grey(160)


                            c_index = default_playlist[album_dex[album_on]]

                            if c_index in album_artist_dict:
                                pass
                            else:
                                i = album_dex[album_on]
                                if pctl.master_library[default_playlist[i]].album_artist != "":
                                    album_artist_dict[c_index] = pctl.master_library[default_playlist[i]].album_artist
                                else:
                                    while i < len(default_playlist) - 1:
                                        if pctl.master_library[default_playlist[i]].parent_folder_name != \
                                                pctl.master_library[
                                                    default_playlist[album_dex[album_on]]].parent_folder_name:
                                            album_artist_dict[c_index] = pctl.master_library[
                                                default_playlist[album_dex[album_on]]].artist
                                            break
                                        if pctl.master_library[default_playlist[i]].artist != pctl.master_library[
                                            default_playlist[album_dex[album_on]]].artist:
                                            album_artist_dict[c_index] = "Various Artists"

                                            break
                                        i += 1
                                    else:
                                        album_artist_dict[c_index] = pctl.master_library[
                                            default_playlist[album_dex[album_on]]].artist

                            if gui.gallery_show_text:
                                line = album_artist_dict[c_index]
                                line2 = pctl.master_library[default_playlist[album_dex[album_on]]].album


                                if card_mode:
                                    if line2 == "":

                                        ddt.draw_text((x + 6 * gui.scale, y + album_mode_art_size + 8 * gui.scale),
                                                      line,
                                                      line1_colour,
                                                      310,
                                                      album_mode_art_size - 18 * gui.scale,
                                                      )
                                    else:

                                        ddt.draw_text((x + 6 * gui.scale, y + album_mode_art_size + 7 * gui.scale),
                                                      line2,
                                                      line2_colour,
                                                      311,
                                                      album_mode_art_size - 18 * gui.scale,
                                                      )

                                        ddt.draw_text((x + 6 * gui.scale, y + album_mode_art_size + (10 + 14) * gui.scale),
                                                      line,
                                                      line1_colour,
                                                      10,
                                                      album_mode_art_size - 18 * gui.scale,
                                                      )
                                else:
                                    if line2 == "":

                                        ddt.draw_text((x, y + album_mode_art_size + 9 * gui.scale),
                                                   line,
                                                   line1_colour,
                                                   311,
                                                   album_mode_art_size - 5 * gui.scale,
                                                   )
                                    else:

                                        ddt.draw_text((x, y + album_mode_art_size + 8 * gui.scale),
                                                   line2,
                                                   line2_colour,
                                                   212,
                                                   album_mode_art_size,
                                                   )

                                        ddt.draw_text((x, y + album_mode_art_size + (10 + 14)  * gui.scale),
                                                   line,
                                                   line1_colour,
                                                   311,
                                                   album_mode_art_size - 5 * gui.scale,
                                                   )

                            album_on += 1

                        if album_on > len(album_dex):
                            break
                        render_pos += album_mode_art_size + album_v_gap

                ddt.rect_a((0, 0), (window_size[0], gui.panelY), colours.top_panel_background, True)



                # POWER TAG BAR --------------

                if gui.pt > 0 or (gui.power_bar is not None and len(gui.power_bar) > 1):

                    top = gui.panelY
                    run_y = top + 1

                    hot_r = (window_size[0] - 47 * gui.scale, top, 45 * gui.scale, h)
                    fields.add(hot_r)


                    if gui.pt == 0:  # mouse moves in
                        if coll(hot_r):
                            gui.pt_on.set()
                            gui.pt = 1
                    elif gui.pt == 1:  # wait then trigger if stays, reset if goes out
                        if not coll(hot_r):
                            gui.pt = 0
                        elif gui.pt_on.get() > 0.2:
                            gui.pt = 2

                            off = 0
                            for item in gui.power_bar:
                                item.ani_timer.force_set(off)
                                off -= 0.005

                    elif gui.pt == 2: # wait to turn off

                        if coll(hot_r):
                            gui.pt_off.set()
                        if gui.pt_off.get() > 0.6:
                            gui.pt = 3

                            off = 0
                            for item in gui.power_bar:
                                item.ani_timer.force_set(off)
                                off -= 0.01

                    done = True
                    # Animate tages on
                    if gui.pt == 2:
                        for item in gui.power_bar:
                            t = item.ani_timer.get()
                            if t < 0:
                                break
                            if t > 0.2:
                                item.peak_x = 9 * gui.scale
                            else:
                                item.peak_x = (t / 0.2) * 9 * gui.scale

                    # Animate tags off
                    if gui.pt == 3:
                        for item in gui.power_bar:
                            t = item.ani_timer.get()
                            if t < 0:
                                done = False
                                break
                            if t > 0.2:
                                item.peak_x = 0
                            else:
                                item.peak_x = 9 * gui.scale - ((t / 0.2) * 9 * gui.scale)
                                done = False
                        if done:
                            gui.pt = 0

                    # Keep draw loop running while on
                    if gui.pt > 0:
                        gui.update = 2


                    # Draw tags

                    block_h = round(27 * gui.scale)
                    block_gap = 1 * gui.scale
                    if gui.scale == 1.25:
                        block_gap = 1

                    if coll(hot_r) or gui.pt > 0:

                        for i, item in enumerate(gui.power_bar):

                            if run_y + block_h > top + h:
                                break


                            rect = [window_size[0] - item.peak_x, run_y, 7 * gui.scale, block_h]
                            i_rect = [window_size[0] - 21 * gui.scale, run_y, 19 * gui.scale, block_h]
                            fields.add(i_rect)

                            if coll(i_rect) and item.peak_x == 9 * gui.scale:

                                minx = 100 * gui.scale
                                maxx = minx * 2

                                ww = ddt.get_text_w(item.name, 213)

                                w = max(minx, ww)
                                w = min(maxx, w)


                                ddt.rect_r((rect[0] - w - 25 * gui.scale, run_y, w + 26 * gui.scale, block_h), [230, 230, 230, 255], True)
                                ddt.draw_text((rect[0] - 10 * gui.scale, run_y + 5 * gui.scale, 1), item.name, [5, 5, 5, 255], 213, w, bg=[230, 230, 230, 255])

                                if input.mouse_click:
                                    goto_album(item.position)


                            ddt.rect_r(rect, item.colour, True)
                            run_y += block_h + block_gap

                # END POWER BAR ------------------------


            # End of gallery view
            # --------------------------------------------------------------------------
            # Main Playlist:

            if len(load_orders) > 0:

                for i, order in enumerate(load_orders):
                    if order.stage == 2:
                        target_pl = 0

                        # Sort the tracks by track number
                        sort_track_2(None, order.tracks)

                        for p, playlist in enumerate(pctl.multi_playlist):
                            if playlist[6] == order.playlist:
                                target_pl = p
                                break
                        else:
                            del load_orders[i]
                            print("Error: Target playlist lost")
                            break

                        # print(order.tracks)
                        if order.playlist_position is not None:
                            # print(order.playlist_position)
                            pctl.multi_playlist[target_pl][2][order.playlist_position:order.playlist_position] = order.tracks
                        else:

                            if order.replace_stem:
                                for ii, id in reversed(list(enumerate(pctl.multi_playlist[target_pl][2]))):
                                    if pctl.g(id).parent_folder_path.startswith(order.target):
                                        del pctl.multi_playlist[target_pl][2][ii]


                            pctl.multi_playlist[target_pl][2] += order.tracks
                            pctl.update_shuffle_pool(pctl.multi_playlist[target_pl][6], order.tracks)


                        gui.update += 2
                        gui.pl_update += 2
                        if order.notify and gui.message_box:
                            show_message(_("Rescan folder complete."), 'done', order.target)
                        reload()


                        if order.play and order.tracks:

                            for p, plst in enumerate(pctl.multi_playlist):
                                if order.tracks[0] in plst[2]:
                                    target_pl = p
                                    break

                            switch_playlist(target_pl)

                            pctl.active_playlist_playing = pctl.active_playlist_viewing

                            # If already in playlist, delete latest add
                            if "Default" == pctl.multi_playlist[target_pl][0]:
                                if default_playlist.count(order.tracks[0]) > 1:
                                    for q in reversed(range(len(default_playlist))):
                                        if default_playlist[q] == order.tracks[0]:
                                            del default_playlist[q]
                                            break


                            pctl.jump(order.tracks[0], pl_position=default_playlist.index(order.tracks[0]))

                            pctl.show_current(True, True, True, True, True)

                        del load_orders[i]

                        # Are there more orders for this playlist?
                        # If not, decide on a name for the playlist
                        for item in load_orders:
                            if item.playlist == order.playlist:
                                break
                        else:
                            if "New Playlist" in pctl.multi_playlist[target_pl][0]:
                                auto_name_pl(target_pl)

                            if prefs.auto_sort:
                                if pctl.multi_playlist[target_pl][9]:
                                    show_message("Auto sort skipped because playlist is locked.")
                                else:
                                    print("Auto sorting")
                                    standard_sort(target_pl)
                                    year_sort(target_pl)

                        if not load_orders:
                            loading_in_progress = False
                            tauon.worker_save_state = True
                        break
                gui.auto_play_import = False

            if gui.show_playlist:

                # playlist hit test
                if coll((
                gui.playlist_left, gui.playlist_top, gui.plw, window_size[1] - gui.panelY - gui.panelBY)) and not drag_mode and (
                                            input.mouse_click or mouse_wheel != 0 or right_click or middle_click or mouse_up or mouse_down):
                    gui.pl_update = 1

                if gui.combo_mode and mouse_wheel != 0:
                    gui.pl_update = 1

                # MAIN PLAYLIST
                # C-PR

                top = gui.panelY
                if gui.artist_info_panel:
                    top += gui.artist_panel_height

                if gui.set_mode and not gui.set_bar:
                    left = 0
                    if gui.lsp:
                        left = gui.lspw
                    rect = [left, top, gui.plw, 6 * gui.scale]
                    if right_click and coll(rect):
                        set_menu_hidden.activate()

                if gui.set_bar and gui.set_mode:
                    left = 0
                    if gui.lsp:
                        left = gui.lspw
                    rect = [left, top, gui.plw, gui.set_height]
                    start = left + 16 * gui.scale
                    run = 0
                    in_grip = False

                    if not mouse_down and gui.set_hold != -1:
                        gui.set_hold = -1

                    for h, item in enumerate(gui.pl_st):
                        box = (start + run, rect[1], item[1], rect[3])
                        grip = (start + run, rect[1], 3 * gui.scale, rect[3])
                        m_grip = (grip[0] - 4 * gui.scale, grip[1], grip[2] + 8 * gui.scale, grip[3])
                        l_grip = (grip[0] + 9 * gui.scale, grip[1], box[2] - 14 * gui.scale, grip[3])
                        fields.add(m_grip)


                        if coll(l_grip):
                            if mouse_up and gui.set_label_hold != -1:
                                if h != gui.set_label_hold:
                                    dest = h
                                    if dest > gui.set_label_hold:
                                        dest += 1
                                    temp = gui.pl_st[gui.set_label_hold]
                                    gui.pl_st[gui.set_label_hold] = "old"
                                    gui.pl_st.insert(dest, temp)
                                    gui.pl_st.remove("old")

                                    gui.pl_update = 1
                                    gui.set_label_hold = -1
                                    # print("MOVE")
                                    break

                                gui.set_label_hold = -1

                            if input.mouse_click:
                                gui.set_label_hold = h
                                gui.set_label_point = copy.deepcopy(mouse_position)
                            if right_click:
                                set_menu.activate(h)

                        if h != 0:
                            if coll(m_grip):
                                in_grip = True
                                if input.mouse_click:

                                    gui.set_hold = h
                                    gui.set_point = mouse_position[0]
                                    gui.set_old = gui.pl_st[h - 1][1]

                            if mouse_down and gui.set_hold == h:
                                gui.pl_st[h - 1][1] = gui.set_old + (mouse_position[0] - gui.set_point)
                                if gui.pl_st[h - 1][1] < 25:
                                    gui.pl_st[h - 1][1] = 25

                                gui.update = 1
                                gui.pl_update = 1

                                total = 0
                                for i in range(len(gui.pl_st) - 1):
                                    total += gui.pl_st[i][1]
                                gui.pl_st[len(gui.pl_st) - 1][1] = gui.plw - 16 - total

                        run += item[1]

                    if not mouse_down:
                        gui.set_label_hold = -1
                    # print(in_grip)
                    if gui.set_label_hold == -1:
                        if in_grip and not x_menu.active and not view_menu.active and not tab_menu.active and not set_menu.active:
                            gui.cursor_want = 1
                        if gui.set_hold != -1:
                            gui.cursor_want = 1



                # heart field test
                if gui.heart_fields:
                    for field in gui.heart_fields:
                        fields.add(field, update_playlist_call)



                if gui.pl_update > 0:

                    gui.pl_update -= 1
                    if gui.combo_mode:
                        if gui.showcase_mode:
                            showcase.render()
                        # else:
                        #     combo_pl_render.full_render()
                    else:
                        gui.heart_fields.clear()
                        playlist_render.full_render()

                else:
                    if gui.combo_mode:
                        if gui.showcase_mode:
                            showcase.render()
                        # else:
                        #     combo_pl_render.cache_render()
                    else:
                        playlist_render.cache_render()


                if gui.set_bar and gui.set_mode and not gui.combo_mode:

                    x = 0
                    if gui.lsp:
                        x = gui.lspw

                    rect = [x, top, gui.plw, gui.set_height]

                    c_bar_background = [30, 30, 30, 255]



                    # if colours.lm:
                    #     c_bar_background = colours.grey(60)

                    if colours.lm:
                        # c_bar_background = colours.row_playing_highlight
                        c_bar_background = [235, 110, 160, 255]

                    ddt.rect_r(rect, c_bar_background, True)

                    start = x + 16 * gui.scale
                    run = 0
                    for i, item in enumerate(gui.pl_st):
                        box = (start + run, rect[1], item[1], rect[3])
                        grip = (start + run, rect[1], 3 * gui.scale, rect[3])

                        bg = c_bar_background

                        if coll(box) and gui.set_label_hold != -1:
                            bg = [39, 39, 39, 255]

                        if i == gui.set_label_hold:
                            bg = [22, 22, 22, 255]


                        ddt.rect_r(box, bg, True)
                        ddt.rect_r(grip, [255, 255, 255, 14], True)

                        line = trunc_line(item[0], 12, box[2] - 13 * gui.scale, False)
                        ddt.text_background_colour = bg
                        ddt.draw_text((box[0] + 10 * gui.scale, top + 4 * gui.scale), line, [240, 240, 240, 255], 312, bg=bg)
                        run += box[2]


                # Switch Vis:
                if right_click and coll((window_size[0] - 150 * gui.scale - gui.offset_extra, 0, 140 * gui.scale , gui.panelY)):
                    vis_menu.activate(None, (window_size[0] - 150 * gui.scale, 30 * gui.scale))


                edge_playlist.render(gui.playlist_left, gui.panelY + 1, gui.plw, 2 * gui.scale)
                bottom_playlist.render(gui.playlist_left, window_size[1] - gui.panelBY - 2 * gui.scale, gui.plw, 2 * gui.scale)
                # --------------------------------------------
                # ALBUM ART

                # Right side panel drawing
                if gui.rsp:
                    if True and not album_mode:

                        boxw = gui.rspw
                        boxh = gui.rspw

                        if prefs.show_side_art:

                            meta_box.draw(window_size[0] - gui.rspw, gui.panelY + boxh, gui.rspw,
                                          window_size[1] - gui.panelY - gui.panelBY - boxh)

                            boxh = min(boxh, window_size[1] - gui.panelY - gui.panelBY)

                            art_box.draw(window_size[0] - gui.rspw, gui.panelY, boxw, boxh)

                        else:
                            meta_box.draw(window_size[0] - gui.rspw, gui.panelY, gui.rspw,
                                          window_size[1] - gui.panelY - gui.panelBY)



                    elif album_mode:
                        pass

                # Seperation Line Drawing
                if gui.rsp:

                    # Draw Highlight when mouse over
                    if draw_sep_hl:
                        ddt.line(window_size[0] - gui.rspw + 1 * gui.scale, gui.panelY + 1 * gui.scale,
                                  window_size[0] - gui.rspw + 1 * gui.scale,
                                  window_size[1] - 50 * gui.scale, [100, 100, 100, 70])
                        draw_sep_hl = False

                # Normal Drawing
                if gui.rsp and gui.draw_frame:
                    ddt.line(gui.playlist_width + 30 * gui.scale, gui.panelY + 1 * gui.scale, gui.plw, window_size[1] - 30 * gui.scale,
                              colours.sep_line)


            # Title position logic
            gui.show_bottom_title = False
            gui.show_top_title = False
            if album_mode or prefs.meta_shows_selected_always:
                gui.show_bottom_title = True
            elif gui.rsp:
                if window_size[1] - gui.panelY - gui.panelBY - gui.rspw < 59 * gui.scale or window_size[0] > 1500 * gui.scale or gui.maximized:
                    gui.show_bottom_title = True
                    if window_size[0] < 820 * gui.scale:
                        gui.show_top_title = True
            else:
                gui.show_bottom_title = True
                if window_size[0] < 820 * gui.scale:
                    gui.show_top_title = True


            if gui.lsp and not gui.combo_mode:

                # left side panel

                h_estimate = ((playlist_box.tab_h + playlist_box.gap) * gui.scale * len(pctl.multi_playlist)) + 13 * gui.scale

                half = int(round((window_size[1] - gui.panelY - gui.panelBY) / 2))
                full = (window_size[1] - gui.panelY - gui.panelBY)

                pl_box_h = full

                if prefs.artist_list:
                    artist_list_box.render(0, gui.panelY, gui.lspw, pl_box_h)

                else:

                    #if pctl.force_queue:

                    if h_estimate < half:
                        pl_box_h = h_estimate
                    else:
                        pl_box_h = half

                    playlist_box.draw(0, gui.panelY, gui.lspw, pl_box_h)

                    #if pctl.force_queue:

                    queue_box.draw(0, gui.panelY + pl_box_h, gui.lspw, full - pl_box_h)


            if gui.artist_info_panel and not gui.combo_mode:
                artist_info_box.draw(gui.playlist_left, gui.panelY, gui.plw, gui.artist_panel_height)

            # ------------------------------------------------
            # Scroll Bar

            # if not scroll_enable:
            top = gui.panelY
            if gui.artist_info_panel:
                top += gui.artist_panel_height

            width = 15 * gui.scale


            x = 0
            if gui.lsp:  # Move left so it sits over panel divide

                x = gui.lspw - 1 * gui.scale
                if not gui.set_mode:
                    width = 11 * gui.scale
            if gui.set_mode and prefs.left_align_album_artist_title:
                width = 11 * gui.scale

            gui.scroll_hide_box = (
                x + 1 if not gui.maximized else x, top, 28 * gui.scale, window_size[1] - gui.panelBY - top)

            fields.add(gui.scroll_hide_box)
            if scroll_hide_timer.get() < 0.9 or (coll(
                    gui.scroll_hide_box) or scroll_hold or quick_search_mode) and \
                    not x_menu.active and \
                    not tab_menu.active and \
                    not pref_box.enabled and \
                    not extra_tab_menu.active and \
                    not gui.rename_playlist_box \
                    and gui.layer_focus == 0:

                scroll_opacity = 255

                if not gui.combo_mode:
                    sy = 31 * gui.scale
                    ey = window_size[1] - (30 + 22) * gui.scale

                    if len(default_playlist) < 50:
                        sbl = 85 * gui.scale
                        if len(default_playlist) == 0:
                            sbp = top
                    else:
                        sbl = 105 * gui.scale

                    fields.add((x + 2 * gui.scale, sbp, 20 * gui.scale, sbl))
                    if coll((x, top, 28 * gui.scale, ey - top)) and (
                            mouse_down or right_click) \
                            and coll_point(click_location, (x, top, 28 * gui.scale, ey - top)):

                        gui.pl_update = 1
                        if right_click:

                            sbp = mouse_position[1] - int(sbl / 2)
                            if sbp + sbl > ey:
                                sbp = ey - sbl
                            elif sbp < top:
                                sbp = top
                            per = (sbp - top) / (ey - top - sbl)
                            pctl.playlist_view_position = int(len(default_playlist) * per)

                            if pctl.playlist_view_position < 0:
                                pctl.playlist_view_position = 0

                            # if playlist_position == len(default_playlist):
                            #     print("END")

                        # elif mouse_position[1] < sbp:
                        #     pctl.playlist_view_position -= 2
                        # elif mouse_position[1] > sbp + sbl:
                        #     pctl.playlist_view_position += 2
                        elif input.mouse_click:

                            if mouse_position[1] < sbp:
                                gui.scroll_direction = -1
                            elif mouse_position[1] > sbp + sbl:
                                gui.scroll_direction = 1
                            else:
                                # p_y = pointer(c_int(0))
                                # p_x = pointer(c_int(0))
                                # SDL_GetGlobalMouseState(p_x, p_y)
                                get_sdl_input.mouse_capture_want = True

                                scroll_hold = True
                                #scroll_point = p_y.contents.value  # mouse_position[1]
                                scroll_point = mouse_position[1]
                                scroll_bpoint = sbp
                        else:
                            #gui.update += 1
                            if sbp < mouse_position[1] < sbp + sbl:
                                gui.scroll_direction = 0
                            pctl.playlist_view_position += gui.scroll_direction * 2
                            if pctl.playlist_view_position < 0:
                                pctl.playlist_view_position = 0
                            if pctl.playlist_view_position > len(default_playlist):
                                pctl.playlist_view_position = len(default_playlist)
                            if sbp + sbl > ey:
                                sbp = ey - sbl
                            elif sbp < top:
                                sbp = top

                    if not mouse_down:
                        scroll_hold = False

                    if scroll_hold and not input.mouse_click:
                        gui.pl_update = 1
                        # p_y = pointer(c_int(0))
                        # p_x = pointer(c_int(0))
                        # SDL_GetGlobalMouseState(p_x, p_y)
                        get_sdl_input.mouse_capture_want = True

                        sbp = mouse_position[1] - (scroll_point - scroll_bpoint)
                        if sbp + sbl > ey:
                            sbp = ey - sbl
                        elif sbp < top:
                            sbp = top
                        per = (sbp - top) / (ey - top - sbl)
                        pctl.playlist_view_position = int(len(default_playlist) * per)


                    else:
                        if len(default_playlist) > 0:
                            per = pctl.playlist_view_position / len(default_playlist)
                            sbp = int((ey - top - sbl) * per) + top + 1

                    bg = [40, 40, 40, 60]
                    fg = colours.scroll_colour

                    if colours.lm:
                        bg = [200, 200, 200, 100]
                        fg = [100, 100, 100, 200]

                    ddt.rect_a((x, top), (width + 1 * gui.scale, window_size[1] - top - gui.panelBY), bg,
                               True)
                    ddt.rect_a((x + 1, sbp), (width, sbl),
                               alpha_mod(fg, scroll_opacity), True)

                    if (coll((x + 2 * gui.scale, sbp, 20 * gui.scale, sbl)) and mouse_position[
                        0] != 0) or scroll_hold:
                        ddt.rect_a((x + 1 * gui.scale, sbp), (width, sbl), [255, 255, 255, 19], True)

            # NEW TOP BAR
            # C-TBR

            if gui.mode == 1:
                top_panel.render()

            # RENDER EXTRA FRAME DOUBLE
            if colours.lm:
                if gui.lsp and not gui.combo_mode:
                    ddt.rect_r((0 + gui.lspw - 6 * gui.scale, gui.panelY, 6 * gui.scale, int(round((window_size[1] - gui.panelY - gui.panelBY)))), colours.grey(200), True)
                    ddt.rect_r((0 + gui.lspw - 5 * gui.scale, gui.panelY - 1, 4 * gui.scale, int(round((window_size[1] - gui.panelY - gui.panelBY))) + 1), colours.grey(245), True)
                if gui.rsp:
                    ddt.rect_r((window_size[0] - gui.rspw - 3 * gui.scale, gui.panelY, 6 * gui.scale, int(round((window_size[1] - gui.panelY - gui.panelBY)))), colours.grey(200), True)
                    ddt.rect_r((window_size[0] - gui.rspw - 2 * gui.scale, gui.panelY - 1, 4 * gui.scale, int(round((window_size[1] - gui.panelY - gui.panelBY))) + 1), colours.grey(245), True)
                if gui.queue_frame_draw is not None:
                    if gui.lsp:
                        ddt.rect_r((0, gui.queue_frame_draw, gui.lspw - 6 * gui.scale, 6 * gui.scale), colours.grey(200), True)
                        ddt.rect_r((0, gui.queue_frame_draw + 1 * gui.scale, gui.lspw - 5 * gui.scale, 5 * gui.scale), colours.grey(250), True)

                    gui.queue_frame_draw = None

            # BOTTOM BAR!
            # C-BB

            ddt.text_background_colour = colours.bottom_panel_colour
            bottom_bar1.render()

            if prefs.art_bg:
                style_overlay.display()
                # if key_shift_down:
                #     ddt.rect_r(gui.seek_bar_rect,
                #                alpha_mod([150, 150, 150 ,255], 20), True)
                #     ddt.rect_r(gui.volume_bar_rect,
                #                alpha_mod(colours.volume_bar_fill, 100), True)

            style_overlay.hole_punches.clear()

            if gui.set_mode:
                if renamebox is False \
                        and radiobox is False \
                        and gui.rename_playlist_box is False \
                        and gui.message_box is False \
                        and pref_box.enabled is False \
                        and track_box is False \
                        and not gui.rename_folder_box \
                        and extra_menu.active is False\
                        and not x_menu.active \
                        and not view_menu.active \
                        and not track_menu.active \
                        and not tab_menu.active \
                        and not selection_menu.active\
                        and not view_box.active \
                        and not folder_menu.active \
                        and not set_menu.active \
                        and not artist_info_scroll.held:

                    columns_tool_tip.render()
                else:
                    columns_tool_tip.show = False


            # Overlay GUI ----------------------

            if gui.rename_playlist_box:
                rename_box.render()

            # if filter_box.active:
            #     filter_box.render()

            if track_box:
                if input.key_return_press or right_click or key_esc_press or key_backspace_press or keymaps.test("quick-find"):
                    track_box = False

                    input.key_return_press = False

                if gui.level_2_click:
                    input.mouse_click = True
                gui.level_2_click = False

                tc = pctl.master_library[r_menu_index]


                w = 540 * gui.scale
                #w = 550 * gui.scale
                h = 240 * gui.scale
                comment_mode = 0

                if len(tc.comment) > 0:
                    h += 22 * gui.scale
                    w += 25 * gui.scale
                    if ddt.get_text_w(tc.comment, 12) > 330 * gui.scale or "\n" in tc.comment:
                        h += 80 * gui.scale
                        w += 30 * gui.scale
                        comment_mode = 1

                x = int(window_size[0] / 2) - int(w / 2)
                y = int(window_size[1] / 2) - int(h / 2)

                x1 = int(x + 18 * gui.scale)
                x2 = int(x + 98 * gui.scale)

                value_font_a = 312
                value_font = 12

                # if key_shift_down:
                #     value_font = 12
                key_colour_off = colours.grey_blend_bg3(90)
                key_colour_on = colours.grey_blend_bg3(240)
                value_colour = colours.grey_blend_bg3(225)
                path_colour = colours.grey_blend_bg3(200)

                # if colours.lm:
                #     key_colour_off = colours.grey(80)
                #     key_colour_on = colours.grey(120)
                #     value_colour = colours.grey(50)
                #     path_colour = colours.grey(70)

                ddt.rect_a((x - 3 * gui.scale, y - 3 * gui.scale), (w + 6 * gui.scale, h + 6 * gui.scale), colours.grey(75), True)
                ddt.rect_a((x, y), (w, h), colours.sys_background_3, True)
                ddt.text_background_colour = colours.sys_background_3

                if input.mouse_click and not coll([x, y, w, h]):
                    track_box = False

                else:
                    art_size = int(115 * gui.scale)

                    # if not tc.is_network: # Don't draw album art if from network location for better performance
                    if comment_mode == 1:
                        album_art_gen.display(r_menu_index, (int(x + w - 135 * gui.scale), int(y + 105 * gui.scale)), (art_size, art_size)) # Mirror this size in auto theme #mark2233
                    else:
                        album_art_gen.display(r_menu_index, (int(x + w - 135 * gui.scale), int(y + h - 135 * gui.scale)), (art_size, art_size))

                    y -= int(24 * gui.scale)
                    y1 = int(y + (40 * gui.scale))


                    ext_rect = [x + w - 38 * gui.scale, y + 44 * gui.scale, 38 * gui.scale, 12 * gui.scale]

                    line = tc.file_ext
                    ex_colour = [130, 130, 130, 255]

                    if line in format_colours:
                        ex_colour = format_colours[line]

                    ddt.rect_r(ext_rect, ex_colour, True)
                    ddt.draw_text((int(x + w - 35 * gui.scale), int(y + 41 * gui.scale)), line, alpha_blend([10, 10, 10, 235], ex_colour) , 211, bg=ex_colour)

                    if tc.is_cue:
                        ext_rect[1] += 16 * gui.scale
                        colour = [218, 222, 73, 255]
                        if tc.is_embed_cue:
                            colour = [252, 199, 55, 255]
                        ddt.rect_r(ext_rect, colour, True)
                        ddt.draw_text((int(x + w - 35 * gui.scale), int(y + (41 + 16) * gui.scale)), "CUE", alpha_blend([10, 10, 10, 235], colour), 211, bg=colour)


                    rect = [x1, y1 + int(2 * gui.scale), 450 * gui.scale, 14 * gui.scale]
                    fields.add(rect)
                    if coll(rect):
                        ddt.draw_text((x1, y1), "Title", key_colour_on, 212)
                        if input.mouse_click:
                            show_message("Title copied to clipboard")
                            copy_to_clipboard(tc.title)
                            input.mouse_click = False
                    else:
                        ddt.draw_text((x1, y1), "Title", key_colour_off, 212)
                        #
                    q = ddt.draw_text((x2, y1 - int(2 * gui.scale)), tc.title
                              , value_colour, 314, max_w=w - 170 * gui.scale)

                    if coll(rect):
                        ex_tool_tip(x2 + 185 * gui.scale, y1, q, tc.title, 314)

                    y1 += int(16 * gui.scale)


                    rect = [x1, y1 + (2 * gui.scale), 450 * gui.scale, 14 * gui.scale]
                    fields.add(rect)
                    if coll(rect):
                        ddt.draw_text((x1, y1), "Artist", key_colour_on, 212)
                        if input.mouse_click:
                            show_message("Artist field copied to clipboard")
                            copy_to_clipboard(tc.artist)
                            input.mouse_click = False
                    else:
                        ddt.draw_text((x1, y1), "Artist", key_colour_off, 212)

                    q = ddt.draw_text((x2, y1 - (1 * gui.scale)), tc.artist,
                                      value_colour, value_font_a, max_w=390 * gui.scale)

                    if coll(rect):
                        ex_tool_tip(x2 + 185 * gui.scale, y1, q, tc.artist, value_font_a)

                    y1 += int(16 * gui.scale)

                    rect = [x1, y1 + (2 * gui.scale), 450 * gui.scale, 14 * gui.scale]
                    fields.add(rect)
                    if coll(rect):
                        ddt.draw_text((x1, y1), "Album", key_colour_on, 212)
                        if input.mouse_click:
                            show_message("Album field copied to clipboard")
                            copy_to_clipboard(tc.album)
                            input.mouse_click = False
                    else:
                        ddt.draw_text((x1, y1), "Album", key_colour_off, 212)

                    q = ddt.draw_text((x2, y1 - 1 * gui.scale), tc.album,
                              value_colour,
                                      value_font_a, max_w=390*gui.scale)

                    if coll(rect):
                        ex_tool_tip(x2 + 185 * gui.scale, y1, q, tc.album, value_font_a)

                    y1 += int(26 * gui.scale)

                    rect = [x1, y1, 450 * gui.scale, 16 * gui.scale]
                    fields.add(rect)
                    if coll(rect):
                        ddt.draw_text((x1, y1), "Path", key_colour_on, 212)
                        if input.mouse_click:
                            show_message("File path copied to clipboard")
                            copy_to_clipboard(tc.fullpath)
                            input.mouse_click = False
                    else:
                        ddt.draw_text((x1, y1), "Path", key_colour_off, 212)

                    q = ddt.draw_text((x2, y1 - int(3 * gui.scale)), tc.fullpath,
                              path_colour, 210, max_w=425*gui.scale )

                    if coll(rect):
                        gui.frame_callback_list.append(TestTimer(0.71))
                        if track_box_path_tool_timer.get() > 0.7:
                            ex_tool_tip(x2 + 185 * gui.scale, y1, q, tc.fullpath, 210)
                    else:
                        track_box_path_tool_timer.set()

                    y1 += int(15 * gui.scale)

                    if tc.samplerate != 0:
                        ddt.draw_text((x1, y1), "Samplerate", key_colour_off, 212)

                        line = str(tc.samplerate) + " Hz"


                        off = ddt.draw_text((x2, y1), line, value_colour, value_font)

                        if tc.bit_depth > 0:
                            line = str(tc.bit_depth) + " bit"
                            ddt.draw_text((x2 + off + 9 * gui.scale, y1), line, value_colour, 311)

                    y1 += int(15 * gui.scale)

                    if tc.bitrate not in (0, "", "0"):
                        ddt.draw_text((x1, y1), "Bitrate", key_colour_off, 212)
                        line = str(tc.bitrate)
                        if tc.file_ext in ('FLAC', 'OPUS', 'APE', 'WV'):
                            line = "~" + line
                        line += " kbps"
                        ddt.draw_text((x2, y1), line, value_colour, 312)

                    # -----------
                    if tc.artist != tc.album_artist != "":
                        x += int(170 * gui.scale)
                        rect = [x + 7 * gui.scale, y1 + (2 * gui.scale), 220 * gui.scale, 14 * gui.scale]
                        fields.add(rect)
                        if coll(rect):
                            ddt.draw_text((x + (8 + 75) * gui.scale, y1, 1), "Album Artist", key_colour_on, 212)
                            if input.mouse_click:
                                show_message("Album artist copied to clipboard")
                                copy_to_clipboard(tc.album_artist)
                                input.mouse_click = False
                        else:
                            ddt.draw_text((x + (8 + 75) * gui.scale, y1, 1), "Album Artist", key_colour_off, 212)

                        q = ddt.draw_text((x + (8 + 88)  * gui.scale, y1), tc.album_artist,
                                  value_colour, value_font, max_w=120 * gui.scale)
                        if coll(rect):
                            ex_tool_tip(x2 + 185 * gui.scale, y1, q, tc.album_artist, value_font)

                        x -= int(170 * gui.scale)

                    y1 += int(15 * gui.scale)

                    rect = [x1, y1, 150 * gui.scale, 16 * gui.scale]
                    fields.add(rect)
                    if coll(rect):
                        ddt.draw_text((x1, y1), "Duration", key_colour_on, 212)
                        if input.mouse_click:
                            copy_to_clipboard(time.strftime('%M:%S', time.gmtime(tc.length)).lstrip("0"))
                            show_message("Duration copied to clipboard")
                            input.mouse_click = False
                    else:
                        ddt.draw_text((x1, y1), "Duration", key_colour_off, 212)
                    line = time.strftime('%M:%S', time.gmtime(tc.length))
                    ddt.draw_text((x2, y1), line, value_colour, value_font)

                    # -----------
                    if tc.track_total not in ("", "0"):
                        x += int(170 * gui.scale)
                        line = str(tc.track_number) + " of " + str(
                            tc.track_total)
                        ddt.draw_text((x + (8 + 75) * gui.scale, y1, 1), "Track", key_colour_off, 212)
                        ddt.draw_text((x + (8 + 88)  * gui.scale, y1), line,
                                  value_colour, value_font)
                        x -= int(170 * gui.scale)

                    y1 += int(15 * gui.scale)
                    #print(tc.size)
                    if tc.size != 0:
                        ddt.draw_text((x1, y1), "File size", key_colour_off, 212)
                        ddt.draw_text((x2, y1), get_filesize_string(tc.size),
                                  value_colour, value_font)

                    # -----------
                    if tc.disc_total not in ("", "0", 0):
                        x += int(170 * gui.scale)
                        line = str(tc.disc_number) + " of " + str(
                            tc.disc_total)
                        ddt.draw_text((x + (8 + 75) * gui.scale, y1, 1), "Disc", key_colour_off, 212)
                        ddt.draw_text((x + (8 + 88) * gui.scale, y1), line,
                                  value_colour, value_font)
                        x -= int(170 * gui.scale)

                    y1 += int(23 * gui.scale)

                    rect = [x1, y1 + (2 * gui.scale), 150 * gui.scale, 14 * gui.scale]
                    fields.add(rect)
                    if coll(rect):
                        ddt.draw_text((x1, y1), "Genre", key_colour_on, 212)
                        if input.mouse_click:
                            show_message("Genre field copied to clipboard")
                            copy_to_clipboard(tc.genre)
                            input.mouse_click = False
                    else:
                        ddt.draw_text((x1, y1), "Genre", key_colour_off, 212)
                    ddt.draw_text((x2, y1), tc.genre, value_colour,
                              value_font, max_w=290 * gui.scale)

                    y1 += int(15 * gui.scale)

                    rect = [x1, y1 + (2 * gui.scale), 150 * gui.scale, 14 * gui.scale]
                    fields.add(rect)
                    if coll(rect):
                        ddt.draw_text((x1, y1), "Date", key_colour_on, 212)
                        if input.mouse_click:
                            show_message("Date field copied to clipboard")
                            copy_to_clipboard(tc.date)
                            input.mouse_click = False
                    else:
                        ddt.draw_text((x1, y1), "Date", key_colour_off, 212)
                    ddt.draw_text((x2, y1), str(tc.date),
                              value_colour, value_font)


                    if tc.composer and tc.composer != tc.artist:
                        x += int(170 * gui.scale)
                        rect = [x + 7 * gui.scale, y1 + (2 * gui.scale), 220 * gui.scale, 14 * gui.scale]
                        fields.add(rect)
                        if coll(rect):
                            ddt.draw_text((x + (8 + 75) * gui.scale, y1, 1), "Composer", key_colour_on, 212)
                            if input.mouse_click:
                                show_message("Composer copied to clipboard")
                                copy_to_clipboard(tc.album_artist)
                                input.mouse_click = False
                        else:
                            ddt.draw_text((x + (8 + 75) * gui.scale, y1, 1), "Composer", key_colour_off, 212)
                        q = ddt.draw_text((x + (8 + 88)  * gui.scale, y1), tc.composer,
                                  value_colour, value_font, max_w=120 * gui.scale)
                        if coll(rect):
                            ex_tool_tip(x2 + 185 * gui.scale, y1, q, tc.composer, value_font_a)

                        x -= int(170 * gui.scale)

                    y1 += int(23 * gui.scale)

                    total = star_store.get(r_menu_index)
                    ratio = 0

                    if total > 0 and pctl.master_library[
                        r_menu_index].length != 0:
                        ratio = total / tc.length

                    ddt.draw_text((x1, y1), "Play count", key_colour_off, 212)
                    ddt.draw_text((x2, y1), str(int(ratio)), value_colour, value_font)

                    y1 += int(15 * gui.scale)

                    rect = [x1, y1, 150, 14]

                    if coll(rect) and key_shift_down and mouse_wheel != 0:
                        star_store.add(r_menu_index, 60 * mouse_wheel)

                    line = time.strftime('%H:%M:%S',
                                         time.gmtime(total))

                    ddt.draw_text((x1, y1), "Play time", key_colour_off, 212)
                    ddt.draw_text((x2, y1), str(line), value_colour, value_font)

                    # -------
                    if tc.lyrics != "":

                        if draw.button("Lyrics", x1 + 200 * gui.scale, y1 - 10 * gui.scale):
                            prefs.show_lyrics_showcase = True
                            track_box = False
                            switch_showcase(r_menu_index)
                            input.mouse_click = False

                    if len(tc.comment) > 0:
                        y1 += 20 * gui.scale
                        rect = [x1, y1 + (2 * gui.scale), 60 * gui.scale, 14 * gui.scale]
                        #ddt.rect_r((x2, y1, 335, 10), [255, 20, 20, 255])
                        fields.add(rect)
                        if coll(rect):
                            ddt.draw_text((x1, y1), "Comment", key_colour_on, 212)
                            if input.mouse_click:
                                show_message("Comment copied to clipboard")
                                copy_to_clipboard(tc.comment)
                                input.mouse_click = False
                        else:
                            ddt.draw_text((x1, y1), "Comment", key_colour_off, 212)
                        # ddt.draw_text((x1, y1), "Comment", key_colour_off, 12)

                        if "\n" not in tc.comment and ('http://' in tc.comment or 'www.' in tc.comment or 'https://' in tc.comment) and ddt.get_text_w(
                                tc.comment, 12) < 335 * gui.scale:

                            link_pa = draw_linked_text((x2, y1), tc.comment, value_colour, 12)
                            link_rect = [x + 98 * gui.scale + link_pa[0], y1 - 2 * gui.scale, link_pa[1], 20 * gui.scale]

                            fields.add(link_rect)
                            if coll(link_rect):
                                if not input.mouse_click:
                                    gui.cursor_want = 3
                                if input.mouse_click:
                                    webbrowser.open(link_pa[2], new=2, autoraise=True)
                                    track_box = True

                        elif comment_mode == 1:
                            ddt.draw_text((x + 18 * gui.scale, y1 + 18 * gui.scale, 4, w - 36 * gui.scale, 90 * gui.scale), tc.comment, value_colour, 12)
                        else:
                            ddt.draw_text((x2, y1), tc.comment, value_colour, 12)

            fader.render()
            if pref_box.enabled:
                # rect = [0, 0, window_size[0], window_size[1]]
                # ddt.rect_r(rect, [0, 0, 0, 90], True)
                pref_box.render()

            if gui.rename_folder_box:

                if gui.level_2_click:
                    input.mouse_click = True
                gui.level_2_click = False

                w = 500 * gui.scale
                h = 127 * gui.scale
                x = int(window_size[0] / 2) - int(w / 2)
                y = int(window_size[1] / 2) - int(h / 2)

                ddt.rect_a((x - 2 * gui.scale, y - 2 * gui.scale), (w + 4 * gui.scale, h + 4 * gui.scale), colours.grey(80), True)
                ddt.rect_a((x, y), (w, h), colours.sys_background_3, True)

                ddt.text_background_colour = colours.sys_background_3

                if key_esc_press or ((input.mouse_click or right_click) and not coll((x, y, w, h))):
                    gui.rename_folder_box = False

                p = ddt.draw_text((x + 10 * gui.scale, y + 9 * gui.scale,), "Folder Modification", colours.grey(230), 213)

                if rename_folder.text != prefs.rename_folder_template and draw.button("Default", x + (300 - 63) * gui.scale, y + 11 * gui.scale,
                               70 * gui.scale):
                    rename_folder.text = prefs.rename_folder_template


                rename_folder.draw(x + 14 * gui.scale, y + 41 * gui.scale, colours.alpha_grey(190), width=300)

                ddt.rect_a((x + 8 * gui.scale, y + 38 * gui.scale), (300 * gui.scale, 22 * gui.scale), colours.grey(50))

                if draw.button("Rename", x + (8 + 300 + 10) * gui.scale, y + 38 * gui.scale, 80 * gui.scale, tooltip="Renames the physical folder based on the template") or input.level_2_enter:
                    rename_parent(rename_index, rename_folder.text)
                    gui.rename_folder_box = False
                    input.mouse_click = False

                text = "Trash"
                tt = "Moves folder to system trash"
                if key_shift_down:
                    text = "Delete"
                    tt = "Physically deletes folder from disk"
                if draw.button(text, x + (8 + 300 + 10) * gui.scale, y + 11 * gui.scale, 80 * gui.scale, fore_text=colours.grey(255), fg=[180, 60, 60, 255], tooltip=tt):
                    if key_shift_down:
                        delete_folder(rename_index, True)
                    else:
                        delete_folder(rename_index)
                    gui.rename_folder_box = False
                    input.mouse_click = False

                if move_folder_up(rename_index):
                    if draw.button("Raise", x + 408 * gui.scale, y + 38 * gui.scale, 80 * gui.scale, tooltip="Moves folder up 2 levels and deletes old the containing folder"):
                        move_folder_up(rename_index, True)
                        input.mouse_click = False

                to_clean = clean_folder(rename_index)
                if to_clean > 0:
                    if draw.button("Clean (" + str(to_clean) + ")", x + 408 * gui.scale, y + 11 * gui.scale, 80 * gui.scale, tooltip="Deletes some unnecessary files from folder"):
                        clean_folder(rename_index, True)
                        input.mouse_click = False

                ddt.draw_text((x + 10 * gui.scale, y + 65 * gui.scale,), "PATH", colours.grey(100), 212)
                line = os.path.dirname(pctl.master_library[rename_index].parent_folder_path.rstrip("\\/")).replace("\\", "/") + "/"
                line = right_trunc(line, 12, 420 * gui.scale)
                ddt.draw_text((x + 60 * gui.scale, y + 65 * gui.scale,), line, colours.grey(200), 211)

                ddt.draw_text((x + 10 * gui.scale, y + 83 * gui.scale), "OLD", colours.grey(100), 212)
                line = pctl.master_library[rename_index].parent_folder_name
                ddt.draw_text((x + 60 * gui.scale, y + 83 * gui.scale), line, colours.grey(200), 211, max_w=420 * gui.scale)

                ddt.draw_text((x + 10 * gui.scale, y + 101 * gui.scale), "NEW", colours.grey(100), 212)
                line = parse_template2(rename_folder.text, pctl.master_library[rename_index])
                ddt.draw_text((x + 60 * gui.scale, y + 101 * gui.scale), line, colours.grey(200), 211, max_w=420 * gui.scale)


            if renamebox:

                if gui.level_2_click:
                    input.mouse_click = True
                gui.level_2_click = False

                w = 420 * gui.scale
                h = 155 * gui.scale
                x = int(window_size[0] / 2) - int(w / 2)
                y = int(window_size[1] / 2) - int(h / 2)

                ddt.rect_a((x - 2 * gui.scale, y - 2 * gui.scale), (w + 4 * gui.scale, h + 4 * gui.scale), colours.grey(80), True)
                ddt.rect_a((x, y), (w, h), colours.sys_background_3, True)
                ddt.text_background_colour = colours.sys_background_3

                if key_esc_press or ((input.mouse_click or right_click) and not coll((x, y, w, h))):
                    renamebox = False

                r_todo = []

                # Find matching folder tracks in playlist
                for item in default_playlist:
                    if pctl.master_library[item].parent_folder_path == pctl.master_library[
                                rename_index].parent_folder_path:

                        # Close and display error if any tracks are not single local files
                        if pctl.master_library[item].is_network is True:
                            renamebox = False
                            show_message("Cannot rename", 'info', "One or more tracks is from a network location!")
                        if pctl.master_library[item].is_cue is True:
                            renamebox = False
                            show_message("This function does not support renaming CUE Sheet tracks.")
                        else:
                            r_todo.append(item)

                ddt.draw_text((x + 10 * gui.scale, y + 8 * gui.scale,), _("Track Renaming"), colours.grey(230), 213)

                #if draw.button("Default", x + 230 * gui.scale, y + 8 * gui.scale,
                if rename_files.text != prefs.rename_tracks_template and draw.button(_("Default"), x + w - 85 * gui.scale, y + h - 35 * gui.scale,
                               70 * gui.scale):
                    rename_files.text = prefs.rename_tracks_template

                # ddt.draw_text((x + 14, y + 40,), NRN + cursor, colours.grey(150), 12)
                rename_files.draw(x + 14 * gui.scale, y + 39 * gui.scale, colours.alpha_grey(170), width=300)
                NRN = rename_files.text

                ddt.rect_a((x + 8 * gui.scale, y + 36 * gui.scale), (300 * gui.scale, 22 * gui.scale), colours.grey(50))

                afterline = ""
                warn = False
                underscore = False

                for item in r_todo:

                    if pctl.master_library[item].track_number == "" or pctl.master_library[item].artist == "" or \
                                    pctl.master_library[item].title == "" or pctl.master_library[item].album == "":
                        warn = True

                    if item == rename_index:
                        afterline = parse_template2(NRN, pctl.master_library[item])

                ddt.draw_text((x + 10 * gui.scale, y + 68 * gui.scale), _("BEFORE"), colours.grey(100), 212)
                line = trunc_line(pctl.master_library[rename_index].filename, 12, 335)
                ddt.draw_text((x + 70 * gui.scale, y + 68 * gui.scale), line, colours.grey(210), 211, max_w=340)

                ddt.draw_text((x + 10 * gui.scale, y + 83 * gui.scale), _("AFTER"), colours.grey(100), 212)
                ddt.draw_text((x + 70 * gui.scale, y + 83 * gui.scale), afterline, colours.grey(210), 211, max_w=340)



                if (len(NRN) > 3 and len(pctl.master_library[rename_index].filename) > 3 and afterline[-3:].lower() !=
                    pctl.master_library[rename_index].filename[-3:].lower()) or len(NRN) < 4 or "." not in afterline[-5:]:
                    ddt.draw_text((x + 10 * gui.scale, y + 108 * gui.scale,), "Warning: This may change the file extension", [245, 90, 90, 255],
                              13)

                colour_warn = [143,186, 65, 255]
                if not unique_template(NRN):
                    ddt.draw_text((x + 10 * gui.scale, y + 123 * gui.scale,), "Warning: The filename might not be unique", [245, 90, 90, 255],
                              13)
                if warn:
                    ddt.draw_text((x + 10 * gui.scale, y + 135 * gui.scale,), "Warning: A track has incomplete metadata", [245, 90, 90, 255], 13)
                    colour_warn = [180, 60, 60, 255]

                label = "Write (" + str(len(r_todo)) + ")"

                if draw.button(label, x + (8 + 300 + 10) * gui.scale, y + 36 * gui.scale, 80 * gui.scale, fore_text=colours.grey(255), fg=colour_warn, tooltip="Physically renames all the tracks in the folder") or input.level_2_enter:
                    input.mouse_click = False
                    total_todo = len(r_todo)
                    pre_state = 0

                    for item in r_todo:

                        if pctl.playing_state > 0 and item == pctl.track_queue[pctl.queue_step]:
                            pre_state = pctl.stop(True)

                        try:

                            afterline = parse_template2(NRN, pctl.master_library[item], strict=True)

                            oldname = pctl.master_library[item].filename
                            oldpath = pctl.master_library[item].fullpath

                            print('Renaming...')

                            star = star_store.full_get(item)
                            star_store.remove(item)

                            oldpath = pctl.master_library[item].fullpath

                            oldsplit = os.path.split(oldpath)

                            if os.path.exists(os.path.join(oldsplit[0], afterline)):
                                print("A file with that name already exists")
                                total_todo -= 1
                                continue

                            if not afterline:
                                print("Rename Error")
                                total_todo -= 1
                                continue

                            if "." in afterline and not afterline.split(".")[0]:
                                print("A file does not have a target filename")
                                total_todo -= 1
                                continue

                            os.rename(pctl.master_library[item].fullpath, os.path.join(oldsplit[0], afterline))

                            pctl.master_library[item].fullpath = os.path.join(oldsplit[0], afterline)
                            pctl.master_library[item].filename = afterline

                            if star is not None:
                                star_store.insert(item, star)

                        except:
                            total_todo -= 1

                    renamebox = False
                    print('Done')
                    if pre_state == 1:
                        pctl.revert()


                    if total_todo != len(r_todo):
                        show_message("Rename complete." + "  " + str(total_todo) + "/" + str(len(r_todo)) + " filenames written.", 'warning')

                    else:
                        show_message(_("Rename complete."), 'done', str(total_todo) + "/" + str(len(r_todo)) + _(" filenames were written."))
                    tauon.worker_save_state = True

            if radiobox:

                s1 = 16 * gui.scale
                sh = s1 * len(pctl.save_urls)

                w = 450 * gui.scale
                h = 103 * gui.scale + sh
                x = int(window_size[0] / 2) - int(w / 2)
                y = int(window_size[1] / 2) - int(h / 2)

                ddt.rect_a((x - 2 * gui.scale, y - 2 * gui.scale), (w + 4 * gui.scale, h + 4 * gui.scale), colours.grey(50), True)
                ddt.rect_a((x, y), (w, h), colours.sys_background_3, True)

                ddt.text_background_colour = colours.sys_background_3

                if key_esc_press or (gui.level_2_click and not coll((x, y, w, h))):
                    radiobox = False

                ddt.draw_text((x + 10 * gui.scale, y + 8 * gui.scale,), _("Open HTTP Audio Stream"), colours.sys_title, 213)
                #ddt.text_background_colour = colours.sys_background_3

                y1 = y
                y += 30 * gui.scale

                to_del = None

                for i, item in enumerate(pctl.save_urls):
                    rect = (x + 13 * gui.scale, y, 380 * gui.scale, s1-1 * gui.scale)
                    if coll(rect):
                        if gui.level_2_click:
                            pass

                    ddt.draw_text((x + 13 * gui.scale, y), item, colours.grey(150), 12, 330 * gui.scale)

                    rect = (x + (17 + 330) * gui.scale, y, 40 * gui.scale, 14 * gui.scale)
                    fields.add(rect)
                    if coll(rect):
                        ddt.rect_r(rect, [40, 40, 40, 60], True)
                        if gui.level_2_click:
                            to_del = i

                    ddt.rect_r(rect, [50, 50, 50, 75], True)
                    ddt.draw_text((rect[0] + 20 * gui.scale, rect[1] + -1 * gui.scale, 2), "Del", colours.grey(180), 211)


                    rect = (x + (17 + 380) * gui.scale, y, 40 * gui.scale, 14 * gui.scale)
                    fields.add(rect)
                    if coll(rect):
                        ddt.rect_r(rect, [40, 40, 40, 60], True)
                        if gui.level_2_click:
                            radio_field.text = item


                    ddt.rect_r(rect, [50, 50, 50, 75], True)
                    ddt.draw_text((rect[0] + 20 * gui.scale, rect[1] + -1 * gui.scale, 2), "Sel", colours.grey(180), 211)


                    y += s1

                if to_del is not None:
                    del pctl.save_urls[to_del]


                y = y1 + sh

                radio_field.draw(x + 14 * gui.scale, y + 40 * gui.scale, colours.grey_blend_bg3(170), width=380 * gui.scale, click=gui.level_2_click)

                ddt.rect_a((x + 8 * gui.scale, y + 38 * gui.scale), (380 * gui.scale, 22 * gui.scale), colours.grey(50))

                draw.button("GO", x + (8 + 380 + 10) * gui.scale, y + 38 * gui.scale, 40 * gui.scale)

                if draw.button("Save", x + 337 * gui.scale, y + 70 * gui.scale, 50 * gui.scale, press=gui.level_2_click):
                    pctl.save_urls.append(radio_field.text)

                if (input.level_2_enter or (
                            gui.level_2_click and
                            coll((x + (8 + 380 + 10) *
                                gui.scale, y + 38 * gui.scale, 40 * gui.scale, 22 * gui.scale)))):
                    if 'youtube.' in radio_field.text or 'youtu.be' in radio_field.text:
                        radiobox = False
                        show_message("Sorry, youtube links are not supported.")
                    elif "http://" in radio_field.text or "https://" in radio_field.text \
                            or "ftp://" in radio_field.text:
                        print("Start radio")
                        pctl.url = radio_field.text.encode('utf-8')
                        pctl.playing_state = 0
                        pctl.record_stream = False
                        pctl.playerCommand = "url"
                        pctl.playerCommandReady = True
                        pctl.playing_state = 3
                        pctl.playing_time = 0
                        pctl.decode_time = 0
                        pctl.playing_length = 0

                    elif radio_field.text == "":
                        pass
                    else:
                        print("Radio fail")
                        radiobox = False
                        gui.update = 1
                        show_message("Could not validate URL.", 'info',
                                     "Make sure the URL starts with 'http://' or 'ftp://'.")

                x -= 230 * gui.scale
                # y += 30
                rect = (x + 277 * gui.scale, y + 70 * gui.scale, 50 * gui.scale, 22 * gui.scale)
                fields.add(rect)

                if pctl.playing_state == 3:

                    if coll(rect):
                        if gui.level_2_click:
                            pctl.playerCommand = 'record'
                            pctl.playerCommandReady = True
                        ddt.rect_a((rect[0], rect[1]), (rect[2], rect[3]), alpha_blend([255, 255, 255, 20],
                                                                                      colours.sys_background_3), True)
                        ddt.draw_text((rect[0] + 7 * gui.scale, rect[1] + 3 * gui.scale), "Rec", colours.grey(210), 212)
                        ddt.draw_text((rect[0] + 34 * gui.scale, rect[1] + 2 * gui.scale), "â", [230, 20, 20, 255], 212)
                    else:
                        ddt.rect_a((rect[0], rect[1]), (rect[2], rect[3]), alpha_blend([255, 255, 255, 9],
                                                                                      colours.sys_background_3), True)
                        ddt.draw_text((rect[0] + 7 * gui.scale, rect[1] + 3 * gui.scale), "Rec", colours.grey(190), 212)
                        ddt.draw_text((rect[0] + 34 * gui.scale, rect[1] + 2 * gui.scale), "â", [220, 20, 20, 255], 212)
                else:
                    if coll(rect):
                        if gui.level_2_click:
                            radiobox = False
                            show_message("A stream needs to be playing first.")
                    ddt.rect_a((rect[0], rect[1]), (rect[2], rect[3]), alpha_blend([255, 255, 255, 7],
                                                                                  colours.sys_background_3), True)
                    ddt.draw_text((rect[0] + 7 * gui.scale, rect[1] + 3 * gui.scale), "Rec", colours.grey(150), 212)
                    ddt.draw_text((rect[0] + 34 * gui.scale, rect[1] + 2 * gui.scale), "â", [200, 15, 15, 255], 212)

                gui.level_2_click = False

            if gui.message_box:
                if input.mouse_click or input.key_return_press or right_click or key_esc_press or key_backspace_press \
                        or keymaps.test("quick-find") or (k_input and message_box_min_timer.get() > 1.2):
                    gui.message_box = False
                    input.key_return_press = False



                w1 = ddt.get_text_w(gui.message_text, 15) + 74 * gui.scale
                w2 = ddt.get_text_w(gui.message_subtext, 12) + 74 * gui.scale
                w = max(w1, w2)

                if w < 210 * gui.scale:
                    w = 210 * gui.scale

                h = 60 * gui.scale
                x = int(window_size[0] / 2) - int(w / 2)
                y = int(window_size[1] / 2) - int(h / 2)

                ddt.rect_a((x - 2 * gui.scale, y - 2 * gui.scale), (w + 4 * gui.scale, h + 4 * gui.scale),
                          colours.grey(55), True)
                ddt.rect_a((x, y), (w, h), colours.message_box_bg, True)

                ddt.text_background_colour = colours.message_box_bg

                if gui.message_mode == 'info':
                    message_info_icon.render(x + 14 * gui.scale, y + int(h / 2) - int(message_info_icon.h / 2) - 1)
                elif gui.message_mode == 'warning':
                    message_warning_icon.render(x + 14 * gui.scale, y + int(h / 2) - int(message_info_icon.h / 2) - 1)
                elif gui.message_mode == 'done':
                    message_tick_icon.render(x + 14 * gui.scale, y + int(h / 2) - int(message_info_icon.h / 2) - 1)
                elif gui.message_mode == 'arrow':
                    message_arrow_icon.render(x + 14 * gui.scale, y + int(h / 2) - int(message_info_icon.h / 2) - 1)
                elif gui.message_mode == 'error':
                    message_error_icon.render(x + 14 * gui.scale, y + int(h / 2) - int(message_error_icon.h / 2) - 1)
                elif gui.message_mode == 'bubble':
                    message_bubble_icon.render(x + 14 * gui.scale, y + int(h / 2) - int(message_bubble_icon.h / 2) - 1)
                elif gui.message_mode == 'link':
                    message_info_icon.render(x + 14 * gui.scale, y + int(h / 2) - int(message_bubble_icon.h / 2) - 1)

                if len(gui.message_subtext) > 0:
                    ddt.draw_text((x + 62 * gui.scale, y + 11 * gui.scale), gui.message_text, colours.message_box_text, 15)
                    if gui.message_mode == "bubble" or gui.message_mode == 'link':
                        link_pa = draw_linked_text((x + 63 * gui.scale, y + (9 + 22) * gui.scale), gui.message_subtext, colours.message_box_text, 12)
                        link_activate(x + 63 * gui.scale, y + (9 + 22) * gui.scale, link_pa)
                    else:
                        ddt.draw_text((x + 63 * gui.scale, y + (9 + 22) * gui.scale), gui.message_subtext, colours.message_box_text, 12)
                else:
                    ddt.draw_text((x + 62 * gui.scale, y + 20 * gui.scale), gui.message_text, colours.message_box_text, 15)

            # SEARCH
            # if key_ctrl_down and key_v_press:

            #     search_over.active = True

            search_over.render()

            if keymaps.test("quick-find") and quick_search_mode is False:
                if not search_over.active:
                    quick_search_mode = True
                if search_clear_timer.get() > 3:
                    search_text.text = ""
                input_text = ""
            elif (keymaps.test("quick-find") or (
                        key_esc_press and len(editline) == 0)) or input.mouse_click and quick_search_mode is True:
                quick_search_mode = False
                search_text.text = ""

            # if (key_backslash_press or (key_ctrl_down and key_f_press)) and quick_search_mode is False:
            #     if not search_over.active:
            #         quick_search_mode = True
            #     if search_clear_timer.get() > 3:
            #         search_text.text = ""
            #     input_text = ""
            # elif ((key_backslash_press or (key_ctrl_down and key_f_press)) or (
            #             key_esc_press and len(editline) == 0)) or input.mouse_click and quick_search_mode is True:
            #     quick_search_mode = False
            #     search_text.text = ""

            if quick_search_mode is True:

                rect2 = [0, window_size[1] - 85 * gui.scale, 420 * gui.scale, 25 * gui.scale]
                rect = [0, window_size[1] - 125 * gui.scale, 420 * gui.scale, 65 * gui.scale]
                rect[0] = int(window_size[0] / 2) - int(rect[2] / 2)
                rect2[0] = rect[0]

                ddt.rect_r((rect[0] - 2, rect[1] - 2, rect[2] + 4, rect[3] + 4), [220,100,5,255], True)
                #ddt.rect_r((rect[0], rect[1], rect[2], rect[3]), [255,120,5,255], True)

                ddt.text_background_colour = colours.sys_background_4
                #ddt.text_background_colour = [255,120,5,255]
                #ddt.text_background_colour = [220,100,5,255]
                ddt.rect_r(rect, colours.sys_background_4, True)

                if len(input_text) > 0:
                    search_index = -1

                if key_backspace_press and search_text.text == "":
                    quick_search_mode = False

                if len(search_text.text) == 0:
                    gui.search_error = False

                if len(search_text.text) != 0 and search_text.text[0] == '/':
                    # if "/love" in search_text.text:
                    #     line = "last.fm loved tracks from user. Format: /love <username>"
                    # else:
                    line = "Folder filter mode. Enter path segment."
                    ddt.draw_text((rect[0] + 23 * gui.scale, window_size[1] - 87 * gui.scale), line, colours.grey(80), 312)
                else:
                    line = "UP / DOWN to navigate. SHIFT + RETURN for new playlist."
                    if len(search_text.text) == 0:
                        line = "Quick find"
                    ddt.draw_text((rect[0] + int(rect[2] / 2), window_size[1] - 87 * gui.scale, 2), line,
                              colours.grey(80), 312)

                    # ddt.draw_text((rect[0] + int(rect[2] / 2), window_size[1] - 118 * gui.scale, 2), "Find",
                    #           colours.grey(90), 214)

                # if len(pctl.track_queue) > 0:

                    # if input_text == 'A':
                    #     search_text.text = pctl.playing_object().artist
                    #     input_text = ""

                if gui.search_error:
                    ddt.rect_r([rect[0], rect[1], rect[2], 30 * gui.scale], [180, 40, 40, 255], True)
                    ddt.text_background_colour = [180, 40, 40, 255] #alpha_blend([255,0,0,25], ddt.text_background_colour)
                # if key_backspace_press:
                #     gui.search_error = False

                search_text.draw(rect[0] + 8 * gui.scale, rect[1] + 6 * gui.scale, colours.grey(250), font=213)

                if (key_shift_down or (len(search_text.text) > 0 and search_text.text[0] == '/')) and input.key_return_press:
                    input.key_return_press = False
                    playlist = []
                    if len(search_text.text) > 0:
                        if search_text.text[0] == '/':

                            if search_text.text.lower() == "/random" or search_text.text.lower() == "/shuffle":
                                gen_500_random(pctl.active_playlist_viewing)
                            elif search_text.text.lower() == "/top" or search_text.text.lower() == "/most":
                                gen_top_100(pctl.active_playlist_viewing)
                            elif search_text.text.lower() == "/length" or search_text.text.lower() == "/duration"\
                                    or search_text.text.lower() == "/len":
                                gen_sort_len(pctl.active_playlist_viewing)

                            else:

                                if search_text.text[-1] == "/":
                                    tt_title = search_text.text.replace('/', "")
                                else:
                                    search_text.text = search_text.text.replace('/', "")
                                    tt_title = search_text.text
                                search_text.text = search_text.text.lower()
                                for item in default_playlist:
                                    if search_text.text in pctl.master_library[item].parent_folder_path.lower():
                                        playlist.append(item)
                                if len(playlist) > 0:

                                    pctl.multi_playlist.append(pl_gen(title=tt_title,
                                                                      playlist=copy.deepcopy(playlist)))
                                    switch_playlist(len(pctl.multi_playlist) - 1)

                        else:
                            search_terms = search_text.text.lower().split()
                            for item in default_playlist:
                                line = pctl.master_library[item].title.lower() + \
                                       pctl.master_library[item].artist.lower() \
                                       + pctl.master_library[item].album.lower() + \
                                       pctl.master_library[item].filename.lower()
                                if all(word in line for word in search_terms):
                                    playlist.append(item)
                            if len(playlist) > 0:
                                pctl.multi_playlist.append(pl_gen(title="Search Results",
                                                                  playlist=copy.deepcopy(playlist)))
                                switch_playlist(len(pctl.multi_playlist) - 1)
                        search_text.text = ""
                        quick_search_mode = False

                if (len(input_text) > 0 and not gui.search_error) or key_down_press is True or key_backspace_press\
                        or gui.force_search:

                    gui.pl_update = 1

                    if gui.force_search:
                        search_index = 0



                    if key_backspace_press:
                        search_index = 0

                    if len(search_text.text) > 0 and search_text.text[0] != "/":
                        oi = search_index

                        while search_index < len(default_playlist) - 1:
                            search_index += 1
                            if search_index > len(default_playlist) - 1:
                                search_index = 0

                            search_terms = search_text.text.lower().split()
                            line = pctl.master_library[default_playlist[search_index]].title.lower() + \
                                pctl.master_library[default_playlist[search_index]].artist.lower() \
                                + pctl.master_library[default_playlist[search_index]].album.lower() + \
                                pctl.master_library[default_playlist[search_index]].filename.lower()

                            if all(word in line for word in search_terms):

                                playlist_selected = search_index
                                if len(default_playlist) > 10 and search_index > 10:
                                    pctl.playlist_view_position = search_index - 7
                                else:
                                    pctl.playlist_view_position = 0

                                if gui.combo_mode:
                                    pctl.show_selected()
                                gui.search_error = False

                                break

                        else:
                            search_index = oi
                            if len(input_text) > 0 or gui.force_search:
                                gui.search_error = True
                            if key_down_press:
                                bottom_playlist.pulse()

                        gui.force_search = False

                if key_up_press is True \
                        and not key_shiftr_down \
                        and not key_shift_down \
                        and not key_ctrl_down\
                        and not key_rctrl_down\
                        and not key_meta\
                        and not key_lalt\
                        and not key_ralt:

                    gui.pl_update = 1
                    oi = search_index

                    while search_index > 1:
                        search_index -= 1
                        if search_index > len(default_playlist) - 1:
                            search_index = len(default_playlist) - 1
                        search_terms = search_text.text.lower().split()
                        line = pctl.master_library[default_playlist[search_index]].title.lower() + \
                            pctl.master_library[default_playlist[search_index]].artist.lower() \
                            + pctl.master_library[default_playlist[search_index]].album.lower() + \
                            pctl.master_library[default_playlist[search_index]].filename.lower()

                        if all(word in line for word in search_terms):

                            playlist_selected = search_index
                            if len(default_playlist) > 10 and search_index > 10:
                                pctl.playlist_view_position = search_index - 7
                            else:
                                pctl.playlist_view_position = 0
                            if gui.combo_mode:
                                pctl.show_selected()
                            break
                    else:
                        search_index = oi

                        edge_playlist.pulse()

                if input.key_return_press is True and search_index > -1:
                    gui.pl_update = 1
                    pctl.jump(default_playlist[search_index], search_index)
                    if album_mode:
                        goto_album(pctl.playlist_playing_position)
                    quick_search_mode = False
                    search_clear_timer.set()

            elif not search_over.active:

                if key_up_press  \
                        and not key_shiftr_down \
                        and not key_shift_down \
                        and not key_ctrl_down\
                        and not key_rctrl_down\
                        and not key_meta\
                        and not key_lalt\
                        and not key_ralt:
                    shift_selection = []

                    pctl.show_selected()
                    gui.pl_update = 1

                    if playlist_selected > 0:
                        playlist_selected -= 1

                    if pctl.playlist_view_position > 0 and playlist_selected < pctl.playlist_view_position + 2:
                        pctl.playlist_view_position -= 1

                        scroll_hide_timer.set()
                        gui.frame_callback_list.append(TestTimer(0.9))

                    if playlist_selected > len(default_playlist):
                        playlist_selected = len(default_playlist)


                if key_down_press and playlist_selected < len(default_playlist)  \
                        and not key_shiftr_down \
                        and not key_shift_down \
                        and not key_ctrl_down\
                        and not key_rctrl_down\
                        and not key_meta\
                        and not key_lalt\
                        and not key_ralt:

                    shift_selection = []
                    pctl.show_selected()
                    gui.pl_update = 1

                    if playlist_selected < len(default_playlist) - 1:
                        playlist_selected += 1

                    if pctl.playlist_view_position < len(
                            default_playlist) and playlist_selected > pctl.playlist_view_position + gui.playlist_view_length - 3 - gui.row_extra:
                        pctl.playlist_view_position += 1

                        scroll_hide_timer.set()
                        gui.frame_callback_list.append(TestTimer(0.9))

                    if playlist_selected < 0:
                        playlist_selected = 0

                if input.key_return_press and not pref_box.enabled and not radiobox:
                    gui.pl_update = 1
                    if playlist_selected > len(default_playlist) - 1:
                        playlist_selected = 0
                        shift_selection = []
                    if default_playlist:
                        pctl.jump(default_playlist[playlist_selected], playlist_selected)
                        if album_mode:
                            goto_album(pctl.playlist_playing_position)


        elif gui.mode == 3:

            if (key_shift_down and input.mouse_click) or middle_click:
                if prefs.mini_mode_mode == 4:
                    prefs.mini_mode_mode = 1
                    window_size[0] = int(330 * gui.scale)
                    window_size[1] = int(330 * gui.scale)
                    SDL_SetWindowMinimumSize(t_window, window_size[0], window_size[1])
                    SDL_SetWindowSize(t_window, window_size[0], window_size[1])
                else:
                    prefs.mini_mode_mode = 4
                    window_size[0] = int(320 * gui.scale)
                    window_size[1] = int(90 * gui.scale)
                    SDL_SetWindowMinimumSize(t_window, window_size[0], window_size[1])
                    SDL_SetWindowSize(t_window, window_size[0], window_size[1])

            if prefs.mini_mode_mode == 4:
                mini_mode2.render()
            else:
                mini_mode.render()


        # Render Menus-------------------------------
        for instance in Menu.instances:
            instance.render()

        if view_box.active:
            view_box.render()

        tool_tip.render()
        tool_tip2.render()

        if gui.cursor_is != gui.cursor_want:

            gui.cursor_is = gui.cursor_want

            if gui.cursor_is == 0:
                SDL_SetCursor(cursor_standard)
            elif gui.cursor_is == 1:
                SDL_SetCursor(cursor_shift)
            elif gui.cursor_is == 2:
                SDL_SetCursor(cursor_text)
            elif gui.cursor_is == 3:
                SDL_SetCursor(cursor_hand)

        get_sdl_input.test_capture_mouse()
        get_sdl_input.mouse_capture_want = False

        if draw_border and not gui.mode == 3:
            draw_window_tools()

        # Drag icon next to cursor
        if quick_drag and mouse_down and not point_proximity_test(gui.drag_source_position, mouse_position, 15):
            i_x, i_y = get_sdl_input.mouse()
            gui.drag_source_position = [0, 0]

            if len(shift_selection) == 1:
                ddt.rect_r((i_x + 20, i_y + 1, 10, 10), [160, 140, 235, 240], True)
            else:
                ddt.rect_r((i_x + 20, i_y + 1, 10, 25), [160, 140, 235, 240], True)

            gui.update += 1

        # Drag pl tab next to cursor
        if (playlist_box.drag) and mouse_down and not point_proximity_test(gui.drag_source_position, mouse_position, 10 * gui.scale):
            i_x, i_y = get_sdl_input.mouse()
            gui.drag_source_position = (0, 0)
            ddt.rect_r((i_x + 20 * gui.scale, i_y + 3 * gui.scale, int(50 * gui.scale), int(15 * gui.scale)), [50, 50, 50, 225], True)
            #ddt.rect_r((i_x + 20 * gui.scale, i_y + 1 * gui.scale, int(60 * gui.scale), int(15 * gui.scale)), [240, 240, 240, 255], True)
            #ddt.draw_text((i_x + 75 * gui.scale, i_y - 0 * gui.scale, 1), pctl.multi_playlist[playlist_box.drag_on][0], [30, 30, 30, 255], 212, bg=[240, 240, 240, 255])


        if (gui.set_label_hold != -1) and mouse_down and not point_proximity_test(gui.set_label_point, mouse_position, 3):
            i_x, i_y = get_sdl_input.mouse()

            gui.set_label_point = (0, 0)

            w = ddt.get_text_w(gui.pl_st[gui.set_label_hold][0], 212)
            w = max(w, 45 * gui.scale)
            ddt.rect_r((i_x + 25 * gui.scale, i_y + 1 * gui.scale, w + int(20 * gui.scale), int(15 * gui.scale)), [240, 240, 240, 255], True)
            ddt.draw_text((i_x + 25 * gui.scale + w + int(20 * gui.scale) - 4 * gui.scale, i_y - 0 * gui.scale, 1), gui.pl_st[gui.set_label_hold][0], [30, 30, 30, 255], 212, bg=[240, 240, 240, 255])


        gui.update -= 1
        if gui.update > 1:
            gui.update = 1
        gui.present = True

        SDL_SetRenderTarget(renderer, None)
        SDL_RenderCopy(renderer, gui.main_texture, None, gui.abc)

        if gui.turbo:
            gui.level_update = True


    if gui.vis == 1 and pctl.playing_state != 1 and gui.level_peak != [0, 0] and gui.turbo:

        # print(gui.level_peak)
        gui.time_passed = gui.level_time.hit()
        if gui.time_passed > 1:
            gui.time_passed = 0
        while gui.time_passed > 0.01:
            gui.level_peak[1] -= 0.5
            if gui.level_peak[1] < 0:
                gui.level_peak[1] = 0
            gui.level_peak[0] -= 0.5
            if gui.level_peak[0] < 0:
                gui.level_peak[0] = 0
            gui.time_passed -= 0.020

        gui.level_update = True

    if gui.level_update is True and not resize_mode and not gui.mode == 3:
        gui.level_update = False

        SDL_SetRenderTarget(renderer, None)
        if not gui.present:

            SDL_RenderCopy(renderer, gui.main_texture, None, gui.abc)
            gui.present = True

        if gui.vis == 3:
            # Scrolling spectrogram

            # if not vis_update:
            #     print("No UPDATE " + str(random.randint(1,50)))
            if len(gui.spec2_buffers) > 0 and gui.spec2_timer.get() > 0.04:
                #gui.spec2_timer.force_set(gui.spec2_timer.get() - 0.04)
                gui.spec2_timer.set()
                vis_update = True


            if len(gui.spec2_buffers) > 0 and vis_update:
                vis_update = False

                SDL_SetRenderTarget(renderer, gui.spec2_tex)
                for i, value in enumerate(gui.spec2_buffers[0]):

                    ddt.rect_r([gui.spec2_position, i, 1, 1],
                                [min(255, prefs.spec2_base[0] + int(value * prefs.spec2_multiply[0])),
                                 min(255, prefs.spec2_base[1] + int(value * prefs.spec2_multiply[1])),
                                 min(255, prefs.spec2_base[2] + int(value * prefs.spec2_multiply[2])),
                                 255], True)

                del gui.spec2_buffers[0]


                gui.spec2_position += 1

                if gui.spec2_position > gui.spec2_w - 1:
                    gui.spec2_position = 0


                SDL_SetRenderTarget(renderer, None)


            #
            # else:
            #     print("animation stall" + str(random.randint(1, 10)))

            if prefs.spec2_scroll:

                gui.spec2_source.x = 0
                gui.spec2_source.y = 0
                gui.spec2_source.w = gui.spec2_position
                gui.spec2_dest.x = gui.spec2_rec.x + gui.spec2_rec.w - gui.spec2_position
                gui.spec2_dest.w = gui.spec2_position
                SDL_RenderCopy(renderer, gui.spec2_tex, gui.spec2_source, gui.spec2_dest)

                gui.spec2_source.x = gui.spec2_position
                gui.spec2_source.y = 0
                gui.spec2_source.w = gui.spec2_rec.w - gui.spec2_position
                gui.spec2_dest.x = gui.spec2_rec.x
                gui.spec2_dest.w = gui.spec2_rec.w - gui.spec2_position
                SDL_RenderCopy(renderer, gui.spec2_tex, gui.spec2_source, gui.spec2_dest)

            else:

                SDL_RenderCopy(renderer, gui.spec2_tex, None, gui.spec2_rec)

            if pref_box.enabled:
                ddt.rect_r((gui.spec2_rec.x, gui.spec2_rec.y, gui.spec2_rec.w, gui.spec2_rec.h), [0, 0, 0, 90], True)

        if gui.vis == 4 and gui.draw_vis4_top:

            showcase.render_vis(True)
            # gui.level_update = False



        if gui.vis == 2 and gui.spec is not None:

            # Standard spectrum visualiser

            if gui.update_spec == 0 and pctl.playing_state != 2:

                if vis_decay_timer.get() > 0.007:  # Controls speed of decay after stop
                    vis_decay_timer.set()
                    for i in range(len(gui.spec)):
                        if gui.s_spec[i] > 0:
                            if gui.spec[i] > 0:
                                gui.spec[i] -= 1
                            gui.level_update = True
                else:
                    gui.level_update = True

            if vis_rate_timer.get() > 0.027:  # Limit the change rate #to 60 fps
                vis_rate_timer.set()

                if spec_smoothing and pctl.playing_state > 0:

                    for i in range(len(gui.spec)):
                        if gui.spec[i] > gui.s_spec[i]:
                            gui.s_spec[i] += 1
                            if abs(gui.spec[i] - gui.s_spec[i]) > 4:
                                gui.s_spec[i] += 1
                            if abs(gui.spec[i] - gui.s_spec[i]) > 6:
                                gui.s_spec[i] += 1
                            if abs(gui.spec[i] - gui.s_spec[i]) > 8:
                                gui.s_spec[i] += 1

                        elif gui.spec[i] == gui.s_spec[i]:
                            pass
                        elif gui.spec[i] < gui.s_spec[i] > 0:
                            gui.s_spec[i] -= 1
                            if abs(gui.spec[i] - gui.s_spec[i]) > 4:
                                gui.s_spec[i] -= 1
                            if abs(gui.spec[i] - gui.s_spec[i]) > 6:
                                gui.s_spec[i] -= 1
                            if abs(gui.spec[i] - gui.s_spec[i]) > 8:
                                gui.s_spec[i] -= 1

                    if pctl.playing_state == 0 and checkEqual(gui.s_spec):
                        gui.level_update = True
                        time.sleep(0.008)
                else:
                    gui.s_spec = gui.spec
            else:
                pass

            if not gui.test:

                SDL_SetRenderTarget(renderer, gui.spec1_tex)

                # ddt.rect_r(gui.spec_rect, colours.top_panel_background, True)
                ddt.rect_r((0, 0, gui.spec_w, gui.spec_h), colours.vis_bg, True)

                # xx = 0
                gui.bar.x = 0
                on = 0

                SDL_SetRenderDrawColor(renderer, colours.vis_colour[0],
                                       colours.vis_colour[1], colours.vis_colour[2],
                                       colours.vis_colour[3])

                for item in gui.s_spec:

                    if on > 19:
                        break
                    on += 1

                    item -= 1

                    if item < 1:
                        gui.bar.x += round(4 * gui.scale)
                        continue

                    if item > 20:
                        item = 20

                    if gui.scale == 2:
                        item *= gui.scale

                    gui.bar.y = 0 + gui.spec_h - item
                    gui.bar.h = item

                    SDL_RenderFillRect(renderer, gui.bar)

                    gui.bar.x += round(4 * gui.scale)

                if pref_box.enabled:
                    ddt.rect_r((0, 0, gui.spec_w, gui.spec_h), [0, 0, 0, 90], True)

                SDL_SetRenderTarget(renderer, None)
                SDL_RenderCopy(renderer, gui.spec1_tex, None, gui.spec1_rec)

        if gui.vis == 1:

            SDL_SetRenderTarget(renderer, gui.spec_level_tex)

            x = window_size[0] - 20 * gui.scale - gui.offset_extra
            y = gui.level_y
            w = gui.level_w
            s = gui.level_s

            y = 0

            gui.spec_level_rec.x = round(x - 70 * gui.scale)
            ddt.rect_a((0, 0), (79 * gui.scale, 18 * gui.scale), colours.grey(10),
                      True)

            x = round(gui.level_ww - 9 * gui.scale)
            y = 10 * gui.scale

            if (gui.level_peak[0] > 0 or gui.level_peak[1] > 0) and pctl.playing_state != 1:
                gui.level_update = True
                time.sleep(0.016)
                # print(vis_decay_timer.get())
                # vis_decay_timer.set()
                pass

            for t in range(12):

                if gui.level_peak[0] < t:
                    met = False
                else:
                    met = True
                if gui.level_peak[0] < 0.2:
                    met = False

                if gui.level_meter_colour_mode == 1:

                    if not met:
                        cc = [15, 10, 20, 255]
                    else:
                        cc = colorsys.hls_to_rgb(0.68 + (t * 0.015), 0.4, 0.7)
                        cc = (int(cc[0] * 255), int(cc[1] * 255), int(cc[2] * 255), 255)

                elif gui.level_meter_colour_mode == 2:

                    if not met:
                        cc = [11, 11, 13, 255]
                    else:
                        cc = colorsys.hls_to_rgb(0.63 - (t * 0.015), 0.4, 0.7)
                        cc = (int(cc[0] * 255), int(cc[1] * 255), int(cc[2] * 255), 255)

                elif gui.level_meter_colour_mode == 3:

                    if not met:
                        cc = [12, 6, 0, 255]
                    else:
                        cc = colorsys.hls_to_rgb(0.11 - (t * 0.010), 0.4, 0.7 + (t * 0.02))
                        cc = (int(cc[0] * 255), int(cc[1] * 255), int(cc[2] * 255), 255)

                elif gui.level_meter_colour_mode == 4:

                    if not met:
                        cc = [10, 10, 10, 255]
                    else:
                        cc = colorsys.hls_to_rgb(0.3 - (t * 0.03), 0.4, 0.7 + (t * 0.02))
                        cc = (int(cc[0] * 255), int(cc[1] * 255), int(cc[2] * 255), 255)

                else:

                    if t < 7:
                        cc = colours.level_green
                        if met is False:
                            cc = colours.level_1_bg
                    elif t < 10:
                        cc = colours.level_yellow
                        if met is False:
                            cc = colours.level_2_bg
                    else:
                        cc = colours.level_red
                        if met is False:
                            cc = colours.level_3_bg
                if gui.level > 0 and pctl.playing_state > 0:
                    pass
                ddt.rect_a(((x - (w * t) - (s * t)), y), (w, w), cc, True)

            y -= 7 * gui.scale
            for t in range(12):

                if gui.level_peak[1] < t:
                    met = False
                else:
                    met = True
                if gui.level_peak[1] < 0.2:
                    met = False

                if gui.level_meter_colour_mode == 1:

                    if not met:
                        cc = [15, 10, 20, 255]
                    else:
                        cc = colorsys.hls_to_rgb(0.68 + (t * 0.015), 0.4, 0.7)
                        cc = (int(cc[0] * 255), int(cc[1] * 255), int(cc[2] * 255), 255)

                elif gui.level_meter_colour_mode == 2:

                    if not met:
                        cc = [11, 11, 13, 255]
                    else:
                        cc = colorsys.hls_to_rgb(0.63 - (t * 0.015), 0.4, 0.7)
                        cc = (int(cc[0] * 255), int(cc[1] * 255), int(cc[2] * 255), 255)

                elif gui.level_meter_colour_mode == 3:

                    if not met:
                        cc = [12, 6, 0, 255]
                    else:
                        cc = colorsys.hls_to_rgb(0.11 - (t * 0.010), 0.4, 0.7 + (t * 0.02))
                        cc = (int(cc[0] * 255), int(cc[1] * 255), int(cc[2] * 255), 255)

                elif gui.level_meter_colour_mode == 4:

                    if not met:
                        cc = [10, 10, 10, 255]
                    else:
                        cc = colorsys.hls_to_rgb(0.3 - (t * 0.03), 0.4, 0.7 + (t * 0.02))
                        cc = (int(cc[0] * 255), int(cc[1] * 255), int(cc[2] * 255), 255)

                else:

                    if t < 7:
                        cc = colours.level_green
                        if met is False:
                            cc = colours.level_1_bg
                    elif t < 10:
                        cc = colours.level_yellow
                        if met is False:
                            cc = colours.level_2_bg
                    else:
                        cc = colours.level_red
                        if met is False:
                            cc = colours.level_3_bg

                if gui.level > 0 and pctl.playing_state > 0:
                    pass
                ddt.rect_a(((x - (w * t) - (s * t)), y), (w, w), cc, True)

            SDL_SetRenderTarget(renderer, None)
            SDL_RenderCopy(renderer, gui.spec_level_tex, None, gui.spec_level_rec)


    if gui.present:
        SDL_SetRenderTarget(renderer, None)
        SDL_RenderPresent(renderer)

        gui.present = False

    # -------------------------------------------------------------------------------------------
    # Misc things to update every tick

    # Broadcast control
    if pctl.broadcast_active and pctl.broadcast_time > pctl.master_library[
            pctl.broadcast_index].length:
        pctl.broadcast_position += 1
        print('next')


        for i, playlist in enumerate(pctl.multi_playlist):
            if playlist[6] == pctl.broadcast_playlist:
                broadcast_playlist = i
                break
        else:
            pctl.broadcast_position = 0
            broadcast_playlist = 0

        if pctl.broadcast_position > len(pctl.multi_playlist[broadcast_playlist][2]) - 1:
            print('reset')
            pctl.broadcast_position = 0

        pctl.broadcast_index = pctl.multi_playlist[broadcast_playlist][2][pctl.broadcast_position]
        pctl.broadcast_time = 0
        pctl.target_open = pctl.master_library[pctl.broadcast_index].fullpath
        pctl.b_start_time = pctl.master_library[pctl.broadcast_index].start_time
        pctl.playerCommand = "cast-next"
        pctl.playerCommandReady = True
        pctl.broadcast_line = pctl.master_library[pctl.broadcast_index].artist + " - " + pctl.master_library[
            pctl.broadcast_index].title

    # elif pctl.join_broadcast and pctl.broadcast_active:
    #     pctl.broadcast_index = pctl.track_queue[pctl.queue_step]
    #     pctl.broadcast_time = pctl.playing_time

    if pctl.broadcast_active and pctl.broadcast_time != pctl.broadcast_last_time:
        pctl.broadcast_last_time = pctl.broadcast_time
        gui.update += 1
    if pctl.broadcast_active and pctl.broadcast_time == 0:
        gui.pl_update = 1

    # Update d-bus metadata on Linux
    if pctl.playing_state == 1 and pctl.mpris is not None:
        pctl.mpris.update_progress()

    # GUI time ticker update
    if (pctl.playing_state == 1 or pctl.playing_state == 3) and gui.lowered is False:
        if int(pctl.playing_time) != int(pctl.last_playing_time):
            pctl.last_playing_time = pctl.playing_time
            bottom_bar1.seek_time = pctl.playing_time
            gui.update = 1

    # Auto save play times to disk
    if pctl.total_playtime - time_last_save > 600:
        print("Auto Save")
        pickle.dump(star_store.db, open(user_directory + "/star.p", "wb"))
        time_last_save = pctl.total_playtime

    # Always render at least one frame per minute (to avoid SDL bugs I guess)
    if min_render_timer.get() > 60:
        min_render_timer.set()
        gui.pl_update = 1
        gui.update += 1

    # Save power if the window is minimized
    if gui.lowered:
        time.sleep(0.2)

# Send scrobble if pending
if lfm_scrobbler.queue and not lfm_scrobbler.running:
    lfm_scrobbler.start_queue()
    print("Sending scrobble before close...")

SDL_DestroyWindow(t_window)

if prefs.reload_play_state and pctl.playing_state in (1, 2):
    print("Saving play state...")
    prefs.reload_state = (pctl.playing_state, pctl.playing_time)

pctl.playerCommand = "unload"
pctl.playerCommandReady = True

pickle.dump(star_store.db, open(user_directory + "/star.p", "wb"))
date = datetime.date.today()
pickle.dump(star_store.db, open(user_directory + "/star.p.backup" + str(date.month), "wb"))


save_state()

if system == "windows":
    tray.stop()

try:
    fp.close()
except:
    print("No lock object to close")

if de_nofity_support:
    song_notification.close()
    Notify.uninit()

print("Unloading SDL...")
SDL_DestroyTexture(gui.main_texture)
SDL_DestroyTexture(gui.ttext)
SDL_DestroyTexture(gui.spec2_tex)
SDL_DestroyTexture(gui.spec1_tex)
SDL_DestroyTexture(gui.spec_level_tex)
ddt.clear_text_cache()
clear_img_cache(False)

IMG_Quit()
SDL_QuitSubSystem(SDL_INIT_EVERYTHING)
SDL_Quit()
print("SDL unloaded")

exit_timer = Timer()
exit_timer.set()
while pctl.playerCommand != 'done' or lfm_scrobbler.running:
    time.sleep(0.1)
    if exit_timer.get() > 3:
        print("Unload timeout")
        break

print("bye")
